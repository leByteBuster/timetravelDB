// Code generated from java-escape by ANTLR 4.11.1. DO NOT EDIT.

package ttql_interface // TTQL
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type TTQLParser struct {
	*antlr.BaseParser
}

var ttqlParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func ttqlParserInit() {
	staticData := &ttqlParserStaticData
	staticData.literalNames = []string{
		"", "';'", "','", "'='", "'+='", "'*'", "'('", "')'", "'['", "']'",
		"':'", "'|'", "'..'", "'<>'", "'<'", "'>'", "'<='", "'>='", "'+'", "'-'",
		"'/'", "'%'", "'^'", "'.'", "'{'", "'}'", "'$'", "'\\u27E8'", "'\\u3008'",
		"'\\uFE64'", "'\\uFF1C'", "'\\u27E9'", "'\\u3009'", "'\\uFE65'", "'\\uFF1E'",
		"'\\u00AD'", "'\\u2010'", "'\\u2011'", "'\\u2012'", "'\\u2013'", "'\\u2014'",
		"'\\u2015'", "'\\u2212'", "'\\uFE58'", "'\\uFE63'", "'\\uFF0D'", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "'0'",
	}
	staticData.symbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "DATETIME", "CURRENT",
		"FROM", "TO", "SHALLOW", "UNION", "ALL", "OPTIONAL", "MATCH", "UNWIND",
		"AS", "MERGE", "ON", "CREATE", "SET", "DETACH", "DELETE", "REMOVE",
		"CALL", "YIELD", "WITH", "RETURN", "DISTINCT", "ORDER", "BY", "L_SKIP",
		"LIMIT", "ASCENDING", "ASC", "DESCENDING", "DESC", "WHERE", "OR", "XOR",
		"AND", "NOT", "STARTS", "ENDS", "CONTAINS", "IN", "IS", "NULL", "COUNT",
		"CASE", "ELSE", "END", "WHEN", "THEN", "ANY", "NONE", "SINGLE", "EXISTS",
		"TRUE", "FALSE", "HexInteger", "DecimalInteger", "OctalInteger", "HexLetter",
		"HexDigit", "Digit", "NonZeroDigit", "NonZeroOctDigit", "OctDigit",
		"ZeroDigit", "ExponentDecimalReal", "RegularDecimalReal", "StringLiteral",
		"EscapedChar", "CONSTRAINT", "DO", "FOR", "REQUIRE", "UNIQUE", "MANDATORY",
		"SCALAR", "OF", "ADD", "DROP", "FILTER", "EXTRACT", "UnescapedSymbolicName",
		"IdentifierStart", "IdentifierPart", "EscapedSymbolicName", "SP", "WHITESPACE",
		"Comment",
	}
	staticData.ruleNames = []string{
		"ttQL", "ttQL_Statement", "ttQL_Query", "ttQL_TimeClause", "oC_Cypher",
		"oC_Statement", "oC_Query", "oC_RegularQuery", "oC_Union", "oC_SingleQuery",
		"oC_SinglePartQuery", "oC_MultiPartQuery", "oC_UpdatingClause", "oC_ReadingClause",
		"oC_Match", "oC_Unwind", "oC_Merge", "oC_MergeAction", "oC_Create",
		"oC_Set", "oC_SetItem", "oC_Delete", "oC_Remove", "oC_RemoveItem", "oC_InQueryCall",
		"oC_StandaloneCall", "oC_YieldItems", "oC_YieldItem", "oC_With", "oC_Return",
		"oC_ProjectionBody", "oC_ProjectionItems", "oC_ProjectionItem", "oC_Order",
		"oC_Skip", "oC_Limit", "oC_SortItem", "oC_Where", "oC_Pattern", "oC_PatternPart",
		"oC_AnonymousPatternPart", "oC_PatternElement", "oC_RelationshipsPattern",
		"oC_NodePattern", "oC_PatternElementChain", "oC_RelationshipPattern",
		"oC_RelationshipDetail", "oC_Properties", "oC_RelationshipTypes", "oC_NodeLabels",
		"oC_NodeLabel", "oC_RangeLiteral", "oC_LabelName", "oC_RelTypeName",
		"oC_PropertyExpression", "oC_Expression", "oC_OrExpression", "oC_XorExpression",
		"oC_AndExpression", "oC_NotExpression", "oC_ComparisonExpression", "oC_PartialComparisonExpression",
		"oC_StringListNullPredicateExpression", "oC_StringPredicateExpression",
		"oC_ListPredicateExpression", "oC_NullPredicateExpression", "oC_AddOrSubtractExpression",
		"oC_MultiplyDivideModuloExpression", "oC_PowerOfExpression", "oC_UnaryAddOrSubtractExpression",
		"oC_ListOperatorExpression", "oC_PropertyOrLabelsExpression", "oC_PropertyLookup",
		"oC_Atom", "oC_CaseExpression", "oC_CaseAlternative", "oC_ListComprehension",
		"oC_PatternComprehension", "oC_Quantifier", "oC_FilterExpression", "oC_PatternPredicate",
		"oC_ParenthesizedExpression", "oC_IdInColl", "oC_FunctionInvocation",
		"oC_FunctionName", "oC_ExistentialSubquery", "oC_ExplicitProcedureInvocation",
		"oC_ImplicitProcedureInvocation", "oC_ProcedureResultField", "oC_ProcedureName",
		"oC_Namespace", "oC_Variable", "oC_Literal", "oC_BooleanLiteral", "oC_NumberLiteral",
		"oC_IntegerLiteral", "oC_DoubleLiteral", "oC_ListLiteral", "oC_MapLiteral",
		"oC_PropertyKeyName", "oC_Parameter", "oC_SchemaName", "oC_ReservedWord",
		"oC_SymbolicName", "oC_LeftArrowHead", "oC_RightArrowHead", "oC_Dash",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 132, 1619, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 1, 0, 3, 0, 216, 8, 0, 1,
		0, 1, 0, 3, 0, 220, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 3,
		2, 229, 8, 2, 1, 3, 1, 3, 3, 3, 233, 8, 3, 1, 3, 1, 3, 3, 3, 237, 8, 3,
		1, 3, 1, 3, 3, 3, 241, 8, 3, 1, 3, 1, 3, 1, 4, 3, 4, 246, 8, 4, 1, 4, 1,
		4, 3, 4, 250, 8, 4, 1, 4, 3, 4, 253, 8, 4, 1, 4, 3, 4, 256, 8, 4, 1, 4,
		1, 4, 1, 5, 1, 5, 1, 6, 1, 6, 3, 6, 264, 8, 6, 1, 7, 1, 7, 3, 7, 268, 8,
		7, 1, 7, 5, 7, 271, 8, 7, 10, 7, 12, 7, 274, 9, 7, 1, 8, 1, 8, 1, 8, 1,
		8, 3, 8, 280, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 285, 8, 8, 1, 8, 3, 8, 288,
		8, 8, 1, 9, 1, 9, 3, 9, 292, 8, 9, 1, 10, 1, 10, 3, 10, 296, 8, 10, 5,
		10, 298, 8, 10, 10, 10, 12, 10, 301, 9, 10, 1, 10, 1, 10, 1, 10, 3, 10,
		306, 8, 10, 5, 10, 308, 8, 10, 10, 10, 12, 10, 311, 9, 10, 1, 10, 1, 10,
		3, 10, 315, 8, 10, 1, 10, 5, 10, 318, 8, 10, 10, 10, 12, 10, 321, 9, 10,
		1, 10, 3, 10, 324, 8, 10, 1, 10, 3, 10, 327, 8, 10, 3, 10, 329, 8, 10,
		1, 11, 1, 11, 3, 11, 333, 8, 11, 5, 11, 335, 8, 11, 10, 11, 12, 11, 338,
		9, 11, 1, 11, 1, 11, 3, 11, 342, 8, 11, 5, 11, 344, 8, 11, 10, 11, 12,
		11, 347, 9, 11, 1, 11, 1, 11, 3, 11, 351, 8, 11, 4, 11, 353, 8, 11, 11,
		11, 12, 11, 354, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12,
		364, 8, 12, 1, 13, 1, 13, 1, 13, 3, 13, 369, 8, 13, 1, 14, 1, 14, 3, 14,
		373, 8, 14, 1, 14, 1, 14, 3, 14, 377, 8, 14, 1, 14, 1, 14, 3, 14, 381,
		8, 14, 1, 14, 3, 14, 384, 8, 14, 1, 15, 1, 15, 3, 15, 388, 8, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 3, 16, 398, 8, 16, 1,
		16, 1, 16, 1, 16, 5, 16, 403, 8, 16, 10, 16, 12, 16, 406, 9, 16, 1, 17,
		1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 418,
		8, 17, 1, 18, 1, 18, 3, 18, 422, 8, 18, 1, 18, 1, 18, 1, 19, 1, 19, 3,
		19, 428, 8, 19, 1, 19, 1, 19, 3, 19, 432, 8, 19, 1, 19, 1, 19, 3, 19, 436,
		8, 19, 1, 19, 5, 19, 439, 8, 19, 10, 19, 12, 19, 442, 9, 19, 1, 20, 1,
		20, 3, 20, 446, 8, 20, 1, 20, 1, 20, 3, 20, 450, 8, 20, 1, 20, 1, 20, 1,
		20, 1, 20, 3, 20, 456, 8, 20, 1, 20, 1, 20, 3, 20, 460, 8, 20, 1, 20, 1,
		20, 1, 20, 1, 20, 3, 20, 466, 8, 20, 1, 20, 1, 20, 3, 20, 470, 8, 20, 1,
		20, 1, 20, 1, 20, 1, 20, 3, 20, 476, 8, 20, 1, 20, 1, 20, 3, 20, 480, 8,
		20, 1, 21, 1, 21, 3, 21, 484, 8, 21, 1, 21, 1, 21, 3, 21, 488, 8, 21, 1,
		21, 1, 21, 3, 21, 492, 8, 21, 1, 21, 1, 21, 3, 21, 496, 8, 21, 1, 21, 5,
		21, 499, 8, 21, 10, 21, 12, 21, 502, 9, 21, 1, 22, 1, 22, 1, 22, 1, 22,
		3, 22, 508, 8, 22, 1, 22, 1, 22, 3, 22, 512, 8, 22, 1, 22, 5, 22, 515,
		8, 22, 10, 22, 12, 22, 518, 9, 22, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 524,
		8, 23, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 530, 8, 24, 1, 24, 1, 24, 1,
		24, 3, 24, 535, 8, 24, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 541, 8, 25, 1,
		25, 3, 25, 544, 8, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 550, 8, 25, 3,
		25, 552, 8, 25, 1, 26, 1, 26, 3, 26, 556, 8, 26, 1, 26, 1, 26, 3, 26, 560,
		8, 26, 1, 26, 5, 26, 563, 8, 26, 10, 26, 12, 26, 566, 9, 26, 1, 26, 3,
		26, 569, 8, 26, 1, 26, 3, 26, 572, 8, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1,
		27, 3, 27, 579, 8, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 3, 28, 586, 8,
		28, 1, 28, 3, 28, 589, 8, 28, 1, 29, 1, 29, 1, 29, 1, 30, 3, 30, 595, 8,
		30, 1, 30, 3, 30, 598, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 604, 8,
		30, 1, 30, 1, 30, 3, 30, 608, 8, 30, 1, 30, 1, 30, 3, 30, 612, 8, 30, 1,
		31, 1, 31, 3, 31, 616, 8, 31, 1, 31, 1, 31, 3, 31, 620, 8, 31, 1, 31, 5,
		31, 623, 8, 31, 10, 31, 12, 31, 626, 9, 31, 1, 31, 1, 31, 3, 31, 630, 8,
		31, 1, 31, 1, 31, 3, 31, 634, 8, 31, 1, 31, 5, 31, 637, 8, 31, 10, 31,
		12, 31, 640, 9, 31, 3, 31, 642, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32,
		1, 32, 1, 32, 3, 32, 651, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 3, 33, 660, 8, 33, 1, 33, 5, 33, 663, 8, 33, 10, 33, 12, 33,
		666, 9, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1,
		36, 1, 36, 3, 36, 678, 8, 36, 1, 36, 3, 36, 681, 8, 36, 1, 37, 1, 37, 1,
		37, 1, 37, 1, 38, 1, 38, 3, 38, 689, 8, 38, 1, 38, 1, 38, 3, 38, 693, 8,
		38, 1, 38, 5, 38, 696, 8, 38, 10, 38, 12, 38, 699, 9, 38, 1, 39, 1, 39,
		3, 39, 703, 8, 39, 1, 39, 1, 39, 3, 39, 707, 8, 39, 1, 39, 1, 39, 1, 39,
		3, 39, 712, 8, 39, 1, 40, 1, 40, 1, 41, 1, 41, 3, 41, 718, 8, 41, 1, 41,
		5, 41, 721, 8, 41, 10, 41, 12, 41, 724, 9, 41, 1, 41, 1, 41, 1, 41, 1,
		41, 3, 41, 730, 8, 41, 1, 42, 1, 42, 3, 42, 734, 8, 42, 1, 42, 4, 42, 737,
		8, 42, 11, 42, 12, 42, 738, 1, 43, 1, 43, 3, 43, 743, 8, 43, 1, 43, 1,
		43, 3, 43, 747, 8, 43, 3, 43, 749, 8, 43, 1, 43, 1, 43, 3, 43, 753, 8,
		43, 3, 43, 755, 8, 43, 1, 43, 1, 43, 3, 43, 759, 8, 43, 3, 43, 761, 8,
		43, 1, 43, 1, 43, 1, 44, 1, 44, 3, 44, 767, 8, 44, 1, 44, 1, 44, 1, 45,
		1, 45, 3, 45, 773, 8, 45, 1, 45, 1, 45, 3, 45, 777, 8, 45, 1, 45, 3, 45,
		780, 8, 45, 1, 45, 3, 45, 783, 8, 45, 1, 45, 1, 45, 3, 45, 787, 8, 45,
		1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 793, 8, 45, 1, 45, 1, 45, 3, 45, 797,
		8, 45, 1, 45, 3, 45, 800, 8, 45, 1, 45, 3, 45, 803, 8, 45, 1, 45, 1, 45,
		1, 45, 1, 45, 3, 45, 809, 8, 45, 1, 45, 3, 45, 812, 8, 45, 1, 45, 3, 45,
		815, 8, 45, 1, 45, 1, 45, 3, 45, 819, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		3, 45, 825, 8, 45, 1, 45, 3, 45, 828, 8, 45, 1, 45, 3, 45, 831, 8, 45,
		1, 45, 1, 45, 3, 45, 835, 8, 45, 1, 46, 1, 46, 3, 46, 839, 8, 46, 1, 46,
		1, 46, 3, 46, 843, 8, 46, 3, 46, 845, 8, 46, 1, 46, 1, 46, 3, 46, 849,
		8, 46, 3, 46, 851, 8, 46, 1, 46, 3, 46, 854, 8, 46, 1, 46, 1, 46, 3, 46,
		858, 8, 46, 3, 46, 860, 8, 46, 1, 46, 1, 46, 1, 47, 1, 47, 3, 47, 866,
		8, 47, 1, 48, 1, 48, 3, 48, 870, 8, 48, 1, 48, 1, 48, 3, 48, 874, 8, 48,
		1, 48, 1, 48, 3, 48, 878, 8, 48, 1, 48, 3, 48, 881, 8, 48, 1, 48, 5, 48,
		884, 8, 48, 10, 48, 12, 48, 887, 9, 48, 1, 49, 1, 49, 3, 49, 891, 8, 49,
		1, 49, 5, 49, 894, 8, 49, 10, 49, 12, 49, 897, 9, 49, 1, 50, 1, 50, 3,
		50, 901, 8, 50, 1, 50, 1, 50, 1, 51, 1, 51, 3, 51, 907, 8, 51, 1, 51, 1,
		51, 3, 51, 911, 8, 51, 3, 51, 913, 8, 51, 1, 51, 1, 51, 3, 51, 917, 8,
		51, 1, 51, 1, 51, 3, 51, 921, 8, 51, 3, 51, 923, 8, 51, 3, 51, 925, 8,
		51, 1, 52, 1, 52, 1, 53, 1, 53, 1, 54, 1, 54, 3, 54, 933, 8, 54, 1, 54,
		4, 54, 936, 8, 54, 11, 54, 12, 54, 937, 1, 55, 1, 55, 1, 56, 1, 56, 1,
		56, 1, 56, 1, 56, 5, 56, 947, 8, 56, 10, 56, 12, 56, 950, 9, 56, 1, 57,
		1, 57, 1, 57, 1, 57, 1, 57, 5, 57, 957, 8, 57, 10, 57, 12, 57, 960, 9,
		57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 5, 58, 967, 8, 58, 10, 58, 12, 58,
		970, 9, 58, 1, 59, 1, 59, 3, 59, 974, 8, 59, 5, 59, 976, 8, 59, 10, 59,
		12, 59, 979, 9, 59, 1, 59, 1, 59, 1, 60, 1, 60, 3, 60, 985, 8, 60, 1, 60,
		5, 60, 988, 8, 60, 10, 60, 12, 60, 991, 9, 60, 1, 61, 1, 61, 3, 61, 995,
		8, 61, 1, 61, 1, 61, 1, 61, 3, 61, 1000, 8, 61, 1, 61, 1, 61, 1, 61, 3,
		61, 1005, 8, 61, 1, 61, 1, 61, 1, 61, 3, 61, 1010, 8, 61, 1, 61, 1, 61,
		1, 61, 3, 61, 1015, 8, 61, 1, 61, 1, 61, 1, 61, 3, 61, 1020, 8, 61, 1,
		61, 3, 61, 1023, 8, 61, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62, 1029, 8, 62,
		10, 62, 12, 62, 1032, 9, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 1044, 8, 63, 1, 63, 3, 63, 1047, 8,
		63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 3, 64, 1054, 8, 64, 1, 64, 1, 64,
		1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3,
		65, 1068, 8, 65, 1, 66, 1, 66, 3, 66, 1072, 8, 66, 1, 66, 1, 66, 3, 66,
		1076, 8, 66, 1, 66, 1, 66, 3, 66, 1080, 8, 66, 1, 66, 1, 66, 3, 66, 1084,
		8, 66, 1, 66, 5, 66, 1087, 8, 66, 10, 66, 12, 66, 1090, 9, 66, 1, 67, 1,
		67, 3, 67, 1094, 8, 67, 1, 67, 1, 67, 3, 67, 1098, 8, 67, 1, 67, 1, 67,
		3, 67, 1102, 8, 67, 1, 67, 1, 67, 3, 67, 1106, 8, 67, 1, 67, 1, 67, 3,
		67, 1110, 8, 67, 1, 67, 1, 67, 3, 67, 1114, 8, 67, 1, 67, 5, 67, 1117,
		8, 67, 10, 67, 12, 67, 1120, 9, 67, 1, 68, 1, 68, 3, 68, 1124, 8, 68, 1,
		68, 1, 68, 3, 68, 1128, 8, 68, 1, 68, 5, 68, 1131, 8, 68, 10, 68, 12, 68,
		1134, 9, 68, 1, 69, 1, 69, 1, 69, 3, 69, 1139, 8, 69, 1, 69, 3, 69, 1142,
		8, 69, 1, 70, 1, 70, 3, 70, 1146, 8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1,
		70, 3, 70, 1153, 8, 70, 1, 70, 1, 70, 3, 70, 1157, 8, 70, 1, 70, 1, 70,
		3, 70, 1161, 8, 70, 1, 70, 5, 70, 1164, 8, 70, 10, 70, 12, 70, 1167, 9,
		70, 1, 71, 1, 71, 3, 71, 1171, 8, 71, 1, 71, 5, 71, 1174, 8, 71, 10, 71,
		12, 71, 1177, 9, 71, 1, 71, 3, 71, 1180, 8, 71, 1, 71, 3, 71, 1183, 8,
		71, 1, 72, 1, 72, 3, 72, 1187, 8, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 3, 73, 1196, 8, 73, 1, 73, 1, 73, 3, 73, 1200, 8, 73, 1,
		73, 1, 73, 3, 73, 1204, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 3, 73, 1215, 8, 73, 1, 74, 1, 74, 3, 74, 1219, 8,
		74, 1, 74, 4, 74, 1222, 8, 74, 11, 74, 12, 74, 1223, 1, 74, 1, 74, 3, 74,
		1228, 8, 74, 1, 74, 1, 74, 3, 74, 1232, 8, 74, 1, 74, 4, 74, 1235, 8, 74,
		11, 74, 12, 74, 1236, 3, 74, 1239, 8, 74, 1, 74, 3, 74, 1242, 8, 74, 1,
		74, 1, 74, 3, 74, 1246, 8, 74, 1, 74, 3, 74, 1249, 8, 74, 1, 74, 3, 74,
		1252, 8, 74, 1, 74, 1, 74, 1, 75, 1, 75, 3, 75, 1258, 8, 75, 1, 75, 1,
		75, 3, 75, 1262, 8, 75, 1, 75, 1, 75, 3, 75, 1266, 8, 75, 1, 75, 1, 75,
		1, 76, 1, 76, 3, 76, 1272, 8, 76, 1, 76, 1, 76, 3, 76, 1276, 8, 76, 1,
		76, 1, 76, 3, 76, 1280, 8, 76, 1, 76, 3, 76, 1283, 8, 76, 1, 76, 3, 76,
		1286, 8, 76, 1, 76, 1, 76, 1, 77, 1, 77, 3, 77, 1292, 8, 77, 1, 77, 1,
		77, 3, 77, 1296, 8, 77, 1, 77, 1, 77, 3, 77, 1300, 8, 77, 3, 77, 1302,
		8, 77, 1, 77, 1, 77, 3, 77, 1306, 8, 77, 1, 77, 1, 77, 3, 77, 1310, 8,
		77, 3, 77, 1312, 8, 77, 1, 77, 1, 77, 3, 77, 1316, 8, 77, 1, 77, 1, 77,
		3, 77, 1320, 8, 77, 1, 77, 1, 77, 1, 78, 1, 78, 3, 78, 1326, 8, 78, 1,
		78, 1, 78, 3, 78, 1330, 8, 78, 1, 78, 1, 78, 3, 78, 1334, 8, 78, 1, 78,
		1, 78, 1, 78, 1, 78, 3, 78, 1340, 8, 78, 1, 78, 1, 78, 3, 78, 1344, 8,
		78, 1, 78, 1, 78, 3, 78, 1348, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78,
		1354, 8, 78, 1, 78, 1, 78, 3, 78, 1358, 8, 78, 1, 78, 1, 78, 3, 78, 1362,
		8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1368, 8, 78, 1, 78, 1, 78, 3,
		78, 1372, 8, 78, 1, 78, 1, 78, 3, 78, 1376, 8, 78, 1, 78, 1, 78, 3, 78,
		1380, 8, 78, 1, 79, 1, 79, 3, 79, 1384, 8, 79, 1, 79, 3, 79, 1387, 8, 79,
		1, 80, 1, 80, 1, 81, 1, 81, 3, 81, 1393, 8, 81, 1, 81, 1, 81, 3, 81, 1397,
		8, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1,
		83, 3, 83, 1409, 8, 83, 1, 83, 1, 83, 3, 83, 1413, 8, 83, 1, 83, 1, 83,
		3, 83, 1417, 8, 83, 3, 83, 1419, 8, 83, 1, 83, 1, 83, 3, 83, 1423, 8, 83,
		1, 83, 1, 83, 3, 83, 1427, 8, 83, 1, 83, 1, 83, 3, 83, 1431, 8, 83, 5,
		83, 1433, 8, 83, 10, 83, 12, 83, 1436, 9, 83, 3, 83, 1438, 8, 83, 1, 83,
		1, 83, 1, 84, 1, 84, 1, 84, 1, 85, 1, 85, 3, 85, 1447, 8, 85, 1, 85, 1,
		85, 3, 85, 1451, 8, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1456, 8, 85, 1, 85,
		3, 85, 1459, 8, 85, 3, 85, 1461, 8, 85, 1, 85, 3, 85, 1464, 8, 85, 1, 85,
		1, 85, 1, 86, 1, 86, 3, 86, 1470, 8, 86, 1, 86, 1, 86, 3, 86, 1474, 8,
		86, 1, 86, 1, 86, 3, 86, 1478, 8, 86, 1, 86, 1, 86, 3, 86, 1482, 8, 86,
		1, 86, 1, 86, 3, 86, 1486, 8, 86, 5, 86, 1488, 8, 86, 10, 86, 12, 86, 1491,
		9, 86, 3, 86, 1493, 8, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 88, 1, 88, 1,
		89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 5, 90, 1507, 8, 90, 10, 90, 12,
		90, 1510, 9, 90, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92,
		3, 92, 1520, 8, 92, 1, 93, 1, 93, 1, 94, 1, 94, 3, 94, 1526, 8, 94, 1,
		95, 1, 95, 1, 96, 1, 96, 1, 97, 1, 97, 3, 97, 1534, 8, 97, 1, 97, 1, 97,
		3, 97, 1538, 8, 97, 1, 97, 1, 97, 3, 97, 1542, 8, 97, 1, 97, 1, 97, 3,
		97, 1546, 8, 97, 5, 97, 1548, 8, 97, 10, 97, 12, 97, 1551, 9, 97, 3, 97,
		1553, 8, 97, 1, 97, 1, 97, 1, 98, 1, 98, 3, 98, 1559, 8, 98, 1, 98, 1,
		98, 3, 98, 1563, 8, 98, 1, 98, 1, 98, 3, 98, 1567, 8, 98, 1, 98, 1, 98,
		3, 98, 1571, 8, 98, 1, 98, 1, 98, 3, 98, 1575, 8, 98, 1, 98, 1, 98, 3,
		98, 1579, 8, 98, 1, 98, 1, 98, 3, 98, 1583, 8, 98, 1, 98, 1, 98, 3, 98,
		1587, 8, 98, 5, 98, 1589, 8, 98, 10, 98, 12, 98, 1592, 9, 98, 3, 98, 1594,
		8, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 100, 1, 100, 1, 100, 3, 100, 1603,
		8, 100, 1, 101, 1, 101, 3, 101, 1607, 8, 101, 1, 102, 1, 102, 1, 103, 1,
		103, 1, 104, 1, 104, 1, 105, 1, 105, 1, 106, 1, 106, 1, 106, 0, 0, 107,
		0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36,
		38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72,
		74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106,
		108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136,
		138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166,
		168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196,
		198, 200, 202, 204, 206, 208, 210, 212, 0, 11, 1, 0, 46, 47, 1, 0, 73,
		76, 1, 0, 18, 19, 1, 0, 98, 99, 1, 0, 100, 102, 1, 0, 110, 111, 5, 0, 51,
		63, 66, 87, 89, 93, 97, 99, 114, 123, 5, 0, 88, 88, 94, 96, 103, 103, 124,
		126, 129, 129, 2, 0, 14, 14, 27, 30, 2, 0, 15, 15, 31, 34, 2, 0, 19, 19,
		35, 45, 1840, 0, 215, 1, 0, 0, 0, 2, 223, 1, 0, 0, 0, 4, 225, 1, 0, 0,
		0, 6, 230, 1, 0, 0, 0, 8, 245, 1, 0, 0, 0, 10, 259, 1, 0, 0, 0, 12, 263,
		1, 0, 0, 0, 14, 265, 1, 0, 0, 0, 16, 287, 1, 0, 0, 0, 18, 291, 1, 0, 0,
		0, 20, 328, 1, 0, 0, 0, 22, 352, 1, 0, 0, 0, 24, 363, 1, 0, 0, 0, 26, 368,
		1, 0, 0, 0, 28, 372, 1, 0, 0, 0, 30, 385, 1, 0, 0, 0, 32, 395, 1, 0, 0,
		0, 34, 417, 1, 0, 0, 0, 36, 419, 1, 0, 0, 0, 38, 425, 1, 0, 0, 0, 40, 479,
		1, 0, 0, 0, 42, 483, 1, 0, 0, 0, 44, 503, 1, 0, 0, 0, 46, 523, 1, 0, 0,
		0, 48, 525, 1, 0, 0, 0, 50, 536, 1, 0, 0, 0, 52, 553, 1, 0, 0, 0, 54, 578,
		1, 0, 0, 0, 56, 582, 1, 0, 0, 0, 58, 590, 1, 0, 0, 0, 60, 597, 1, 0, 0,
		0, 62, 641, 1, 0, 0, 0, 64, 650, 1, 0, 0, 0, 66, 652, 1, 0, 0, 0, 68, 667,
		1, 0, 0, 0, 70, 671, 1, 0, 0, 0, 72, 675, 1, 0, 0, 0, 74, 682, 1, 0, 0,
		0, 76, 686, 1, 0, 0, 0, 78, 711, 1, 0, 0, 0, 80, 713, 1, 0, 0, 0, 82, 729,
		1, 0, 0, 0, 84, 731, 1, 0, 0, 0, 86, 740, 1, 0, 0, 0, 88, 764, 1, 0, 0,
		0, 90, 834, 1, 0, 0, 0, 92, 836, 1, 0, 0, 0, 94, 865, 1, 0, 0, 0, 96, 867,
		1, 0, 0, 0, 98, 888, 1, 0, 0, 0, 100, 898, 1, 0, 0, 0, 102, 904, 1, 0,
		0, 0, 104, 926, 1, 0, 0, 0, 106, 928, 1, 0, 0, 0, 108, 930, 1, 0, 0, 0,
		110, 939, 1, 0, 0, 0, 112, 941, 1, 0, 0, 0, 114, 951, 1, 0, 0, 0, 116,
		961, 1, 0, 0, 0, 118, 977, 1, 0, 0, 0, 120, 982, 1, 0, 0, 0, 122, 1022,
		1, 0, 0, 0, 124, 1024, 1, 0, 0, 0, 126, 1043, 1, 0, 0, 0, 128, 1050, 1,
		0, 0, 0, 130, 1067, 1, 0, 0, 0, 132, 1069, 1, 0, 0, 0, 134, 1091, 1, 0,
		0, 0, 136, 1121, 1, 0, 0, 0, 138, 1141, 1, 0, 0, 0, 140, 1143, 1, 0, 0,
		0, 142, 1168, 1, 0, 0, 0, 144, 1184, 1, 0, 0, 0, 146, 1214, 1, 0, 0, 0,
		148, 1238, 1, 0, 0, 0, 150, 1255, 1, 0, 0, 0, 152, 1269, 1, 0, 0, 0, 154,
		1289, 1, 0, 0, 0, 156, 1379, 1, 0, 0, 0, 158, 1381, 1, 0, 0, 0, 160, 1388,
		1, 0, 0, 0, 162, 1390, 1, 0, 0, 0, 164, 1400, 1, 0, 0, 0, 166, 1406, 1,
		0, 0, 0, 168, 1441, 1, 0, 0, 0, 170, 1444, 1, 0, 0, 0, 172, 1467, 1, 0,
		0, 0, 174, 1496, 1, 0, 0, 0, 176, 1498, 1, 0, 0, 0, 178, 1500, 1, 0, 0,
		0, 180, 1508, 1, 0, 0, 0, 182, 1511, 1, 0, 0, 0, 184, 1519, 1, 0, 0, 0,
		186, 1521, 1, 0, 0, 0, 188, 1525, 1, 0, 0, 0, 190, 1527, 1, 0, 0, 0, 192,
		1529, 1, 0, 0, 0, 194, 1531, 1, 0, 0, 0, 196, 1556, 1, 0, 0, 0, 198, 1597,
		1, 0, 0, 0, 200, 1599, 1, 0, 0, 0, 202, 1606, 1, 0, 0, 0, 204, 1608, 1,
		0, 0, 0, 206, 1610, 1, 0, 0, 0, 208, 1612, 1, 0, 0, 0, 210, 1614, 1, 0,
		0, 0, 212, 1616, 1, 0, 0, 0, 214, 216, 5, 130, 0, 0, 215, 214, 1, 0, 0,
		0, 215, 216, 1, 0, 0, 0, 216, 217, 1, 0, 0, 0, 217, 219, 3, 2, 1, 0, 218,
		220, 5, 130, 0, 0, 219, 218, 1, 0, 0, 0, 219, 220, 1, 0, 0, 0, 220, 221,
		1, 0, 0, 0, 221, 222, 3, 8, 4, 0, 222, 1, 1, 0, 0, 0, 223, 224, 3, 4, 2,
		0, 224, 3, 1, 0, 0, 0, 225, 226, 3, 6, 3, 0, 226, 228, 5, 130, 0, 0, 227,
		229, 5, 50, 0, 0, 228, 227, 1, 0, 0, 0, 228, 229, 1, 0, 0, 0, 229, 5, 1,
		0, 0, 0, 230, 232, 5, 48, 0, 0, 231, 233, 5, 130, 0, 0, 232, 231, 1, 0,
		0, 0, 232, 233, 1, 0, 0, 0, 233, 234, 1, 0, 0, 0, 234, 236, 7, 0, 0, 0,
		235, 237, 5, 130, 0, 0, 236, 235, 1, 0, 0, 0, 236, 237, 1, 0, 0, 0, 237,
		238, 1, 0, 0, 0, 238, 240, 5, 49, 0, 0, 239, 241, 5, 130, 0, 0, 240, 239,
		1, 0, 0, 0, 240, 241, 1, 0, 0, 0, 241, 242, 1, 0, 0, 0, 242, 243, 7, 0,
		0, 0, 243, 7, 1, 0, 0, 0, 244, 246, 5, 130, 0, 0, 245, 244, 1, 0, 0, 0,
		245, 246, 1, 0, 0, 0, 246, 247, 1, 0, 0, 0, 247, 252, 3, 10, 5, 0, 248,
		250, 5, 130, 0, 0, 249, 248, 1, 0, 0, 0, 249, 250, 1, 0, 0, 0, 250, 251,
		1, 0, 0, 0, 251, 253, 5, 1, 0, 0, 252, 249, 1, 0, 0, 0, 252, 253, 1, 0,
		0, 0, 253, 255, 1, 0, 0, 0, 254, 256, 5, 130, 0, 0, 255, 254, 1, 0, 0,
		0, 255, 256, 1, 0, 0, 0, 256, 257, 1, 0, 0, 0, 257, 258, 5, 0, 0, 1, 258,
		9, 1, 0, 0, 0, 259, 260, 3, 12, 6, 0, 260, 11, 1, 0, 0, 0, 261, 264, 3,
		14, 7, 0, 262, 264, 3, 50, 25, 0, 263, 261, 1, 0, 0, 0, 263, 262, 1, 0,
		0, 0, 264, 13, 1, 0, 0, 0, 265, 272, 3, 18, 9, 0, 266, 268, 5, 130, 0,
		0, 267, 266, 1, 0, 0, 0, 267, 268, 1, 0, 0, 0, 268, 269, 1, 0, 0, 0, 269,
		271, 3, 16, 8, 0, 270, 267, 1, 0, 0, 0, 271, 274, 1, 0, 0, 0, 272, 270,
		1, 0, 0, 0, 272, 273, 1, 0, 0, 0, 273, 15, 1, 0, 0, 0, 274, 272, 1, 0,
		0, 0, 275, 276, 5, 51, 0, 0, 276, 277, 5, 130, 0, 0, 277, 279, 5, 52, 0,
		0, 278, 280, 5, 130, 0, 0, 279, 278, 1, 0, 0, 0, 279, 280, 1, 0, 0, 0,
		280, 281, 1, 0, 0, 0, 281, 288, 3, 18, 9, 0, 282, 284, 5, 51, 0, 0, 283,
		285, 5, 130, 0, 0, 284, 283, 1, 0, 0, 0, 284, 285, 1, 0, 0, 0, 285, 286,
		1, 0, 0, 0, 286, 288, 3, 18, 9, 0, 287, 275, 1, 0, 0, 0, 287, 282, 1, 0,
		0, 0, 288, 17, 1, 0, 0, 0, 289, 292, 3, 20, 10, 0, 290, 292, 3, 22, 11,
		0, 291, 289, 1, 0, 0, 0, 291, 290, 1, 0, 0, 0, 292, 19, 1, 0, 0, 0, 293,
		295, 3, 26, 13, 0, 294, 296, 5, 130, 0, 0, 295, 294, 1, 0, 0, 0, 295, 296,
		1, 0, 0, 0, 296, 298, 1, 0, 0, 0, 297, 293, 1, 0, 0, 0, 298, 301, 1, 0,
		0, 0, 299, 297, 1, 0, 0, 0, 299, 300, 1, 0, 0, 0, 300, 302, 1, 0, 0, 0,
		301, 299, 1, 0, 0, 0, 302, 329, 3, 58, 29, 0, 303, 305, 3, 26, 13, 0, 304,
		306, 5, 130, 0, 0, 305, 304, 1, 0, 0, 0, 305, 306, 1, 0, 0, 0, 306, 308,
		1, 0, 0, 0, 307, 303, 1, 0, 0, 0, 308, 311, 1, 0, 0, 0, 309, 307, 1, 0,
		0, 0, 309, 310, 1, 0, 0, 0, 310, 312, 1, 0, 0, 0, 311, 309, 1, 0, 0, 0,
		312, 319, 3, 24, 12, 0, 313, 315, 5, 130, 0, 0, 314, 313, 1, 0, 0, 0, 314,
		315, 1, 0, 0, 0, 315, 316, 1, 0, 0, 0, 316, 318, 3, 24, 12, 0, 317, 314,
		1, 0, 0, 0, 318, 321, 1, 0, 0, 0, 319, 317, 1, 0, 0, 0, 319, 320, 1, 0,
		0, 0, 320, 326, 1, 0, 0, 0, 321, 319, 1, 0, 0, 0, 322, 324, 5, 130, 0,
		0, 323, 322, 1, 0, 0, 0, 323, 324, 1, 0, 0, 0, 324, 325, 1, 0, 0, 0, 325,
		327, 3, 58, 29, 0, 326, 323, 1, 0, 0, 0, 326, 327, 1, 0, 0, 0, 327, 329,
		1, 0, 0, 0, 328, 299, 1, 0, 0, 0, 328, 309, 1, 0, 0, 0, 329, 21, 1, 0,
		0, 0, 330, 332, 3, 26, 13, 0, 331, 333, 5, 130, 0, 0, 332, 331, 1, 0, 0,
		0, 332, 333, 1, 0, 0, 0, 333, 335, 1, 0, 0, 0, 334, 330, 1, 0, 0, 0, 335,
		338, 1, 0, 0, 0, 336, 334, 1, 0, 0, 0, 336, 337, 1, 0, 0, 0, 337, 345,
		1, 0, 0, 0, 338, 336, 1, 0, 0, 0, 339, 341, 3, 24, 12, 0, 340, 342, 5,
		130, 0, 0, 341, 340, 1, 0, 0, 0, 341, 342, 1, 0, 0, 0, 342, 344, 1, 0,
		0, 0, 343, 339, 1, 0, 0, 0, 344, 347, 1, 0, 0, 0, 345, 343, 1, 0, 0, 0,
		345, 346, 1, 0, 0, 0, 346, 348, 1, 0, 0, 0, 347, 345, 1, 0, 0, 0, 348,
		350, 3, 56, 28, 0, 349, 351, 5, 130, 0, 0, 350, 349, 1, 0, 0, 0, 350, 351,
		1, 0, 0, 0, 351, 353, 1, 0, 0, 0, 352, 336, 1, 0, 0, 0, 353, 354, 1, 0,
		0, 0, 354, 352, 1, 0, 0, 0, 354, 355, 1, 0, 0, 0, 355, 356, 1, 0, 0, 0,
		356, 357, 3, 20, 10, 0, 357, 23, 1, 0, 0, 0, 358, 364, 3, 36, 18, 0, 359,
		364, 3, 32, 16, 0, 360, 364, 3, 42, 21, 0, 361, 364, 3, 38, 19, 0, 362,
		364, 3, 44, 22, 0, 363, 358, 1, 0, 0, 0, 363, 359, 1, 0, 0, 0, 363, 360,
		1, 0, 0, 0, 363, 361, 1, 0, 0, 0, 363, 362, 1, 0, 0, 0, 364, 25, 1, 0,
		0, 0, 365, 369, 3, 28, 14, 0, 366, 369, 3, 30, 15, 0, 367, 369, 3, 48,
		24, 0, 368, 365, 1, 0, 0, 0, 368, 366, 1, 0, 0, 0, 368, 367, 1, 0, 0, 0,
		369, 27, 1, 0, 0, 0, 370, 371, 5, 53, 0, 0, 371, 373, 5, 130, 0, 0, 372,
		370, 1, 0, 0, 0, 372, 373, 1, 0, 0, 0, 373, 374, 1, 0, 0, 0, 374, 376,
		5, 54, 0, 0, 375, 377, 5, 130, 0, 0, 376, 375, 1, 0, 0, 0, 376, 377, 1,
		0, 0, 0, 377, 378, 1, 0, 0, 0, 378, 383, 3, 76, 38, 0, 379, 381, 5, 130,
		0, 0, 380, 379, 1, 0, 0, 0, 380, 381, 1, 0, 0, 0, 381, 382, 1, 0, 0, 0,
		382, 384, 3, 74, 37, 0, 383, 380, 1, 0, 0, 0, 383, 384, 1, 0, 0, 0, 384,
		29, 1, 0, 0, 0, 385, 387, 5, 55, 0, 0, 386, 388, 5, 130, 0, 0, 387, 386,
		1, 0, 0, 0, 387, 388, 1, 0, 0, 0, 388, 389, 1, 0, 0, 0, 389, 390, 3, 110,
		55, 0, 390, 391, 5, 130, 0, 0, 391, 392, 5, 56, 0, 0, 392, 393, 5, 130,
		0, 0, 393, 394, 3, 182, 91, 0, 394, 31, 1, 0, 0, 0, 395, 397, 5, 57, 0,
		0, 396, 398, 5, 130, 0, 0, 397, 396, 1, 0, 0, 0, 397, 398, 1, 0, 0, 0,
		398, 399, 1, 0, 0, 0, 399, 404, 3, 78, 39, 0, 400, 401, 5, 130, 0, 0, 401,
		403, 3, 34, 17, 0, 402, 400, 1, 0, 0, 0, 403, 406, 1, 0, 0, 0, 404, 402,
		1, 0, 0, 0, 404, 405, 1, 0, 0, 0, 405, 33, 1, 0, 0, 0, 406, 404, 1, 0,
		0, 0, 407, 408, 5, 58, 0, 0, 408, 409, 5, 130, 0, 0, 409, 410, 5, 54, 0,
		0, 410, 411, 5, 130, 0, 0, 411, 418, 3, 38, 19, 0, 412, 413, 5, 58, 0,
		0, 413, 414, 5, 130, 0, 0, 414, 415, 5, 59, 0, 0, 415, 416, 5, 130, 0,
		0, 416, 418, 3, 38, 19, 0, 417, 407, 1, 0, 0, 0, 417, 412, 1, 0, 0, 0,
		418, 35, 1, 0, 0, 0, 419, 421, 5, 59, 0, 0, 420, 422, 5, 130, 0, 0, 421,
		420, 1, 0, 0, 0, 421, 422, 1, 0, 0, 0, 422, 423, 1, 0, 0, 0, 423, 424,
		3, 76, 38, 0, 424, 37, 1, 0, 0, 0, 425, 427, 5, 60, 0, 0, 426, 428, 5,
		130, 0, 0, 427, 426, 1, 0, 0, 0, 427, 428, 1, 0, 0, 0, 428, 429, 1, 0,
		0, 0, 429, 440, 3, 40, 20, 0, 430, 432, 5, 130, 0, 0, 431, 430, 1, 0, 0,
		0, 431, 432, 1, 0, 0, 0, 432, 433, 1, 0, 0, 0, 433, 435, 5, 2, 0, 0, 434,
		436, 5, 130, 0, 0, 435, 434, 1, 0, 0, 0, 435, 436, 1, 0, 0, 0, 436, 437,
		1, 0, 0, 0, 437, 439, 3, 40, 20, 0, 438, 431, 1, 0, 0, 0, 439, 442, 1,
		0, 0, 0, 440, 438, 1, 0, 0, 0, 440, 441, 1, 0, 0, 0, 441, 39, 1, 0, 0,
		0, 442, 440, 1, 0, 0, 0, 443, 445, 3, 108, 54, 0, 444, 446, 5, 130, 0,
		0, 445, 444, 1, 0, 0, 0, 445, 446, 1, 0, 0, 0, 446, 447, 1, 0, 0, 0, 447,
		449, 5, 3, 0, 0, 448, 450, 5, 130, 0, 0, 449, 448, 1, 0, 0, 0, 449, 450,
		1, 0, 0, 0, 450, 451, 1, 0, 0, 0, 451, 452, 3, 110, 55, 0, 452, 480, 1,
		0, 0, 0, 453, 455, 3, 182, 91, 0, 454, 456, 5, 130, 0, 0, 455, 454, 1,
		0, 0, 0, 455, 456, 1, 0, 0, 0, 456, 457, 1, 0, 0, 0, 457, 459, 5, 3, 0,
		0, 458, 460, 5, 130, 0, 0, 459, 458, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0,
		460, 461, 1, 0, 0, 0, 461, 462, 3, 110, 55, 0, 462, 480, 1, 0, 0, 0, 463,
		465, 3, 182, 91, 0, 464, 466, 5, 130, 0, 0, 465, 464, 1, 0, 0, 0, 465,
		466, 1, 0, 0, 0, 466, 467, 1, 0, 0, 0, 467, 469, 5, 4, 0, 0, 468, 470,
		5, 130, 0, 0, 469, 468, 1, 0, 0, 0, 469, 470, 1, 0, 0, 0, 470, 471, 1,
		0, 0, 0, 471, 472, 3, 110, 55, 0, 472, 480, 1, 0, 0, 0, 473, 475, 3, 182,
		91, 0, 474, 476, 5, 130, 0, 0, 475, 474, 1, 0, 0, 0, 475, 476, 1, 0, 0,
		0, 476, 477, 1, 0, 0, 0, 477, 478, 3, 98, 49, 0, 478, 480, 1, 0, 0, 0,
		479, 443, 1, 0, 0, 0, 479, 453, 1, 0, 0, 0, 479, 463, 1, 0, 0, 0, 479,
		473, 1, 0, 0, 0, 480, 41, 1, 0, 0, 0, 481, 482, 5, 61, 0, 0, 482, 484,
		5, 130, 0, 0, 483, 481, 1, 0, 0, 0, 483, 484, 1, 0, 0, 0, 484, 485, 1,
		0, 0, 0, 485, 487, 5, 62, 0, 0, 486, 488, 5, 130, 0, 0, 487, 486, 1, 0,
		0, 0, 487, 488, 1, 0, 0, 0, 488, 489, 1, 0, 0, 0, 489, 500, 3, 110, 55,
		0, 490, 492, 5, 130, 0, 0, 491, 490, 1, 0, 0, 0, 491, 492, 1, 0, 0, 0,
		492, 493, 1, 0, 0, 0, 493, 495, 5, 2, 0, 0, 494, 496, 5, 130, 0, 0, 495,
		494, 1, 0, 0, 0, 495, 496, 1, 0, 0, 0, 496, 497, 1, 0, 0, 0, 497, 499,
		3, 110, 55, 0, 498, 491, 1, 0, 0, 0, 499, 502, 1, 0, 0, 0, 500, 498, 1,
		0, 0, 0, 500, 501, 1, 0, 0, 0, 501, 43, 1, 0, 0, 0, 502, 500, 1, 0, 0,
		0, 503, 504, 5, 63, 0, 0, 504, 505, 5, 130, 0, 0, 505, 516, 3, 46, 23,
		0, 506, 508, 5, 130, 0, 0, 507, 506, 1, 0, 0, 0, 507, 508, 1, 0, 0, 0,
		508, 509, 1, 0, 0, 0, 509, 511, 5, 2, 0, 0, 510, 512, 5, 130, 0, 0, 511,
		510, 1, 0, 0, 0, 511, 512, 1, 0, 0, 0, 512, 513, 1, 0, 0, 0, 513, 515,
		3, 46, 23, 0, 514, 507, 1, 0, 0, 0, 515, 518, 1, 0, 0, 0, 516, 514, 1,
		0, 0, 0, 516, 517, 1, 0, 0, 0, 517, 45, 1, 0, 0, 0, 518, 516, 1, 0, 0,
		0, 519, 520, 3, 182, 91, 0, 520, 521, 3, 98, 49, 0, 521, 524, 1, 0, 0,
		0, 522, 524, 3, 108, 54, 0, 523, 519, 1, 0, 0, 0, 523, 522, 1, 0, 0, 0,
		524, 47, 1, 0, 0, 0, 525, 526, 5, 64, 0, 0, 526, 527, 5, 130, 0, 0, 527,
		534, 3, 172, 86, 0, 528, 530, 5, 130, 0, 0, 529, 528, 1, 0, 0, 0, 529,
		530, 1, 0, 0, 0, 530, 531, 1, 0, 0, 0, 531, 532, 5, 65, 0, 0, 532, 533,
		5, 130, 0, 0, 533, 535, 3, 52, 26, 0, 534, 529, 1, 0, 0, 0, 534, 535, 1,
		0, 0, 0, 535, 49, 1, 0, 0, 0, 536, 537, 5, 64, 0, 0, 537, 540, 5, 130,
		0, 0, 538, 541, 3, 172, 86, 0, 539, 541, 3, 174, 87, 0, 540, 538, 1, 0,
		0, 0, 540, 539, 1, 0, 0, 0, 541, 551, 1, 0, 0, 0, 542, 544, 5, 130, 0,
		0, 543, 542, 1, 0, 0, 0, 543, 544, 1, 0, 0, 0, 544, 545, 1, 0, 0, 0, 545,
		546, 5, 65, 0, 0, 546, 549, 5, 130, 0, 0, 547, 550, 5, 5, 0, 0, 548, 550,
		3, 52, 26, 0, 549, 547, 1, 0, 0, 0, 549, 548, 1, 0, 0, 0, 550, 552, 1,
		0, 0, 0, 551, 543, 1, 0, 0, 0, 551, 552, 1, 0, 0, 0, 552, 51, 1, 0, 0,
		0, 553, 564, 3, 54, 27, 0, 554, 556, 5, 130, 0, 0, 555, 554, 1, 0, 0, 0,
		555, 556, 1, 0, 0, 0, 556, 557, 1, 0, 0, 0, 557, 559, 5, 2, 0, 0, 558,
		560, 5, 130, 0, 0, 559, 558, 1, 0, 0, 0, 559, 560, 1, 0, 0, 0, 560, 561,
		1, 0, 0, 0, 561, 563, 3, 54, 27, 0, 562, 555, 1, 0, 0, 0, 563, 566, 1,
		0, 0, 0, 564, 562, 1, 0, 0, 0, 564, 565, 1, 0, 0, 0, 565, 571, 1, 0, 0,
		0, 566, 564, 1, 0, 0, 0, 567, 569, 5, 130, 0, 0, 568, 567, 1, 0, 0, 0,
		568, 569, 1, 0, 0, 0, 569, 570, 1, 0, 0, 0, 570, 572, 3, 74, 37, 0, 571,
		568, 1, 0, 0, 0, 571, 572, 1, 0, 0, 0, 572, 53, 1, 0, 0, 0, 573, 574, 3,
		176, 88, 0, 574, 575, 5, 130, 0, 0, 575, 576, 5, 56, 0, 0, 576, 577, 5,
		130, 0, 0, 577, 579, 1, 0, 0, 0, 578, 573, 1, 0, 0, 0, 578, 579, 1, 0,
		0, 0, 579, 580, 1, 0, 0, 0, 580, 581, 3, 182, 91, 0, 581, 55, 1, 0, 0,
		0, 582, 583, 5, 66, 0, 0, 583, 588, 3, 60, 30, 0, 584, 586, 5, 130, 0,
		0, 585, 584, 1, 0, 0, 0, 585, 586, 1, 0, 0, 0, 586, 587, 1, 0, 0, 0, 587,
		589, 3, 74, 37, 0, 588, 585, 1, 0, 0, 0, 588, 589, 1, 0, 0, 0, 589, 57,
		1, 0, 0, 0, 590, 591, 5, 67, 0, 0, 591, 592, 3, 60, 30, 0, 592, 59, 1,
		0, 0, 0, 593, 595, 5, 130, 0, 0, 594, 593, 1, 0, 0, 0, 594, 595, 1, 0,
		0, 0, 595, 596, 1, 0, 0, 0, 596, 598, 5, 68, 0, 0, 597, 594, 1, 0, 0, 0,
		597, 598, 1, 0, 0, 0, 598, 599, 1, 0, 0, 0, 599, 600, 5, 130, 0, 0, 600,
		603, 3, 62, 31, 0, 601, 602, 5, 130, 0, 0, 602, 604, 3, 66, 33, 0, 603,
		601, 1, 0, 0, 0, 603, 604, 1, 0, 0, 0, 604, 607, 1, 0, 0, 0, 605, 606,
		5, 130, 0, 0, 606, 608, 3, 68, 34, 0, 607, 605, 1, 0, 0, 0, 607, 608, 1,
		0, 0, 0, 608, 611, 1, 0, 0, 0, 609, 610, 5, 130, 0, 0, 610, 612, 3, 70,
		35, 0, 611, 609, 1, 0, 0, 0, 611, 612, 1, 0, 0, 0, 612, 61, 1, 0, 0, 0,
		613, 624, 5, 5, 0, 0, 614, 616, 5, 130, 0, 0, 615, 614, 1, 0, 0, 0, 615,
		616, 1, 0, 0, 0, 616, 617, 1, 0, 0, 0, 617, 619, 5, 2, 0, 0, 618, 620,
		5, 130, 0, 0, 619, 618, 1, 0, 0, 0, 619, 620, 1, 0, 0, 0, 620, 621, 1,
		0, 0, 0, 621, 623, 3, 64, 32, 0, 622, 615, 1, 0, 0, 0, 623, 626, 1, 0,
		0, 0, 624, 622, 1, 0, 0, 0, 624, 625, 1, 0, 0, 0, 625, 642, 1, 0, 0, 0,
		626, 624, 1, 0, 0, 0, 627, 638, 3, 64, 32, 0, 628, 630, 5, 130, 0, 0, 629,
		628, 1, 0, 0, 0, 629, 630, 1, 0, 0, 0, 630, 631, 1, 0, 0, 0, 631, 633,
		5, 2, 0, 0, 632, 634, 5, 130, 0, 0, 633, 632, 1, 0, 0, 0, 633, 634, 1,
		0, 0, 0, 634, 635, 1, 0, 0, 0, 635, 637, 3, 64, 32, 0, 636, 629, 1, 0,
		0, 0, 637, 640, 1, 0, 0, 0, 638, 636, 1, 0, 0, 0, 638, 639, 1, 0, 0, 0,
		639, 642, 1, 0, 0, 0, 640, 638, 1, 0, 0, 0, 641, 613, 1, 0, 0, 0, 641,
		627, 1, 0, 0, 0, 642, 63, 1, 0, 0, 0, 643, 644, 3, 110, 55, 0, 644, 645,
		5, 130, 0, 0, 645, 646, 5, 56, 0, 0, 646, 647, 5, 130, 0, 0, 647, 648,
		3, 182, 91, 0, 648, 651, 1, 0, 0, 0, 649, 651, 3, 110, 55, 0, 650, 643,
		1, 0, 0, 0, 650, 649, 1, 0, 0, 0, 651, 65, 1, 0, 0, 0, 652, 653, 5, 69,
		0, 0, 653, 654, 5, 130, 0, 0, 654, 655, 5, 70, 0, 0, 655, 656, 5, 130,
		0, 0, 656, 664, 3, 72, 36, 0, 657, 659, 5, 2, 0, 0, 658, 660, 5, 130, 0,
		0, 659, 658, 1, 0, 0, 0, 659, 660, 1, 0, 0, 0, 660, 661, 1, 0, 0, 0, 661,
		663, 3, 72, 36, 0, 662, 657, 1, 0, 0, 0, 663, 666, 1, 0, 0, 0, 664, 662,
		1, 0, 0, 0, 664, 665, 1, 0, 0, 0, 665, 67, 1, 0, 0, 0, 666, 664, 1, 0,
		0, 0, 667, 668, 5, 71, 0, 0, 668, 669, 5, 130, 0, 0, 669, 670, 3, 110,
		55, 0, 670, 69, 1, 0, 0, 0, 671, 672, 5, 72, 0, 0, 672, 673, 5, 130, 0,
		0, 673, 674, 3, 110, 55, 0, 674, 71, 1, 0, 0, 0, 675, 680, 3, 110, 55,
		0, 676, 678, 5, 130, 0, 0, 677, 676, 1, 0, 0, 0, 677, 678, 1, 0, 0, 0,
		678, 679, 1, 0, 0, 0, 679, 681, 7, 1, 0, 0, 680, 677, 1, 0, 0, 0, 680,
		681, 1, 0, 0, 0, 681, 73, 1, 0, 0, 0, 682, 683, 5, 77, 0, 0, 683, 684,
		5, 130, 0, 0, 684, 685, 3, 110, 55, 0, 685, 75, 1, 0, 0, 0, 686, 697, 3,
		78, 39, 0, 687, 689, 5, 130, 0, 0, 688, 687, 1, 0, 0, 0, 688, 689, 1, 0,
		0, 0, 689, 690, 1, 0, 0, 0, 690, 692, 5, 2, 0, 0, 691, 693, 5, 130, 0,
		0, 692, 691, 1, 0, 0, 0, 692, 693, 1, 0, 0, 0, 693, 694, 1, 0, 0, 0, 694,
		696, 3, 78, 39, 0, 695, 688, 1, 0, 0, 0, 696, 699, 1, 0, 0, 0, 697, 695,
		1, 0, 0, 0, 697, 698, 1, 0, 0, 0, 698, 77, 1, 0, 0, 0, 699, 697, 1, 0,
		0, 0, 700, 702, 3, 182, 91, 0, 701, 703, 5, 130, 0, 0, 702, 701, 1, 0,
		0, 0, 702, 703, 1, 0, 0, 0, 703, 704, 1, 0, 0, 0, 704, 706, 5, 3, 0, 0,
		705, 707, 5, 130, 0, 0, 706, 705, 1, 0, 0, 0, 706, 707, 1, 0, 0, 0, 707,
		708, 1, 0, 0, 0, 708, 709, 3, 80, 40, 0, 709, 712, 1, 0, 0, 0, 710, 712,
		3, 80, 40, 0, 711, 700, 1, 0, 0, 0, 711, 710, 1, 0, 0, 0, 712, 79, 1, 0,
		0, 0, 713, 714, 3, 82, 41, 0, 714, 81, 1, 0, 0, 0, 715, 722, 3, 86, 43,
		0, 716, 718, 5, 130, 0, 0, 717, 716, 1, 0, 0, 0, 717, 718, 1, 0, 0, 0,
		718, 719, 1, 0, 0, 0, 719, 721, 3, 88, 44, 0, 720, 717, 1, 0, 0, 0, 721,
		724, 1, 0, 0, 0, 722, 720, 1, 0, 0, 0, 722, 723, 1, 0, 0, 0, 723, 730,
		1, 0, 0, 0, 724, 722, 1, 0, 0, 0, 725, 726, 5, 6, 0, 0, 726, 727, 3, 82,
		41, 0, 727, 728, 5, 7, 0, 0, 728, 730, 1, 0, 0, 0, 729, 715, 1, 0, 0, 0,
		729, 725, 1, 0, 0, 0, 730, 83, 1, 0, 0, 0, 731, 736, 3, 86, 43, 0, 732,
		734, 5, 130, 0, 0, 733, 732, 1, 0, 0, 0, 733, 734, 1, 0, 0, 0, 734, 735,
		1, 0, 0, 0, 735, 737, 3, 88, 44, 0, 736, 733, 1, 0, 0, 0, 737, 738, 1,
		0, 0, 0, 738, 736, 1, 0, 0, 0, 738, 739, 1, 0, 0, 0, 739, 85, 1, 0, 0,
		0, 740, 742, 5, 6, 0, 0, 741, 743, 5, 130, 0, 0, 742, 741, 1, 0, 0, 0,
		742, 743, 1, 0, 0, 0, 743, 748, 1, 0, 0, 0, 744, 746, 3, 182, 91, 0, 745,
		747, 5, 130, 0, 0, 746, 745, 1, 0, 0, 0, 746, 747, 1, 0, 0, 0, 747, 749,
		1, 0, 0, 0, 748, 744, 1, 0, 0, 0, 748, 749, 1, 0, 0, 0, 749, 754, 1, 0,
		0, 0, 750, 752, 3, 98, 49, 0, 751, 753, 5, 130, 0, 0, 752, 751, 1, 0, 0,
		0, 752, 753, 1, 0, 0, 0, 753, 755, 1, 0, 0, 0, 754, 750, 1, 0, 0, 0, 754,
		755, 1, 0, 0, 0, 755, 760, 1, 0, 0, 0, 756, 758, 3, 94, 47, 0, 757, 759,
		5, 130, 0, 0, 758, 757, 1, 0, 0, 0, 758, 759, 1, 0, 0, 0, 759, 761, 1,
		0, 0, 0, 760, 756, 1, 0, 0, 0, 760, 761, 1, 0, 0, 0, 761, 762, 1, 0, 0,
		0, 762, 763, 5, 7, 0, 0, 763, 87, 1, 0, 0, 0, 764, 766, 3, 90, 45, 0, 765,
		767, 5, 130, 0, 0, 766, 765, 1, 0, 0, 0, 766, 767, 1, 0, 0, 0, 767, 768,
		1, 0, 0, 0, 768, 769, 3, 86, 43, 0, 769, 89, 1, 0, 0, 0, 770, 772, 3, 208,
		104, 0, 771, 773, 5, 130, 0, 0, 772, 771, 1, 0, 0, 0, 772, 773, 1, 0, 0,
		0, 773, 774, 1, 0, 0, 0, 774, 776, 3, 212, 106, 0, 775, 777, 5, 130, 0,
		0, 776, 775, 1, 0, 0, 0, 776, 777, 1, 0, 0, 0, 777, 779, 1, 0, 0, 0, 778,
		780, 3, 92, 46, 0, 779, 778, 1, 0, 0, 0, 779, 780, 1, 0, 0, 0, 780, 782,
		1, 0, 0, 0, 781, 783, 5, 130, 0, 0, 782, 781, 1, 0, 0, 0, 782, 783, 1,
		0, 0, 0, 783, 784, 1, 0, 0, 0, 784, 786, 3, 212, 106, 0, 785, 787, 5, 130,
		0, 0, 786, 785, 1, 0, 0, 0, 786, 787, 1, 0, 0, 0, 787, 788, 1, 0, 0, 0,
		788, 789, 3, 210, 105, 0, 789, 835, 1, 0, 0, 0, 790, 792, 3, 208, 104,
		0, 791, 793, 5, 130, 0, 0, 792, 791, 1, 0, 0, 0, 792, 793, 1, 0, 0, 0,
		793, 794, 1, 0, 0, 0, 794, 796, 3, 212, 106, 0, 795, 797, 5, 130, 0, 0,
		796, 795, 1, 0, 0, 0, 796, 797, 1, 0, 0, 0, 797, 799, 1, 0, 0, 0, 798,
		800, 3, 92, 46, 0, 799, 798, 1, 0, 0, 0, 799, 800, 1, 0, 0, 0, 800, 802,
		1, 0, 0, 0, 801, 803, 5, 130, 0, 0, 802, 801, 1, 0, 0, 0, 802, 803, 1,
		0, 0, 0, 803, 804, 1, 0, 0, 0, 804, 805, 3, 212, 106, 0, 805, 835, 1, 0,
		0, 0, 806, 808, 3, 212, 106, 0, 807, 809, 5, 130, 0, 0, 808, 807, 1, 0,
		0, 0, 808, 809, 1, 0, 0, 0, 809, 811, 1, 0, 0, 0, 810, 812, 3, 92, 46,
		0, 811, 810, 1, 0, 0, 0, 811, 812, 1, 0, 0, 0, 812, 814, 1, 0, 0, 0, 813,
		815, 5, 130, 0, 0, 814, 813, 1, 0, 0, 0, 814, 815, 1, 0, 0, 0, 815, 816,
		1, 0, 0, 0, 816, 818, 3, 212, 106, 0, 817, 819, 5, 130, 0, 0, 818, 817,
		1, 0, 0, 0, 818, 819, 1, 0, 0, 0, 819, 820, 1, 0, 0, 0, 820, 821, 3, 210,
		105, 0, 821, 835, 1, 0, 0, 0, 822, 824, 3, 212, 106, 0, 823, 825, 5, 130,
		0, 0, 824, 823, 1, 0, 0, 0, 824, 825, 1, 0, 0, 0, 825, 827, 1, 0, 0, 0,
		826, 828, 3, 92, 46, 0, 827, 826, 1, 0, 0, 0, 827, 828, 1, 0, 0, 0, 828,
		830, 1, 0, 0, 0, 829, 831, 5, 130, 0, 0, 830, 829, 1, 0, 0, 0, 830, 831,
		1, 0, 0, 0, 831, 832, 1, 0, 0, 0, 832, 833, 3, 212, 106, 0, 833, 835, 1,
		0, 0, 0, 834, 770, 1, 0, 0, 0, 834, 790, 1, 0, 0, 0, 834, 806, 1, 0, 0,
		0, 834, 822, 1, 0, 0, 0, 835, 91, 1, 0, 0, 0, 836, 838, 5, 8, 0, 0, 837,
		839, 5, 130, 0, 0, 838, 837, 1, 0, 0, 0, 838, 839, 1, 0, 0, 0, 839, 844,
		1, 0, 0, 0, 840, 842, 3, 182, 91, 0, 841, 843, 5, 130, 0, 0, 842, 841,
		1, 0, 0, 0, 842, 843, 1, 0, 0, 0, 843, 845, 1, 0, 0, 0, 844, 840, 1, 0,
		0, 0, 844, 845, 1, 0, 0, 0, 845, 850, 1, 0, 0, 0, 846, 848, 3, 96, 48,
		0, 847, 849, 5, 130, 0, 0, 848, 847, 1, 0, 0, 0, 848, 849, 1, 0, 0, 0,
		849, 851, 1, 0, 0, 0, 850, 846, 1, 0, 0, 0, 850, 851, 1, 0, 0, 0, 851,
		853, 1, 0, 0, 0, 852, 854, 3, 102, 51, 0, 853, 852, 1, 0, 0, 0, 853, 854,
		1, 0, 0, 0, 854, 859, 1, 0, 0, 0, 855, 857, 3, 94, 47, 0, 856, 858, 5,
		130, 0, 0, 857, 856, 1, 0, 0, 0, 857, 858, 1, 0, 0, 0, 858, 860, 1, 0,
		0, 0, 859, 855, 1, 0, 0, 0, 859, 860, 1, 0, 0, 0, 860, 861, 1, 0, 0, 0,
		861, 862, 5, 9, 0, 0, 862, 93, 1, 0, 0, 0, 863, 866, 3, 196, 98, 0, 864,
		866, 3, 200, 100, 0, 865, 863, 1, 0, 0, 0, 865, 864, 1, 0, 0, 0, 866, 95,
		1, 0, 0, 0, 867, 869, 5, 10, 0, 0, 868, 870, 5, 130, 0, 0, 869, 868, 1,
		0, 0, 0, 869, 870, 1, 0, 0, 0, 870, 871, 1, 0, 0, 0, 871, 885, 3, 106,
		53, 0, 872, 874, 5, 130, 0, 0, 873, 872, 1, 0, 0, 0, 873, 874, 1, 0, 0,
		0, 874, 875, 1, 0, 0, 0, 875, 877, 5, 11, 0, 0, 876, 878, 5, 10, 0, 0,
		877, 876, 1, 0, 0, 0, 877, 878, 1, 0, 0, 0, 878, 880, 1, 0, 0, 0, 879,
		881, 5, 130, 0, 0, 880, 879, 1, 0, 0, 0, 880, 881, 1, 0, 0, 0, 881, 882,
		1, 0, 0, 0, 882, 884, 3, 106, 53, 0, 883, 873, 1, 0, 0, 0, 884, 887, 1,
		0, 0, 0, 885, 883, 1, 0, 0, 0, 885, 886, 1, 0, 0, 0, 886, 97, 1, 0, 0,
		0, 887, 885, 1, 0, 0, 0, 888, 895, 3, 100, 50, 0, 889, 891, 5, 130, 0,
		0, 890, 889, 1, 0, 0, 0, 890, 891, 1, 0, 0, 0, 891, 892, 1, 0, 0, 0, 892,
		894, 3, 100, 50, 0, 893, 890, 1, 0, 0, 0, 894, 897, 1, 0, 0, 0, 895, 893,
		1, 0, 0, 0, 895, 896, 1, 0, 0, 0, 896, 99, 1, 0, 0, 0, 897, 895, 1, 0,
		0, 0, 898, 900, 5, 10, 0, 0, 899, 901, 5, 130, 0, 0, 900, 899, 1, 0, 0,
		0, 900, 901, 1, 0, 0, 0, 901, 902, 1, 0, 0, 0, 902, 903, 3, 104, 52, 0,
		903, 101, 1, 0, 0, 0, 904, 906, 5, 5, 0, 0, 905, 907, 5, 130, 0, 0, 906,
		905, 1, 0, 0, 0, 906, 907, 1, 0, 0, 0, 907, 912, 1, 0, 0, 0, 908, 910,
		3, 190, 95, 0, 909, 911, 5, 130, 0, 0, 910, 909, 1, 0, 0, 0, 910, 911,
		1, 0, 0, 0, 911, 913, 1, 0, 0, 0, 912, 908, 1, 0, 0, 0, 912, 913, 1, 0,
		0, 0, 913, 924, 1, 0, 0, 0, 914, 916, 5, 12, 0, 0, 915, 917, 5, 130, 0,
		0, 916, 915, 1, 0, 0, 0, 916, 917, 1, 0, 0, 0, 917, 922, 1, 0, 0, 0, 918,
		920, 3, 190, 95, 0, 919, 921, 5, 130, 0, 0, 920, 919, 1, 0, 0, 0, 920,
		921, 1, 0, 0, 0, 921, 923, 1, 0, 0, 0, 922, 918, 1, 0, 0, 0, 922, 923,
		1, 0, 0, 0, 923, 925, 1, 0, 0, 0, 924, 914, 1, 0, 0, 0, 924, 925, 1, 0,
		0, 0, 925, 103, 1, 0, 0, 0, 926, 927, 3, 202, 101, 0, 927, 105, 1, 0, 0,
		0, 928, 929, 3, 202, 101, 0, 929, 107, 1, 0, 0, 0, 930, 935, 3, 146, 73,
		0, 931, 933, 5, 130, 0, 0, 932, 931, 1, 0, 0, 0, 932, 933, 1, 0, 0, 0,
		933, 934, 1, 0, 0, 0, 934, 936, 3, 144, 72, 0, 935, 932, 1, 0, 0, 0, 936,
		937, 1, 0, 0, 0, 937, 935, 1, 0, 0, 0, 937, 938, 1, 0, 0, 0, 938, 109,
		1, 0, 0, 0, 939, 940, 3, 112, 56, 0, 940, 111, 1, 0, 0, 0, 941, 948, 3,
		114, 57, 0, 942, 943, 5, 130, 0, 0, 943, 944, 5, 78, 0, 0, 944, 945, 5,
		130, 0, 0, 945, 947, 3, 114, 57, 0, 946, 942, 1, 0, 0, 0, 947, 950, 1,
		0, 0, 0, 948, 946, 1, 0, 0, 0, 948, 949, 1, 0, 0, 0, 949, 113, 1, 0, 0,
		0, 950, 948, 1, 0, 0, 0, 951, 958, 3, 116, 58, 0, 952, 953, 5, 130, 0,
		0, 953, 954, 5, 79, 0, 0, 954, 955, 5, 130, 0, 0, 955, 957, 3, 116, 58,
		0, 956, 952, 1, 0, 0, 0, 957, 960, 1, 0, 0, 0, 958, 956, 1, 0, 0, 0, 958,
		959, 1, 0, 0, 0, 959, 115, 1, 0, 0, 0, 960, 958, 1, 0, 0, 0, 961, 968,
		3, 118, 59, 0, 962, 963, 5, 130, 0, 0, 963, 964, 5, 80, 0, 0, 964, 965,
		5, 130, 0, 0, 965, 967, 3, 118, 59, 0, 966, 962, 1, 0, 0, 0, 967, 970,
		1, 0, 0, 0, 968, 966, 1, 0, 0, 0, 968, 969, 1, 0, 0, 0, 969, 117, 1, 0,
		0, 0, 970, 968, 1, 0, 0, 0, 971, 973, 5, 81, 0, 0, 972, 974, 5, 130, 0,
		0, 973, 972, 1, 0, 0, 0, 973, 974, 1, 0, 0, 0, 974, 976, 1, 0, 0, 0, 975,
		971, 1, 0, 0, 0, 976, 979, 1, 0, 0, 0, 977, 975, 1, 0, 0, 0, 977, 978,
		1, 0, 0, 0, 978, 980, 1, 0, 0, 0, 979, 977, 1, 0, 0, 0, 980, 981, 3, 120,
		60, 0, 981, 119, 1, 0, 0, 0, 982, 989, 3, 124, 62, 0, 983, 985, 5, 130,
		0, 0, 984, 983, 1, 0, 0, 0, 984, 985, 1, 0, 0, 0, 985, 986, 1, 0, 0, 0,
		986, 988, 3, 122, 61, 0, 987, 984, 1, 0, 0, 0, 988, 991, 1, 0, 0, 0, 989,
		987, 1, 0, 0, 0, 989, 990, 1, 0, 0, 0, 990, 121, 1, 0, 0, 0, 991, 989,
		1, 0, 0, 0, 992, 994, 5, 3, 0, 0, 993, 995, 5, 130, 0, 0, 994, 993, 1,
		0, 0, 0, 994, 995, 1, 0, 0, 0, 995, 996, 1, 0, 0, 0, 996, 1023, 3, 124,
		62, 0, 997, 999, 5, 13, 0, 0, 998, 1000, 5, 130, 0, 0, 999, 998, 1, 0,
		0, 0, 999, 1000, 1, 0, 0, 0, 1000, 1001, 1, 0, 0, 0, 1001, 1023, 3, 124,
		62, 0, 1002, 1004, 5, 14, 0, 0, 1003, 1005, 5, 130, 0, 0, 1004, 1003, 1,
		0, 0, 0, 1004, 1005, 1, 0, 0, 0, 1005, 1006, 1, 0, 0, 0, 1006, 1023, 3,
		124, 62, 0, 1007, 1009, 5, 15, 0, 0, 1008, 1010, 5, 130, 0, 0, 1009, 1008,
		1, 0, 0, 0, 1009, 1010, 1, 0, 0, 0, 1010, 1011, 1, 0, 0, 0, 1011, 1023,
		3, 124, 62, 0, 1012, 1014, 5, 16, 0, 0, 1013, 1015, 5, 130, 0, 0, 1014,
		1013, 1, 0, 0, 0, 1014, 1015, 1, 0, 0, 0, 1015, 1016, 1, 0, 0, 0, 1016,
		1023, 3, 124, 62, 0, 1017, 1019, 5, 17, 0, 0, 1018, 1020, 5, 130, 0, 0,
		1019, 1018, 1, 0, 0, 0, 1019, 1020, 1, 0, 0, 0, 1020, 1021, 1, 0, 0, 0,
		1021, 1023, 3, 124, 62, 0, 1022, 992, 1, 0, 0, 0, 1022, 997, 1, 0, 0, 0,
		1022, 1002, 1, 0, 0, 0, 1022, 1007, 1, 0, 0, 0, 1022, 1012, 1, 0, 0, 0,
		1022, 1017, 1, 0, 0, 0, 1023, 123, 1, 0, 0, 0, 1024, 1030, 3, 132, 66,
		0, 1025, 1029, 3, 126, 63, 0, 1026, 1029, 3, 128, 64, 0, 1027, 1029, 3,
		130, 65, 0, 1028, 1025, 1, 0, 0, 0, 1028, 1026, 1, 0, 0, 0, 1028, 1027,
		1, 0, 0, 0, 1029, 1032, 1, 0, 0, 0, 1030, 1028, 1, 0, 0, 0, 1030, 1031,
		1, 0, 0, 0, 1031, 125, 1, 0, 0, 0, 1032, 1030, 1, 0, 0, 0, 1033, 1034,
		5, 130, 0, 0, 1034, 1035, 5, 82, 0, 0, 1035, 1036, 5, 130, 0, 0, 1036,
		1044, 5, 66, 0, 0, 1037, 1038, 5, 130, 0, 0, 1038, 1039, 5, 83, 0, 0, 1039,
		1040, 5, 130, 0, 0, 1040, 1044, 5, 66, 0, 0, 1041, 1042, 5, 130, 0, 0,
		1042, 1044, 5, 84, 0, 0, 1043, 1033, 1, 0, 0, 0, 1043, 1037, 1, 0, 0, 0,
		1043, 1041, 1, 0, 0, 0, 1044, 1046, 1, 0, 0, 0, 1045, 1047, 5, 130, 0,
		0, 1046, 1045, 1, 0, 0, 0, 1046, 1047, 1, 0, 0, 0, 1047, 1048, 1, 0, 0,
		0, 1048, 1049, 3, 132, 66, 0, 1049, 127, 1, 0, 0, 0, 1050, 1051, 5, 130,
		0, 0, 1051, 1053, 5, 85, 0, 0, 1052, 1054, 5, 130, 0, 0, 1053, 1052, 1,
		0, 0, 0, 1053, 1054, 1, 0, 0, 0, 1054, 1055, 1, 0, 0, 0, 1055, 1056, 3,
		132, 66, 0, 1056, 129, 1, 0, 0, 0, 1057, 1058, 5, 130, 0, 0, 1058, 1059,
		5, 86, 0, 0, 1059, 1060, 5, 130, 0, 0, 1060, 1068, 5, 87, 0, 0, 1061, 1062,
		5, 130, 0, 0, 1062, 1063, 5, 86, 0, 0, 1063, 1064, 5, 130, 0, 0, 1064,
		1065, 5, 81, 0, 0, 1065, 1066, 5, 130, 0, 0, 1066, 1068, 5, 87, 0, 0, 1067,
		1057, 1, 0, 0, 0, 1067, 1061, 1, 0, 0, 0, 1068, 131, 1, 0, 0, 0, 1069,
		1088, 3, 134, 67, 0, 1070, 1072, 5, 130, 0, 0, 1071, 1070, 1, 0, 0, 0,
		1071, 1072, 1, 0, 0, 0, 1072, 1073, 1, 0, 0, 0, 1073, 1075, 5, 18, 0, 0,
		1074, 1076, 5, 130, 0, 0, 1075, 1074, 1, 0, 0, 0, 1075, 1076, 1, 0, 0,
		0, 1076, 1077, 1, 0, 0, 0, 1077, 1087, 3, 134, 67, 0, 1078, 1080, 5, 130,
		0, 0, 1079, 1078, 1, 0, 0, 0, 1079, 1080, 1, 0, 0, 0, 1080, 1081, 1, 0,
		0, 0, 1081, 1083, 5, 19, 0, 0, 1082, 1084, 5, 130, 0, 0, 1083, 1082, 1,
		0, 0, 0, 1083, 1084, 1, 0, 0, 0, 1084, 1085, 1, 0, 0, 0, 1085, 1087, 3,
		134, 67, 0, 1086, 1071, 1, 0, 0, 0, 1086, 1079, 1, 0, 0, 0, 1087, 1090,
		1, 0, 0, 0, 1088, 1086, 1, 0, 0, 0, 1088, 1089, 1, 0, 0, 0, 1089, 133,
		1, 0, 0, 0, 1090, 1088, 1, 0, 0, 0, 1091, 1118, 3, 136, 68, 0, 1092, 1094,
		5, 130, 0, 0, 1093, 1092, 1, 0, 0, 0, 1093, 1094, 1, 0, 0, 0, 1094, 1095,
		1, 0, 0, 0, 1095, 1097, 5, 5, 0, 0, 1096, 1098, 5, 130, 0, 0, 1097, 1096,
		1, 0, 0, 0, 1097, 1098, 1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099, 1117,
		3, 136, 68, 0, 1100, 1102, 5, 130, 0, 0, 1101, 1100, 1, 0, 0, 0, 1101,
		1102, 1, 0, 0, 0, 1102, 1103, 1, 0, 0, 0, 1103, 1105, 5, 20, 0, 0, 1104,
		1106, 5, 130, 0, 0, 1105, 1104, 1, 0, 0, 0, 1105, 1106, 1, 0, 0, 0, 1106,
		1107, 1, 0, 0, 0, 1107, 1117, 3, 136, 68, 0, 1108, 1110, 5, 130, 0, 0,
		1109, 1108, 1, 0, 0, 0, 1109, 1110, 1, 0, 0, 0, 1110, 1111, 1, 0, 0, 0,
		1111, 1113, 5, 21, 0, 0, 1112, 1114, 5, 130, 0, 0, 1113, 1112, 1, 0, 0,
		0, 1113, 1114, 1, 0, 0, 0, 1114, 1115, 1, 0, 0, 0, 1115, 1117, 3, 136,
		68, 0, 1116, 1093, 1, 0, 0, 0, 1116, 1101, 1, 0, 0, 0, 1116, 1109, 1, 0,
		0, 0, 1117, 1120, 1, 0, 0, 0, 1118, 1116, 1, 0, 0, 0, 1118, 1119, 1, 0,
		0, 0, 1119, 135, 1, 0, 0, 0, 1120, 1118, 1, 0, 0, 0, 1121, 1132, 3, 138,
		69, 0, 1122, 1124, 5, 130, 0, 0, 1123, 1122, 1, 0, 0, 0, 1123, 1124, 1,
		0, 0, 0, 1124, 1125, 1, 0, 0, 0, 1125, 1127, 5, 22, 0, 0, 1126, 1128, 5,
		130, 0, 0, 1127, 1126, 1, 0, 0, 0, 1127, 1128, 1, 0, 0, 0, 1128, 1129,
		1, 0, 0, 0, 1129, 1131, 3, 138, 69, 0, 1130, 1123, 1, 0, 0, 0, 1131, 1134,
		1, 0, 0, 0, 1132, 1130, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133, 137,
		1, 0, 0, 0, 1134, 1132, 1, 0, 0, 0, 1135, 1142, 3, 140, 70, 0, 1136, 1138,
		7, 2, 0, 0, 1137, 1139, 5, 130, 0, 0, 1138, 1137, 1, 0, 0, 0, 1138, 1139,
		1, 0, 0, 0, 1139, 1140, 1, 0, 0, 0, 1140, 1142, 3, 140, 70, 0, 1141, 1135,
		1, 0, 0, 0, 1141, 1136, 1, 0, 0, 0, 1142, 139, 1, 0, 0, 0, 1143, 1165,
		3, 142, 71, 0, 1144, 1146, 5, 130, 0, 0, 1145, 1144, 1, 0, 0, 0, 1145,
		1146, 1, 0, 0, 0, 1146, 1147, 1, 0, 0, 0, 1147, 1148, 5, 8, 0, 0, 1148,
		1149, 3, 110, 55, 0, 1149, 1150, 5, 9, 0, 0, 1150, 1164, 1, 0, 0, 0, 1151,
		1153, 5, 130, 0, 0, 1152, 1151, 1, 0, 0, 0, 1152, 1153, 1, 0, 0, 0, 1153,
		1154, 1, 0, 0, 0, 1154, 1156, 5, 8, 0, 0, 1155, 1157, 3, 110, 55, 0, 1156,
		1155, 1, 0, 0, 0, 1156, 1157, 1, 0, 0, 0, 1157, 1158, 1, 0, 0, 0, 1158,
		1160, 5, 12, 0, 0, 1159, 1161, 3, 110, 55, 0, 1160, 1159, 1, 0, 0, 0, 1160,
		1161, 1, 0, 0, 0, 1161, 1162, 1, 0, 0, 0, 1162, 1164, 5, 9, 0, 0, 1163,
		1145, 1, 0, 0, 0, 1163, 1152, 1, 0, 0, 0, 1164, 1167, 1, 0, 0, 0, 1165,
		1163, 1, 0, 0, 0, 1165, 1166, 1, 0, 0, 0, 1166, 141, 1, 0, 0, 0, 1167,
		1165, 1, 0, 0, 0, 1168, 1175, 3, 146, 73, 0, 1169, 1171, 5, 130, 0, 0,
		1170, 1169, 1, 0, 0, 0, 1170, 1171, 1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0,
		1172, 1174, 3, 144, 72, 0, 1173, 1170, 1, 0, 0, 0, 1174, 1177, 1, 0, 0,
		0, 1175, 1173, 1, 0, 0, 0, 1175, 1176, 1, 0, 0, 0, 1176, 1182, 1, 0, 0,
		0, 1177, 1175, 1, 0, 0, 0, 1178, 1180, 5, 130, 0, 0, 1179, 1178, 1, 0,
		0, 0, 1179, 1180, 1, 0, 0, 0, 1180, 1181, 1, 0, 0, 0, 1181, 1183, 3, 98,
		49, 0, 1182, 1179, 1, 0, 0, 0, 1182, 1183, 1, 0, 0, 0, 1183, 143, 1, 0,
		0, 0, 1184, 1186, 5, 23, 0, 0, 1185, 1187, 5, 130, 0, 0, 1186, 1185, 1,
		0, 0, 0, 1186, 1187, 1, 0, 0, 0, 1187, 1188, 1, 0, 0, 0, 1188, 1189, 3,
		198, 99, 0, 1189, 145, 1, 0, 0, 0, 1190, 1215, 3, 184, 92, 0, 1191, 1215,
		3, 200, 100, 0, 1192, 1215, 3, 148, 74, 0, 1193, 1195, 5, 88, 0, 0, 1194,
		1196, 5, 130, 0, 0, 1195, 1194, 1, 0, 0, 0, 1195, 1196, 1, 0, 0, 0, 1196,
		1197, 1, 0, 0, 0, 1197, 1199, 5, 6, 0, 0, 1198, 1200, 5, 130, 0, 0, 1199,
		1198, 1, 0, 0, 0, 1199, 1200, 1, 0, 0, 0, 1200, 1201, 1, 0, 0, 0, 1201,
		1203, 5, 5, 0, 0, 1202, 1204, 5, 130, 0, 0, 1203, 1202, 1, 0, 0, 0, 1203,
		1204, 1, 0, 0, 0, 1204, 1205, 1, 0, 0, 0, 1205, 1215, 5, 7, 0, 0, 1206,
		1215, 3, 152, 76, 0, 1207, 1215, 3, 154, 77, 0, 1208, 1215, 3, 156, 78,
		0, 1209, 1215, 3, 160, 80, 0, 1210, 1215, 3, 162, 81, 0, 1211, 1215, 3,
		166, 83, 0, 1212, 1215, 3, 170, 85, 0, 1213, 1215, 3, 182, 91, 0, 1214,
		1190, 1, 0, 0, 0, 1214, 1191, 1, 0, 0, 0, 1214, 1192, 1, 0, 0, 0, 1214,
		1193, 1, 0, 0, 0, 1214, 1206, 1, 0, 0, 0, 1214, 1207, 1, 0, 0, 0, 1214,
		1208, 1, 0, 0, 0, 1214, 1209, 1, 0, 0, 0, 1214, 1210, 1, 0, 0, 0, 1214,
		1211, 1, 0, 0, 0, 1214, 1212, 1, 0, 0, 0, 1214, 1213, 1, 0, 0, 0, 1215,
		147, 1, 0, 0, 0, 1216, 1221, 5, 89, 0, 0, 1217, 1219, 5, 130, 0, 0, 1218,
		1217, 1, 0, 0, 0, 1218, 1219, 1, 0, 0, 0, 1219, 1220, 1, 0, 0, 0, 1220,
		1222, 3, 150, 75, 0, 1221, 1218, 1, 0, 0, 0, 1222, 1223, 1, 0, 0, 0, 1223,
		1221, 1, 0, 0, 0, 1223, 1224, 1, 0, 0, 0, 1224, 1239, 1, 0, 0, 0, 1225,
		1227, 5, 89, 0, 0, 1226, 1228, 5, 130, 0, 0, 1227, 1226, 1, 0, 0, 0, 1227,
		1228, 1, 0, 0, 0, 1228, 1229, 1, 0, 0, 0, 1229, 1234, 3, 110, 55, 0, 1230,
		1232, 5, 130, 0, 0, 1231, 1230, 1, 0, 0, 0, 1231, 1232, 1, 0, 0, 0, 1232,
		1233, 1, 0, 0, 0, 1233, 1235, 3, 150, 75, 0, 1234, 1231, 1, 0, 0, 0, 1235,
		1236, 1, 0, 0, 0, 1236, 1234, 1, 0, 0, 0, 1236, 1237, 1, 0, 0, 0, 1237,
		1239, 1, 0, 0, 0, 1238, 1216, 1, 0, 0, 0, 1238, 1225, 1, 0, 0, 0, 1239,
		1248, 1, 0, 0, 0, 1240, 1242, 5, 130, 0, 0, 1241, 1240, 1, 0, 0, 0, 1241,
		1242, 1, 0, 0, 0, 1242, 1243, 1, 0, 0, 0, 1243, 1245, 5, 90, 0, 0, 1244,
		1246, 5, 130, 0, 0, 1245, 1244, 1, 0, 0, 0, 1245, 1246, 1, 0, 0, 0, 1246,
		1247, 1, 0, 0, 0, 1247, 1249, 3, 110, 55, 0, 1248, 1241, 1, 0, 0, 0, 1248,
		1249, 1, 0, 0, 0, 1249, 1251, 1, 0, 0, 0, 1250, 1252, 5, 130, 0, 0, 1251,
		1250, 1, 0, 0, 0, 1251, 1252, 1, 0, 0, 0, 1252, 1253, 1, 0, 0, 0, 1253,
		1254, 5, 91, 0, 0, 1254, 149, 1, 0, 0, 0, 1255, 1257, 5, 92, 0, 0, 1256,
		1258, 5, 130, 0, 0, 1257, 1256, 1, 0, 0, 0, 1257, 1258, 1, 0, 0, 0, 1258,
		1259, 1, 0, 0, 0, 1259, 1261, 3, 110, 55, 0, 1260, 1262, 5, 130, 0, 0,
		1261, 1260, 1, 0, 0, 0, 1261, 1262, 1, 0, 0, 0, 1262, 1263, 1, 0, 0, 0,
		1263, 1265, 5, 93, 0, 0, 1264, 1266, 5, 130, 0, 0, 1265, 1264, 1, 0, 0,
		0, 1265, 1266, 1, 0, 0, 0, 1266, 1267, 1, 0, 0, 0, 1267, 1268, 3, 110,
		55, 0, 1268, 151, 1, 0, 0, 0, 1269, 1271, 5, 8, 0, 0, 1270, 1272, 5, 130,
		0, 0, 1271, 1270, 1, 0, 0, 0, 1271, 1272, 1, 0, 0, 0, 1272, 1273, 1, 0,
		0, 0, 1273, 1282, 3, 158, 79, 0, 1274, 1276, 5, 130, 0, 0, 1275, 1274,
		1, 0, 0, 0, 1275, 1276, 1, 0, 0, 0, 1276, 1277, 1, 0, 0, 0, 1277, 1279,
		5, 11, 0, 0, 1278, 1280, 5, 130, 0, 0, 1279, 1278, 1, 0, 0, 0, 1279, 1280,
		1, 0, 0, 0, 1280, 1281, 1, 0, 0, 0, 1281, 1283, 3, 110, 55, 0, 1282, 1275,
		1, 0, 0, 0, 1282, 1283, 1, 0, 0, 0, 1283, 1285, 1, 0, 0, 0, 1284, 1286,
		5, 130, 0, 0, 1285, 1284, 1, 0, 0, 0, 1285, 1286, 1, 0, 0, 0, 1286, 1287,
		1, 0, 0, 0, 1287, 1288, 5, 9, 0, 0, 1288, 153, 1, 0, 0, 0, 1289, 1291,
		5, 8, 0, 0, 1290, 1292, 5, 130, 0, 0, 1291, 1290, 1, 0, 0, 0, 1291, 1292,
		1, 0, 0, 0, 1292, 1301, 1, 0, 0, 0, 1293, 1295, 3, 182, 91, 0, 1294, 1296,
		5, 130, 0, 0, 1295, 1294, 1, 0, 0, 0, 1295, 1296, 1, 0, 0, 0, 1296, 1297,
		1, 0, 0, 0, 1297, 1299, 5, 3, 0, 0, 1298, 1300, 5, 130, 0, 0, 1299, 1298,
		1, 0, 0, 0, 1299, 1300, 1, 0, 0, 0, 1300, 1302, 1, 0, 0, 0, 1301, 1293,
		1, 0, 0, 0, 1301, 1302, 1, 0, 0, 0, 1302, 1303, 1, 0, 0, 0, 1303, 1305,
		3, 84, 42, 0, 1304, 1306, 5, 130, 0, 0, 1305, 1304, 1, 0, 0, 0, 1305, 1306,
		1, 0, 0, 0, 1306, 1311, 1, 0, 0, 0, 1307, 1309, 3, 74, 37, 0, 1308, 1310,
		5, 130, 0, 0, 1309, 1308, 1, 0, 0, 0, 1309, 1310, 1, 0, 0, 0, 1310, 1312,
		1, 0, 0, 0, 1311, 1307, 1, 0, 0, 0, 1311, 1312, 1, 0, 0, 0, 1312, 1313,
		1, 0, 0, 0, 1313, 1315, 5, 11, 0, 0, 1314, 1316, 5, 130, 0, 0, 1315, 1314,
		1, 0, 0, 0, 1315, 1316, 1, 0, 0, 0, 1316, 1317, 1, 0, 0, 0, 1317, 1319,
		3, 110, 55, 0, 1318, 1320, 5, 130, 0, 0, 1319, 1318, 1, 0, 0, 0, 1319,
		1320, 1, 0, 0, 0, 1320, 1321, 1, 0, 0, 0, 1321, 1322, 5, 9, 0, 0, 1322,
		155, 1, 0, 0, 0, 1323, 1325, 5, 52, 0, 0, 1324, 1326, 5, 130, 0, 0, 1325,
		1324, 1, 0, 0, 0, 1325, 1326, 1, 0, 0, 0, 1326, 1327, 1, 0, 0, 0, 1327,
		1329, 5, 6, 0, 0, 1328, 1330, 5, 130, 0, 0, 1329, 1328, 1, 0, 0, 0, 1329,
		1330, 1, 0, 0, 0, 1330, 1331, 1, 0, 0, 0, 1331, 1333, 3, 158, 79, 0, 1332,
		1334, 5, 130, 0, 0, 1333, 1332, 1, 0, 0, 0, 1333, 1334, 1, 0, 0, 0, 1334,
		1335, 1, 0, 0, 0, 1335, 1336, 5, 7, 0, 0, 1336, 1380, 1, 0, 0, 0, 1337,
		1339, 5, 94, 0, 0, 1338, 1340, 5, 130, 0, 0, 1339, 1338, 1, 0, 0, 0, 1339,
		1340, 1, 0, 0, 0, 1340, 1341, 1, 0, 0, 0, 1341, 1343, 5, 6, 0, 0, 1342,
		1344, 5, 130, 0, 0, 1343, 1342, 1, 0, 0, 0, 1343, 1344, 1, 0, 0, 0, 1344,
		1345, 1, 0, 0, 0, 1345, 1347, 3, 158, 79, 0, 1346, 1348, 5, 130, 0, 0,
		1347, 1346, 1, 0, 0, 0, 1347, 1348, 1, 0, 0, 0, 1348, 1349, 1, 0, 0, 0,
		1349, 1350, 5, 7, 0, 0, 1350, 1380, 1, 0, 0, 0, 1351, 1353, 5, 95, 0, 0,
		1352, 1354, 5, 130, 0, 0, 1353, 1352, 1, 0, 0, 0, 1353, 1354, 1, 0, 0,
		0, 1354, 1355, 1, 0, 0, 0, 1355, 1357, 5, 6, 0, 0, 1356, 1358, 5, 130,
		0, 0, 1357, 1356, 1, 0, 0, 0, 1357, 1358, 1, 0, 0, 0, 1358, 1359, 1, 0,
		0, 0, 1359, 1361, 3, 158, 79, 0, 1360, 1362, 5, 130, 0, 0, 1361, 1360,
		1, 0, 0, 0, 1361, 1362, 1, 0, 0, 0, 1362, 1363, 1, 0, 0, 0, 1363, 1364,
		5, 7, 0, 0, 1364, 1380, 1, 0, 0, 0, 1365, 1367, 5, 96, 0, 0, 1366, 1368,
		5, 130, 0, 0, 1367, 1366, 1, 0, 0, 0, 1367, 1368, 1, 0, 0, 0, 1368, 1369,
		1, 0, 0, 0, 1369, 1371, 5, 6, 0, 0, 1370, 1372, 5, 130, 0, 0, 1371, 1370,
		1, 0, 0, 0, 1371, 1372, 1, 0, 0, 0, 1372, 1373, 1, 0, 0, 0, 1373, 1375,
		3, 158, 79, 0, 1374, 1376, 5, 130, 0, 0, 1375, 1374, 1, 0, 0, 0, 1375,
		1376, 1, 0, 0, 0, 1376, 1377, 1, 0, 0, 0, 1377, 1378, 5, 7, 0, 0, 1378,
		1380, 1, 0, 0, 0, 1379, 1323, 1, 0, 0, 0, 1379, 1337, 1, 0, 0, 0, 1379,
		1351, 1, 0, 0, 0, 1379, 1365, 1, 0, 0, 0, 1380, 157, 1, 0, 0, 0, 1381,
		1386, 3, 164, 82, 0, 1382, 1384, 5, 130, 0, 0, 1383, 1382, 1, 0, 0, 0,
		1383, 1384, 1, 0, 0, 0, 1384, 1385, 1, 0, 0, 0, 1385, 1387, 3, 74, 37,
		0, 1386, 1383, 1, 0, 0, 0, 1386, 1387, 1, 0, 0, 0, 1387, 159, 1, 0, 0,
		0, 1388, 1389, 3, 84, 42, 0, 1389, 161, 1, 0, 0, 0, 1390, 1392, 5, 6, 0,
		0, 1391, 1393, 5, 130, 0, 0, 1392, 1391, 1, 0, 0, 0, 1392, 1393, 1, 0,
		0, 0, 1393, 1394, 1, 0, 0, 0, 1394, 1396, 3, 110, 55, 0, 1395, 1397, 5,
		130, 0, 0, 1396, 1395, 1, 0, 0, 0, 1396, 1397, 1, 0, 0, 0, 1397, 1398,
		1, 0, 0, 0, 1398, 1399, 5, 7, 0, 0, 1399, 163, 1, 0, 0, 0, 1400, 1401,
		3, 182, 91, 0, 1401, 1402, 5, 130, 0, 0, 1402, 1403, 5, 85, 0, 0, 1403,
		1404, 5, 130, 0, 0, 1404, 1405, 3, 110, 55, 0, 1405, 165, 1, 0, 0, 0, 1406,
		1408, 3, 168, 84, 0, 1407, 1409, 5, 130, 0, 0, 1408, 1407, 1, 0, 0, 0,
		1408, 1409, 1, 0, 0, 0, 1409, 1410, 1, 0, 0, 0, 1410, 1412, 5, 6, 0, 0,
		1411, 1413, 5, 130, 0, 0, 1412, 1411, 1, 0, 0, 0, 1412, 1413, 1, 0, 0,
		0, 1413, 1418, 1, 0, 0, 0, 1414, 1416, 5, 68, 0, 0, 1415, 1417, 5, 130,
		0, 0, 1416, 1415, 1, 0, 0, 0, 1416, 1417, 1, 0, 0, 0, 1417, 1419, 1, 0,
		0, 0, 1418, 1414, 1, 0, 0, 0, 1418, 1419, 1, 0, 0, 0, 1419, 1437, 1, 0,
		0, 0, 1420, 1422, 3, 110, 55, 0, 1421, 1423, 5, 130, 0, 0, 1422, 1421,
		1, 0, 0, 0, 1422, 1423, 1, 0, 0, 0, 1423, 1434, 1, 0, 0, 0, 1424, 1426,
		5, 2, 0, 0, 1425, 1427, 5, 130, 0, 0, 1426, 1425, 1, 0, 0, 0, 1426, 1427,
		1, 0, 0, 0, 1427, 1428, 1, 0, 0, 0, 1428, 1430, 3, 110, 55, 0, 1429, 1431,
		5, 130, 0, 0, 1430, 1429, 1, 0, 0, 0, 1430, 1431, 1, 0, 0, 0, 1431, 1433,
		1, 0, 0, 0, 1432, 1424, 1, 0, 0, 0, 1433, 1436, 1, 0, 0, 0, 1434, 1432,
		1, 0, 0, 0, 1434, 1435, 1, 0, 0, 0, 1435, 1438, 1, 0, 0, 0, 1436, 1434,
		1, 0, 0, 0, 1437, 1420, 1, 0, 0, 0, 1437, 1438, 1, 0, 0, 0, 1438, 1439,
		1, 0, 0, 0, 1439, 1440, 5, 7, 0, 0, 1440, 167, 1, 0, 0, 0, 1441, 1442,
		3, 180, 90, 0, 1442, 1443, 3, 206, 103, 0, 1443, 169, 1, 0, 0, 0, 1444,
		1446, 5, 97, 0, 0, 1445, 1447, 5, 130, 0, 0, 1446, 1445, 1, 0, 0, 0, 1446,
		1447, 1, 0, 0, 0, 1447, 1448, 1, 0, 0, 0, 1448, 1450, 5, 24, 0, 0, 1449,
		1451, 5, 130, 0, 0, 1450, 1449, 1, 0, 0, 0, 1450, 1451, 1, 0, 0, 0, 1451,
		1460, 1, 0, 0, 0, 1452, 1461, 3, 14, 7, 0, 1453, 1458, 3, 76, 38, 0, 1454,
		1456, 5, 130, 0, 0, 1455, 1454, 1, 0, 0, 0, 1455, 1456, 1, 0, 0, 0, 1456,
		1457, 1, 0, 0, 0, 1457, 1459, 3, 74, 37, 0, 1458, 1455, 1, 0, 0, 0, 1458,
		1459, 1, 0, 0, 0, 1459, 1461, 1, 0, 0, 0, 1460, 1452, 1, 0, 0, 0, 1460,
		1453, 1, 0, 0, 0, 1461, 1463, 1, 0, 0, 0, 1462, 1464, 5, 130, 0, 0, 1463,
		1462, 1, 0, 0, 0, 1463, 1464, 1, 0, 0, 0, 1464, 1465, 1, 0, 0, 0, 1465,
		1466, 5, 25, 0, 0, 1466, 171, 1, 0, 0, 0, 1467, 1469, 3, 178, 89, 0, 1468,
		1470, 5, 130, 0, 0, 1469, 1468, 1, 0, 0, 0, 1469, 1470, 1, 0, 0, 0, 1470,
		1471, 1, 0, 0, 0, 1471, 1473, 5, 6, 0, 0, 1472, 1474, 5, 130, 0, 0, 1473,
		1472, 1, 0, 0, 0, 1473, 1474, 1, 0, 0, 0, 1474, 1492, 1, 0, 0, 0, 1475,
		1477, 3, 110, 55, 0, 1476, 1478, 5, 130, 0, 0, 1477, 1476, 1, 0, 0, 0,
		1477, 1478, 1, 0, 0, 0, 1478, 1489, 1, 0, 0, 0, 1479, 1481, 5, 2, 0, 0,
		1480, 1482, 5, 130, 0, 0, 1481, 1480, 1, 0, 0, 0, 1481, 1482, 1, 0, 0,
		0, 1482, 1483, 1, 0, 0, 0, 1483, 1485, 3, 110, 55, 0, 1484, 1486, 5, 130,
		0, 0, 1485, 1484, 1, 0, 0, 0, 1485, 1486, 1, 0, 0, 0, 1486, 1488, 1, 0,
		0, 0, 1487, 1479, 1, 0, 0, 0, 1488, 1491, 1, 0, 0, 0, 1489, 1487, 1, 0,
		0, 0, 1489, 1490, 1, 0, 0, 0, 1490, 1493, 1, 0, 0, 0, 1491, 1489, 1, 0,
		0, 0, 1492, 1475, 1, 0, 0, 0, 1492, 1493, 1, 0, 0, 0, 1493, 1494, 1, 0,
		0, 0, 1494, 1495, 5, 7, 0, 0, 1495, 173, 1, 0, 0, 0, 1496, 1497, 3, 178,
		89, 0, 1497, 175, 1, 0, 0, 0, 1498, 1499, 3, 206, 103, 0, 1499, 177, 1,
		0, 0, 0, 1500, 1501, 3, 180, 90, 0, 1501, 1502, 3, 206, 103, 0, 1502, 179,
		1, 0, 0, 0, 1503, 1504, 3, 206, 103, 0, 1504, 1505, 5, 23, 0, 0, 1505,
		1507, 1, 0, 0, 0, 1506, 1503, 1, 0, 0, 0, 1507, 1510, 1, 0, 0, 0, 1508,
		1506, 1, 0, 0, 0, 1508, 1509, 1, 0, 0, 0, 1509, 181, 1, 0, 0, 0, 1510,
		1508, 1, 0, 0, 0, 1511, 1512, 3, 206, 103, 0, 1512, 183, 1, 0, 0, 0, 1513,
		1520, 3, 186, 93, 0, 1514, 1520, 5, 87, 0, 0, 1515, 1520, 3, 188, 94, 0,
		1516, 1520, 5, 112, 0, 0, 1517, 1520, 3, 194, 97, 0, 1518, 1520, 3, 196,
		98, 0, 1519, 1513, 1, 0, 0, 0, 1519, 1514, 1, 0, 0, 0, 1519, 1515, 1, 0,
		0, 0, 1519, 1516, 1, 0, 0, 0, 1519, 1517, 1, 0, 0, 0, 1519, 1518, 1, 0,
		0, 0, 1520, 185, 1, 0, 0, 0, 1521, 1522, 7, 3, 0, 0, 1522, 187, 1, 0, 0,
		0, 1523, 1526, 3, 192, 96, 0, 1524, 1526, 3, 190, 95, 0, 1525, 1523, 1,
		0, 0, 0, 1525, 1524, 1, 0, 0, 0, 1526, 189, 1, 0, 0, 0, 1527, 1528, 7,
		4, 0, 0, 1528, 191, 1, 0, 0, 0, 1529, 1530, 7, 5, 0, 0, 1530, 193, 1, 0,
		0, 0, 1531, 1533, 5, 8, 0, 0, 1532, 1534, 5, 130, 0, 0, 1533, 1532, 1,
		0, 0, 0, 1533, 1534, 1, 0, 0, 0, 1534, 1552, 1, 0, 0, 0, 1535, 1537, 3,
		110, 55, 0, 1536, 1538, 5, 130, 0, 0, 1537, 1536, 1, 0, 0, 0, 1537, 1538,
		1, 0, 0, 0, 1538, 1549, 1, 0, 0, 0, 1539, 1541, 5, 2, 0, 0, 1540, 1542,
		5, 130, 0, 0, 1541, 1540, 1, 0, 0, 0, 1541, 1542, 1, 0, 0, 0, 1542, 1543,
		1, 0, 0, 0, 1543, 1545, 3, 110, 55, 0, 1544, 1546, 5, 130, 0, 0, 1545,
		1544, 1, 0, 0, 0, 1545, 1546, 1, 0, 0, 0, 1546, 1548, 1, 0, 0, 0, 1547,
		1539, 1, 0, 0, 0, 1548, 1551, 1, 0, 0, 0, 1549, 1547, 1, 0, 0, 0, 1549,
		1550, 1, 0, 0, 0, 1550, 1553, 1, 0, 0, 0, 1551, 1549, 1, 0, 0, 0, 1552,
		1535, 1, 0, 0, 0, 1552, 1553, 1, 0, 0, 0, 1553, 1554, 1, 0, 0, 0, 1554,
		1555, 5, 9, 0, 0, 1555, 195, 1, 0, 0, 0, 1556, 1558, 5, 24, 0, 0, 1557,
		1559, 5, 130, 0, 0, 1558, 1557, 1, 0, 0, 0, 1558, 1559, 1, 0, 0, 0, 1559,
		1593, 1, 0, 0, 0, 1560, 1562, 3, 198, 99, 0, 1561, 1563, 5, 130, 0, 0,
		1562, 1561, 1, 0, 0, 0, 1562, 1563, 1, 0, 0, 0, 1563, 1564, 1, 0, 0, 0,
		1564, 1566, 5, 10, 0, 0, 1565, 1567, 5, 130, 0, 0, 1566, 1565, 1, 0, 0,
		0, 1566, 1567, 1, 0, 0, 0, 1567, 1568, 1, 0, 0, 0, 1568, 1570, 3, 110,
		55, 0, 1569, 1571, 5, 130, 0, 0, 1570, 1569, 1, 0, 0, 0, 1570, 1571, 1,
		0, 0, 0, 1571, 1590, 1, 0, 0, 0, 1572, 1574, 5, 2, 0, 0, 1573, 1575, 5,
		130, 0, 0, 1574, 1573, 1, 0, 0, 0, 1574, 1575, 1, 0, 0, 0, 1575, 1576,
		1, 0, 0, 0, 1576, 1578, 3, 198, 99, 0, 1577, 1579, 5, 130, 0, 0, 1578,
		1577, 1, 0, 0, 0, 1578, 1579, 1, 0, 0, 0, 1579, 1580, 1, 0, 0, 0, 1580,
		1582, 5, 10, 0, 0, 1581, 1583, 5, 130, 0, 0, 1582, 1581, 1, 0, 0, 0, 1582,
		1583, 1, 0, 0, 0, 1583, 1584, 1, 0, 0, 0, 1584, 1586, 3, 110, 55, 0, 1585,
		1587, 5, 130, 0, 0, 1586, 1585, 1, 0, 0, 0, 1586, 1587, 1, 0, 0, 0, 1587,
		1589, 1, 0, 0, 0, 1588, 1572, 1, 0, 0, 0, 1589, 1592, 1, 0, 0, 0, 1590,
		1588, 1, 0, 0, 0, 1590, 1591, 1, 0, 0, 0, 1591, 1594, 1, 0, 0, 0, 1592,
		1590, 1, 0, 0, 0, 1593, 1560, 1, 0, 0, 0, 1593, 1594, 1, 0, 0, 0, 1594,
		1595, 1, 0, 0, 0, 1595, 1596, 5, 25, 0, 0, 1596, 197, 1, 0, 0, 0, 1597,
		1598, 3, 202, 101, 0, 1598, 199, 1, 0, 0, 0, 1599, 1602, 5, 26, 0, 0, 1600,
		1603, 3, 206, 103, 0, 1601, 1603, 5, 101, 0, 0, 1602, 1600, 1, 0, 0, 0,
		1602, 1601, 1, 0, 0, 0, 1603, 201, 1, 0, 0, 0, 1604, 1607, 3, 206, 103,
		0, 1605, 1607, 3, 204, 102, 0, 1606, 1604, 1, 0, 0, 0, 1606, 1605, 1, 0,
		0, 0, 1607, 203, 1, 0, 0, 0, 1608, 1609, 7, 6, 0, 0, 1609, 205, 1, 0, 0,
		0, 1610, 1611, 7, 7, 0, 0, 1611, 207, 1, 0, 0, 0, 1612, 1613, 7, 8, 0,
		0, 1613, 209, 1, 0, 0, 0, 1614, 1615, 7, 9, 0, 0, 1615, 211, 1, 0, 0, 0,
		1616, 1617, 7, 10, 0, 0, 1617, 213, 1, 0, 0, 0, 298, 215, 219, 228, 232,
		236, 240, 245, 249, 252, 255, 263, 267, 272, 279, 284, 287, 291, 295, 299,
		305, 309, 314, 319, 323, 326, 328, 332, 336, 341, 345, 350, 354, 363, 368,
		372, 376, 380, 383, 387, 397, 404, 417, 421, 427, 431, 435, 440, 445, 449,
		455, 459, 465, 469, 475, 479, 483, 487, 491, 495, 500, 507, 511, 516, 523,
		529, 534, 540, 543, 549, 551, 555, 559, 564, 568, 571, 578, 585, 588, 594,
		597, 603, 607, 611, 615, 619, 624, 629, 633, 638, 641, 650, 659, 664, 677,
		680, 688, 692, 697, 702, 706, 711, 717, 722, 729, 733, 738, 742, 746, 748,
		752, 754, 758, 760, 766, 772, 776, 779, 782, 786, 792, 796, 799, 802, 808,
		811, 814, 818, 824, 827, 830, 834, 838, 842, 844, 848, 850, 853, 857, 859,
		865, 869, 873, 877, 880, 885, 890, 895, 900, 906, 910, 912, 916, 920, 922,
		924, 932, 937, 948, 958, 968, 973, 977, 984, 989, 994, 999, 1004, 1009,
		1014, 1019, 1022, 1028, 1030, 1043, 1046, 1053, 1067, 1071, 1075, 1079,
		1083, 1086, 1088, 1093, 1097, 1101, 1105, 1109, 1113, 1116, 1118, 1123,
		1127, 1132, 1138, 1141, 1145, 1152, 1156, 1160, 1163, 1165, 1170, 1175,
		1179, 1182, 1186, 1195, 1199, 1203, 1214, 1218, 1223, 1227, 1231, 1236,
		1238, 1241, 1245, 1248, 1251, 1257, 1261, 1265, 1271, 1275, 1279, 1282,
		1285, 1291, 1295, 1299, 1301, 1305, 1309, 1311, 1315, 1319, 1325, 1329,
		1333, 1339, 1343, 1347, 1353, 1357, 1361, 1367, 1371, 1375, 1379, 1383,
		1386, 1392, 1396, 1408, 1412, 1416, 1418, 1422, 1426, 1430, 1434, 1437,
		1446, 1450, 1455, 1458, 1460, 1463, 1469, 1473, 1477, 1481, 1485, 1489,
		1492, 1508, 1519, 1525, 1533, 1537, 1541, 1545, 1549, 1552, 1558, 1562,
		1566, 1570, 1574, 1578, 1582, 1586, 1590, 1593, 1602, 1606,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// TTQLParserInit initializes any static state used to implement TTQLParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewTTQLParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func TTQLParserInit() {
	staticData := &ttqlParserStaticData
	staticData.once.Do(ttqlParserInit)
}

// NewTTQLParser produces a new parser instance for the optional input antlr.TokenStream.
func NewTTQLParser(input antlr.TokenStream) *TTQLParser {
	TTQLParserInit()
	this := new(TTQLParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &ttqlParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "java-escape"

	return this
}

// TTQLParser tokens.
const (
	TTQLParserEOF                   = antlr.TokenEOF
	TTQLParserT__0                  = 1
	TTQLParserT__1                  = 2
	TTQLParserT__2                  = 3
	TTQLParserT__3                  = 4
	TTQLParserT__4                  = 5
	TTQLParserT__5                  = 6
	TTQLParserT__6                  = 7
	TTQLParserT__7                  = 8
	TTQLParserT__8                  = 9
	TTQLParserT__9                  = 10
	TTQLParserT__10                 = 11
	TTQLParserT__11                 = 12
	TTQLParserT__12                 = 13
	TTQLParserT__13                 = 14
	TTQLParserT__14                 = 15
	TTQLParserT__15                 = 16
	TTQLParserT__16                 = 17
	TTQLParserT__17                 = 18
	TTQLParserT__18                 = 19
	TTQLParserT__19                 = 20
	TTQLParserT__20                 = 21
	TTQLParserT__21                 = 22
	TTQLParserT__22                 = 23
	TTQLParserT__23                 = 24
	TTQLParserT__24                 = 25
	TTQLParserT__25                 = 26
	TTQLParserT__26                 = 27
	TTQLParserT__27                 = 28
	TTQLParserT__28                 = 29
	TTQLParserT__29                 = 30
	TTQLParserT__30                 = 31
	TTQLParserT__31                 = 32
	TTQLParserT__32                 = 33
	TTQLParserT__33                 = 34
	TTQLParserT__34                 = 35
	TTQLParserT__35                 = 36
	TTQLParserT__36                 = 37
	TTQLParserT__37                 = 38
	TTQLParserT__38                 = 39
	TTQLParserT__39                 = 40
	TTQLParserT__40                 = 41
	TTQLParserT__41                 = 42
	TTQLParserT__42                 = 43
	TTQLParserT__43                 = 44
	TTQLParserT__44                 = 45
	TTQLParserDATETIME              = 46
	TTQLParserCURRENT               = 47
	TTQLParserFROM                  = 48
	TTQLParserTO                    = 49
	TTQLParserSHALLOW               = 50
	TTQLParserUNION                 = 51
	TTQLParserALL                   = 52
	TTQLParserOPTIONAL              = 53
	TTQLParserMATCH                 = 54
	TTQLParserUNWIND                = 55
	TTQLParserAS                    = 56
	TTQLParserMERGE                 = 57
	TTQLParserON                    = 58
	TTQLParserCREATE                = 59
	TTQLParserSET                   = 60
	TTQLParserDETACH                = 61
	TTQLParserDELETE                = 62
	TTQLParserREMOVE                = 63
	TTQLParserCALL                  = 64
	TTQLParserYIELD                 = 65
	TTQLParserWITH                  = 66
	TTQLParserRETURN                = 67
	TTQLParserDISTINCT              = 68
	TTQLParserORDER                 = 69
	TTQLParserBY                    = 70
	TTQLParserL_SKIP                = 71
	TTQLParserLIMIT                 = 72
	TTQLParserASCENDING             = 73
	TTQLParserASC                   = 74
	TTQLParserDESCENDING            = 75
	TTQLParserDESC                  = 76
	TTQLParserWHERE                 = 77
	TTQLParserOR                    = 78
	TTQLParserXOR                   = 79
	TTQLParserAND                   = 80
	TTQLParserNOT                   = 81
	TTQLParserSTARTS                = 82
	TTQLParserENDS                  = 83
	TTQLParserCONTAINS              = 84
	TTQLParserIN                    = 85
	TTQLParserIS                    = 86
	TTQLParserNULL                  = 87
	TTQLParserCOUNT                 = 88
	TTQLParserCASE                  = 89
	TTQLParserELSE                  = 90
	TTQLParserEND                   = 91
	TTQLParserWHEN                  = 92
	TTQLParserTHEN                  = 93
	TTQLParserANY                   = 94
	TTQLParserNONE                  = 95
	TTQLParserSINGLE                = 96
	TTQLParserEXISTS                = 97
	TTQLParserTRUE                  = 98
	TTQLParserFALSE                 = 99
	TTQLParserHexInteger            = 100
	TTQLParserDecimalInteger        = 101
	TTQLParserOctalInteger          = 102
	TTQLParserHexLetter             = 103
	TTQLParserHexDigit              = 104
	TTQLParserDigit                 = 105
	TTQLParserNonZeroDigit          = 106
	TTQLParserNonZeroOctDigit       = 107
	TTQLParserOctDigit              = 108
	TTQLParserZeroDigit             = 109
	TTQLParserExponentDecimalReal   = 110
	TTQLParserRegularDecimalReal    = 111
	TTQLParserStringLiteral         = 112
	TTQLParserEscapedChar           = 113
	TTQLParserCONSTRAINT            = 114
	TTQLParserDO                    = 115
	TTQLParserFOR                   = 116
	TTQLParserREQUIRE               = 117
	TTQLParserUNIQUE                = 118
	TTQLParserMANDATORY             = 119
	TTQLParserSCALAR                = 120
	TTQLParserOF                    = 121
	TTQLParserADD                   = 122
	TTQLParserDROP                  = 123
	TTQLParserFILTER                = 124
	TTQLParserEXTRACT               = 125
	TTQLParserUnescapedSymbolicName = 126
	TTQLParserIdentifierStart       = 127
	TTQLParserIdentifierPart        = 128
	TTQLParserEscapedSymbolicName   = 129
	TTQLParserSP                    = 130
	TTQLParserWHITESPACE            = 131
	TTQLParserComment               = 132
)

// TTQLParser rules.
const (
	TTQLParserRULE_ttQL                                 = 0
	TTQLParserRULE_ttQL_Statement                       = 1
	TTQLParserRULE_ttQL_Query                           = 2
	TTQLParserRULE_ttQL_TimeClause                      = 3
	TTQLParserRULE_oC_Cypher                            = 4
	TTQLParserRULE_oC_Statement                         = 5
	TTQLParserRULE_oC_Query                             = 6
	TTQLParserRULE_oC_RegularQuery                      = 7
	TTQLParserRULE_oC_Union                             = 8
	TTQLParserRULE_oC_SingleQuery                       = 9
	TTQLParserRULE_oC_SinglePartQuery                   = 10
	TTQLParserRULE_oC_MultiPartQuery                    = 11
	TTQLParserRULE_oC_UpdatingClause                    = 12
	TTQLParserRULE_oC_ReadingClause                     = 13
	TTQLParserRULE_oC_Match                             = 14
	TTQLParserRULE_oC_Unwind                            = 15
	TTQLParserRULE_oC_Merge                             = 16
	TTQLParserRULE_oC_MergeAction                       = 17
	TTQLParserRULE_oC_Create                            = 18
	TTQLParserRULE_oC_Set                               = 19
	TTQLParserRULE_oC_SetItem                           = 20
	TTQLParserRULE_oC_Delete                            = 21
	TTQLParserRULE_oC_Remove                            = 22
	TTQLParserRULE_oC_RemoveItem                        = 23
	TTQLParserRULE_oC_InQueryCall                       = 24
	TTQLParserRULE_oC_StandaloneCall                    = 25
	TTQLParserRULE_oC_YieldItems                        = 26
	TTQLParserRULE_oC_YieldItem                         = 27
	TTQLParserRULE_oC_With                              = 28
	TTQLParserRULE_oC_Return                            = 29
	TTQLParserRULE_oC_ProjectionBody                    = 30
	TTQLParserRULE_oC_ProjectionItems                   = 31
	TTQLParserRULE_oC_ProjectionItem                    = 32
	TTQLParserRULE_oC_Order                             = 33
	TTQLParserRULE_oC_Skip                              = 34
	TTQLParserRULE_oC_Limit                             = 35
	TTQLParserRULE_oC_SortItem                          = 36
	TTQLParserRULE_oC_Where                             = 37
	TTQLParserRULE_oC_Pattern                           = 38
	TTQLParserRULE_oC_PatternPart                       = 39
	TTQLParserRULE_oC_AnonymousPatternPart              = 40
	TTQLParserRULE_oC_PatternElement                    = 41
	TTQLParserRULE_oC_RelationshipsPattern              = 42
	TTQLParserRULE_oC_NodePattern                       = 43
	TTQLParserRULE_oC_PatternElementChain               = 44
	TTQLParserRULE_oC_RelationshipPattern               = 45
	TTQLParserRULE_oC_RelationshipDetail                = 46
	TTQLParserRULE_oC_Properties                        = 47
	TTQLParserRULE_oC_RelationshipTypes                 = 48
	TTQLParserRULE_oC_NodeLabels                        = 49
	TTQLParserRULE_oC_NodeLabel                         = 50
	TTQLParserRULE_oC_RangeLiteral                      = 51
	TTQLParserRULE_oC_LabelName                         = 52
	TTQLParserRULE_oC_RelTypeName                       = 53
	TTQLParserRULE_oC_PropertyExpression                = 54
	TTQLParserRULE_oC_Expression                        = 55
	TTQLParserRULE_oC_OrExpression                      = 56
	TTQLParserRULE_oC_XorExpression                     = 57
	TTQLParserRULE_oC_AndExpression                     = 58
	TTQLParserRULE_oC_NotExpression                     = 59
	TTQLParserRULE_oC_ComparisonExpression              = 60
	TTQLParserRULE_oC_PartialComparisonExpression       = 61
	TTQLParserRULE_oC_StringListNullPredicateExpression = 62
	TTQLParserRULE_oC_StringPredicateExpression         = 63
	TTQLParserRULE_oC_ListPredicateExpression           = 64
	TTQLParserRULE_oC_NullPredicateExpression           = 65
	TTQLParserRULE_oC_AddOrSubtractExpression           = 66
	TTQLParserRULE_oC_MultiplyDivideModuloExpression    = 67
	TTQLParserRULE_oC_PowerOfExpression                 = 68
	TTQLParserRULE_oC_UnaryAddOrSubtractExpression      = 69
	TTQLParserRULE_oC_ListOperatorExpression            = 70
	TTQLParserRULE_oC_PropertyOrLabelsExpression        = 71
	TTQLParserRULE_oC_PropertyLookup                    = 72
	TTQLParserRULE_oC_Atom                              = 73
	TTQLParserRULE_oC_CaseExpression                    = 74
	TTQLParserRULE_oC_CaseAlternative                   = 75
	TTQLParserRULE_oC_ListComprehension                 = 76
	TTQLParserRULE_oC_PatternComprehension              = 77
	TTQLParserRULE_oC_Quantifier                        = 78
	TTQLParserRULE_oC_FilterExpression                  = 79
	TTQLParserRULE_oC_PatternPredicate                  = 80
	TTQLParserRULE_oC_ParenthesizedExpression           = 81
	TTQLParserRULE_oC_IdInColl                          = 82
	TTQLParserRULE_oC_FunctionInvocation                = 83
	TTQLParserRULE_oC_FunctionName                      = 84
	TTQLParserRULE_oC_ExistentialSubquery               = 85
	TTQLParserRULE_oC_ExplicitProcedureInvocation       = 86
	TTQLParserRULE_oC_ImplicitProcedureInvocation       = 87
	TTQLParserRULE_oC_ProcedureResultField              = 88
	TTQLParserRULE_oC_ProcedureName                     = 89
	TTQLParserRULE_oC_Namespace                         = 90
	TTQLParserRULE_oC_Variable                          = 91
	TTQLParserRULE_oC_Literal                           = 92
	TTQLParserRULE_oC_BooleanLiteral                    = 93
	TTQLParserRULE_oC_NumberLiteral                     = 94
	TTQLParserRULE_oC_IntegerLiteral                    = 95
	TTQLParserRULE_oC_DoubleLiteral                     = 96
	TTQLParserRULE_oC_ListLiteral                       = 97
	TTQLParserRULE_oC_MapLiteral                        = 98
	TTQLParserRULE_oC_PropertyKeyName                   = 99
	TTQLParserRULE_oC_Parameter                         = 100
	TTQLParserRULE_oC_SchemaName                        = 101
	TTQLParserRULE_oC_ReservedWord                      = 102
	TTQLParserRULE_oC_SymbolicName                      = 103
	TTQLParserRULE_oC_LeftArrowHead                     = 104
	TTQLParserRULE_oC_RightArrowHead                    = 105
	TTQLParserRULE_oC_Dash                              = 106
)

// ITtQLContext is an interface to support dynamic dispatch.
type ITtQLContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTtQLContext differentiates from other interfaces.
	IsTtQLContext()
}

type TtQLContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTtQLContext() *TtQLContext {
	var p = new(TtQLContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_ttQL
	return p
}

func (*TtQLContext) IsTtQLContext() {}

func NewTtQLContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TtQLContext {
	var p = new(TtQLContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_ttQL

	return p
}

func (s *TtQLContext) GetParser() antlr.Parser { return s.parser }

func (s *TtQLContext) TtQL_Statement() ITtQL_StatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITtQL_StatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITtQL_StatementContext)
}

func (s *TtQLContext) OC_Cypher() IOC_CypherContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_CypherContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_CypherContext)
}

func (s *TtQLContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *TtQLContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *TtQLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TtQLContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TtQLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterTtQL(s)
	}
}

func (s *TtQLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitTtQL(s)
	}
}

func (p *TTQLParser) TtQL() (localctx ITtQLContext) {
	this := p
	_ = this

	localctx = NewTtQLContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, TTQLParserRULE_ttQL)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(214)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(217)
		p.TtQL_Statement()
	}
	p.SetState(219)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(218)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(221)
		p.OC_Cypher()
	}

	return localctx
}

// ITtQL_StatementContext is an interface to support dynamic dispatch.
type ITtQL_StatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTtQL_StatementContext differentiates from other interfaces.
	IsTtQL_StatementContext()
}

type TtQL_StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTtQL_StatementContext() *TtQL_StatementContext {
	var p = new(TtQL_StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_ttQL_Statement
	return p
}

func (*TtQL_StatementContext) IsTtQL_StatementContext() {}

func NewTtQL_StatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TtQL_StatementContext {
	var p = new(TtQL_StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_ttQL_Statement

	return p
}

func (s *TtQL_StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TtQL_StatementContext) TtQL_Query() ITtQL_QueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITtQL_QueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITtQL_QueryContext)
}

func (s *TtQL_StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TtQL_StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TtQL_StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterTtQL_Statement(s)
	}
}

func (s *TtQL_StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitTtQL_Statement(s)
	}
}

func (p *TTQLParser) TtQL_Statement() (localctx ITtQL_StatementContext) {
	this := p
	_ = this

	localctx = NewTtQL_StatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, TTQLParserRULE_ttQL_Statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(223)
		p.TtQL_Query()
	}

	return localctx
}

// ITtQL_QueryContext is an interface to support dynamic dispatch.
type ITtQL_QueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTtQL_QueryContext differentiates from other interfaces.
	IsTtQL_QueryContext()
}

type TtQL_QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTtQL_QueryContext() *TtQL_QueryContext {
	var p = new(TtQL_QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_ttQL_Query
	return p
}

func (*TtQL_QueryContext) IsTtQL_QueryContext() {}

func NewTtQL_QueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TtQL_QueryContext {
	var p = new(TtQL_QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_ttQL_Query

	return p
}

func (s *TtQL_QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *TtQL_QueryContext) TtQL_TimeClause() ITtQL_TimeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITtQL_TimeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITtQL_TimeClauseContext)
}

func (s *TtQL_QueryContext) SP() antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, 0)
}

func (s *TtQL_QueryContext) SHALLOW() antlr.TerminalNode {
	return s.GetToken(TTQLParserSHALLOW, 0)
}

func (s *TtQL_QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TtQL_QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TtQL_QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterTtQL_Query(s)
	}
}

func (s *TtQL_QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitTtQL_Query(s)
	}
}

func (p *TTQLParser) TtQL_Query() (localctx ITtQL_QueryContext) {
	this := p
	_ = this

	localctx = NewTtQL_QueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, TTQLParserRULE_ttQL_Query)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(225)
		p.TtQL_TimeClause()
	}
	{
		p.SetState(226)
		p.Match(TTQLParserSP)
	}
	p.SetState(228)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSHALLOW {
		{
			p.SetState(227)
			p.Match(TTQLParserSHALLOW)
		}

	}

	return localctx
}

// ITtQL_TimeClauseContext is an interface to support dynamic dispatch.
type ITtQL_TimeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTtQL_TimeClauseContext differentiates from other interfaces.
	IsTtQL_TimeClauseContext()
}

type TtQL_TimeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTtQL_TimeClauseContext() *TtQL_TimeClauseContext {
	var p = new(TtQL_TimeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_ttQL_TimeClause
	return p
}

func (*TtQL_TimeClauseContext) IsTtQL_TimeClauseContext() {}

func NewTtQL_TimeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TtQL_TimeClauseContext {
	var p = new(TtQL_TimeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_ttQL_TimeClause

	return p
}

func (s *TtQL_TimeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TtQL_TimeClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(TTQLParserFROM, 0)
}

func (s *TtQL_TimeClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(TTQLParserTO, 0)
}

func (s *TtQL_TimeClauseContext) AllDATETIME() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserDATETIME)
}

func (s *TtQL_TimeClauseContext) DATETIME(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserDATETIME, i)
}

func (s *TtQL_TimeClauseContext) AllCURRENT() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserCURRENT)
}

func (s *TtQL_TimeClauseContext) CURRENT(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserCURRENT, i)
}

func (s *TtQL_TimeClauseContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *TtQL_TimeClauseContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *TtQL_TimeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TtQL_TimeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TtQL_TimeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterTtQL_TimeClause(s)
	}
}

func (s *TtQL_TimeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitTtQL_TimeClause(s)
	}
}

func (p *TTQLParser) TtQL_TimeClause() (localctx ITtQL_TimeClauseContext) {
	this := p
	_ = this

	localctx = NewTtQL_TimeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, TTQLParserRULE_ttQL_TimeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(230)
		p.Match(TTQLParserFROM)
	}
	p.SetState(232)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(231)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(234)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TTQLParserDATETIME || _la == TTQLParserCURRENT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(236)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(235)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(238)
		p.Match(TTQLParserTO)
	}
	p.SetState(240)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(239)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(242)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TTQLParserDATETIME || _la == TTQLParserCURRENT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOC_CypherContext is an interface to support dynamic dispatch.
type IOC_CypherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_CypherContext differentiates from other interfaces.
	IsOC_CypherContext()
}

type OC_CypherContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_CypherContext() *OC_CypherContext {
	var p = new(OC_CypherContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Cypher
	return p
}

func (*OC_CypherContext) IsOC_CypherContext() {}

func NewOC_CypherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_CypherContext {
	var p = new(OC_CypherContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Cypher

	return p
}

func (s *OC_CypherContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_CypherContext) OC_Statement() IOC_StatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_StatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_StatementContext)
}

func (s *OC_CypherContext) EOF() antlr.TerminalNode {
	return s.GetToken(TTQLParserEOF, 0)
}

func (s *OC_CypherContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_CypherContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_CypherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_CypherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_CypherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Cypher(s)
	}
}

func (s *OC_CypherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Cypher(s)
	}
}

func (p *TTQLParser) OC_Cypher() (localctx IOC_CypherContext) {
	this := p
	_ = this

	localctx = NewOC_CypherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, TTQLParserRULE_oC_Cypher)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(245)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(244)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(247)
		p.OC_Statement()
	}
	p.SetState(252)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
		p.SetState(249)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(248)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(251)
			p.Match(TTQLParserT__0)
		}

	}
	p.SetState(255)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(254)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(257)
		p.Match(TTQLParserEOF)
	}

	return localctx
}

// IOC_StatementContext is an interface to support dynamic dispatch.
type IOC_StatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_StatementContext differentiates from other interfaces.
	IsOC_StatementContext()
}

type OC_StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_StatementContext() *OC_StatementContext {
	var p = new(OC_StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Statement
	return p
}

func (*OC_StatementContext) IsOC_StatementContext() {}

func NewOC_StatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_StatementContext {
	var p = new(OC_StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Statement

	return p
}

func (s *OC_StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_StatementContext) OC_Query() IOC_QueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_QueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_QueryContext)
}

func (s *OC_StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Statement(s)
	}
}

func (s *OC_StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Statement(s)
	}
}

func (p *TTQLParser) OC_Statement() (localctx IOC_StatementContext) {
	this := p
	_ = this

	localctx = NewOC_StatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, TTQLParserRULE_oC_Statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(259)
		p.OC_Query()
	}

	return localctx
}

// IOC_QueryContext is an interface to support dynamic dispatch.
type IOC_QueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_QueryContext differentiates from other interfaces.
	IsOC_QueryContext()
}

type OC_QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_QueryContext() *OC_QueryContext {
	var p = new(OC_QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Query
	return p
}

func (*OC_QueryContext) IsOC_QueryContext() {}

func NewOC_QueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_QueryContext {
	var p = new(OC_QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Query

	return p
}

func (s *OC_QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_QueryContext) OC_RegularQuery() IOC_RegularQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_RegularQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_RegularQueryContext)
}

func (s *OC_QueryContext) OC_StandaloneCall() IOC_StandaloneCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_StandaloneCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_StandaloneCallContext)
}

func (s *OC_QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Query(s)
	}
}

func (s *OC_QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Query(s)
	}
}

func (p *TTQLParser) OC_Query() (localctx IOC_QueryContext) {
	this := p
	_ = this

	localctx = NewOC_QueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, TTQLParserRULE_oC_Query)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(263)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(261)
			p.OC_RegularQuery()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(262)
			p.OC_StandaloneCall()
		}

	}

	return localctx
}

// IOC_RegularQueryContext is an interface to support dynamic dispatch.
type IOC_RegularQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RegularQueryContext differentiates from other interfaces.
	IsOC_RegularQueryContext()
}

type OC_RegularQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RegularQueryContext() *OC_RegularQueryContext {
	var p = new(OC_RegularQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_RegularQuery
	return p
}

func (*OC_RegularQueryContext) IsOC_RegularQueryContext() {}

func NewOC_RegularQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RegularQueryContext {
	var p = new(OC_RegularQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_RegularQuery

	return p
}

func (s *OC_RegularQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RegularQueryContext) OC_SingleQuery() IOC_SingleQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SingleQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SingleQueryContext)
}

func (s *OC_RegularQueryContext) AllOC_Union() []IOC_UnionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_UnionContext); ok {
			len++
		}
	}

	tst := make([]IOC_UnionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_UnionContext); ok {
			tst[i] = t.(IOC_UnionContext)
			i++
		}
	}

	return tst
}

func (s *OC_RegularQueryContext) OC_Union(i int) IOC_UnionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_UnionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_UnionContext)
}

func (s *OC_RegularQueryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_RegularQueryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_RegularQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RegularQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_RegularQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_RegularQuery(s)
	}
}

func (s *OC_RegularQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_RegularQuery(s)
	}
}

func (p *TTQLParser) OC_RegularQuery() (localctx IOC_RegularQueryContext) {
	this := p
	_ = this

	localctx = NewOC_RegularQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, TTQLParserRULE_oC_RegularQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(265)
		p.OC_SingleQuery()
	}
	p.SetState(272)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(267)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(266)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(269)
				p.OC_Union()
			}

		}
		p.SetState(274)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_UnionContext is an interface to support dynamic dispatch.
type IOC_UnionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_UnionContext differentiates from other interfaces.
	IsOC_UnionContext()
}

type OC_UnionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_UnionContext() *OC_UnionContext {
	var p = new(OC_UnionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Union
	return p
}

func (*OC_UnionContext) IsOC_UnionContext() {}

func NewOC_UnionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_UnionContext {
	var p = new(OC_UnionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Union

	return p
}

func (s *OC_UnionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_UnionContext) UNION() antlr.TerminalNode {
	return s.GetToken(TTQLParserUNION, 0)
}

func (s *OC_UnionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_UnionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_UnionContext) ALL() antlr.TerminalNode {
	return s.GetToken(TTQLParserALL, 0)
}

func (s *OC_UnionContext) OC_SingleQuery() IOC_SingleQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SingleQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SingleQueryContext)
}

func (s *OC_UnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_UnionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_UnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Union(s)
	}
}

func (s *OC_UnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Union(s)
	}
}

func (p *TTQLParser) OC_Union() (localctx IOC_UnionContext) {
	this := p
	_ = this

	localctx = NewOC_UnionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, TTQLParserRULE_oC_Union)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(287)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(275)
			p.Match(TTQLParserUNION)
		}
		{
			p.SetState(276)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(277)
			p.Match(TTQLParserALL)
		}
		p.SetState(279)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(278)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(281)
			p.OC_SingleQuery()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(282)
			p.Match(TTQLParserUNION)
		}
		p.SetState(284)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(283)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(286)
			p.OC_SingleQuery()
		}

	}

	return localctx
}

// IOC_SingleQueryContext is an interface to support dynamic dispatch.
type IOC_SingleQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SingleQueryContext differentiates from other interfaces.
	IsOC_SingleQueryContext()
}

type OC_SingleQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SingleQueryContext() *OC_SingleQueryContext {
	var p = new(OC_SingleQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_SingleQuery
	return p
}

func (*OC_SingleQueryContext) IsOC_SingleQueryContext() {}

func NewOC_SingleQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SingleQueryContext {
	var p = new(OC_SingleQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_SingleQuery

	return p
}

func (s *OC_SingleQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SingleQueryContext) OC_SinglePartQuery() IOC_SinglePartQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SinglePartQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SinglePartQueryContext)
}

func (s *OC_SingleQueryContext) OC_MultiPartQuery() IOC_MultiPartQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_MultiPartQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_MultiPartQueryContext)
}

func (s *OC_SingleQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SingleQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_SingleQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_SingleQuery(s)
	}
}

func (s *OC_SingleQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_SingleQuery(s)
	}
}

func (p *TTQLParser) OC_SingleQuery() (localctx IOC_SingleQueryContext) {
	this := p
	_ = this

	localctx = NewOC_SingleQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, TTQLParserRULE_oC_SingleQuery)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(291)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(289)
			p.OC_SinglePartQuery()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(290)
			p.OC_MultiPartQuery()
		}

	}

	return localctx
}

// IOC_SinglePartQueryContext is an interface to support dynamic dispatch.
type IOC_SinglePartQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SinglePartQueryContext differentiates from other interfaces.
	IsOC_SinglePartQueryContext()
}

type OC_SinglePartQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SinglePartQueryContext() *OC_SinglePartQueryContext {
	var p = new(OC_SinglePartQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_SinglePartQuery
	return p
}

func (*OC_SinglePartQueryContext) IsOC_SinglePartQueryContext() {}

func NewOC_SinglePartQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SinglePartQueryContext {
	var p = new(OC_SinglePartQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_SinglePartQuery

	return p
}

func (s *OC_SinglePartQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SinglePartQueryContext) OC_Return() IOC_ReturnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ReturnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ReturnContext)
}

func (s *OC_SinglePartQueryContext) AllOC_ReadingClause() []IOC_ReadingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_ReadingClauseContext); ok {
			len++
		}
	}

	tst := make([]IOC_ReadingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_ReadingClauseContext); ok {
			tst[i] = t.(IOC_ReadingClauseContext)
			i++
		}
	}

	return tst
}

func (s *OC_SinglePartQueryContext) OC_ReadingClause(i int) IOC_ReadingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ReadingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ReadingClauseContext)
}

func (s *OC_SinglePartQueryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_SinglePartQueryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_SinglePartQueryContext) AllOC_UpdatingClause() []IOC_UpdatingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_UpdatingClauseContext); ok {
			len++
		}
	}

	tst := make([]IOC_UpdatingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_UpdatingClauseContext); ok {
			tst[i] = t.(IOC_UpdatingClauseContext)
			i++
		}
	}

	return tst
}

func (s *OC_SinglePartQueryContext) OC_UpdatingClause(i int) IOC_UpdatingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_UpdatingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_UpdatingClauseContext)
}

func (s *OC_SinglePartQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SinglePartQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_SinglePartQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_SinglePartQuery(s)
	}
}

func (s *OC_SinglePartQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_SinglePartQuery(s)
	}
}

func (p *TTQLParser) OC_SinglePartQuery() (localctx IOC_SinglePartQueryContext) {
	this := p
	_ = this

	localctx = NewOC_SinglePartQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, TTQLParserRULE_oC_SinglePartQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(328)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(299)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-53)) & ^0x3f) == 0 && ((int64(1)<<(_la-53))&2055) != 0 {
			{
				p.SetState(293)
				p.OC_ReadingClause()
			}
			p.SetState(295)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(294)
					p.Match(TTQLParserSP)
				}

			}

			p.SetState(301)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(302)
			p.OC_Return()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(309)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-53)) & ^0x3f) == 0 && ((int64(1)<<(_la-53))&2055) != 0 {
			{
				p.SetState(303)
				p.OC_ReadingClause()
			}
			p.SetState(305)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(304)
					p.Match(TTQLParserSP)
				}

			}

			p.SetState(311)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(312)
			p.OC_UpdatingClause()
		}
		p.SetState(319)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(314)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(313)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(316)
					p.OC_UpdatingClause()
				}

			}
			p.SetState(321)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())
		}
		p.SetState(326)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
			p.SetState(323)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(322)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(325)
				p.OC_Return()
			}

		}

	}

	return localctx
}

// IOC_MultiPartQueryContext is an interface to support dynamic dispatch.
type IOC_MultiPartQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_MultiPartQueryContext differentiates from other interfaces.
	IsOC_MultiPartQueryContext()
}

type OC_MultiPartQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_MultiPartQueryContext() *OC_MultiPartQueryContext {
	var p = new(OC_MultiPartQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_MultiPartQuery
	return p
}

func (*OC_MultiPartQueryContext) IsOC_MultiPartQueryContext() {}

func NewOC_MultiPartQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_MultiPartQueryContext {
	var p = new(OC_MultiPartQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_MultiPartQuery

	return p
}

func (s *OC_MultiPartQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_MultiPartQueryContext) OC_SinglePartQuery() IOC_SinglePartQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SinglePartQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SinglePartQueryContext)
}

func (s *OC_MultiPartQueryContext) AllOC_With() []IOC_WithContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_WithContext); ok {
			len++
		}
	}

	tst := make([]IOC_WithContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_WithContext); ok {
			tst[i] = t.(IOC_WithContext)
			i++
		}
	}

	return tst
}

func (s *OC_MultiPartQueryContext) OC_With(i int) IOC_WithContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_WithContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_WithContext)
}

func (s *OC_MultiPartQueryContext) AllOC_ReadingClause() []IOC_ReadingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_ReadingClauseContext); ok {
			len++
		}
	}

	tst := make([]IOC_ReadingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_ReadingClauseContext); ok {
			tst[i] = t.(IOC_ReadingClauseContext)
			i++
		}
	}

	return tst
}

func (s *OC_MultiPartQueryContext) OC_ReadingClause(i int) IOC_ReadingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ReadingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ReadingClauseContext)
}

func (s *OC_MultiPartQueryContext) AllOC_UpdatingClause() []IOC_UpdatingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_UpdatingClauseContext); ok {
			len++
		}
	}

	tst := make([]IOC_UpdatingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_UpdatingClauseContext); ok {
			tst[i] = t.(IOC_UpdatingClauseContext)
			i++
		}
	}

	return tst
}

func (s *OC_MultiPartQueryContext) OC_UpdatingClause(i int) IOC_UpdatingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_UpdatingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_UpdatingClauseContext)
}

func (s *OC_MultiPartQueryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_MultiPartQueryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_MultiPartQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_MultiPartQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_MultiPartQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_MultiPartQuery(s)
	}
}

func (s *OC_MultiPartQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_MultiPartQuery(s)
	}
}

func (p *TTQLParser) OC_MultiPartQuery() (localctx IOC_MultiPartQueryContext) {
	this := p
	_ = this

	localctx = NewOC_MultiPartQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, TTQLParserRULE_oC_MultiPartQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(352)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(336)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for (int64((_la-53)) & ^0x3f) == 0 && ((int64(1)<<(_la-53))&2055) != 0 {
				{
					p.SetState(330)
					p.OC_ReadingClause()
				}
				p.SetState(332)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(331)
						p.Match(TTQLParserSP)
					}

				}

				p.SetState(338)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(345)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-432345564227567616) != 0 {
				{
					p.SetState(339)
					p.OC_UpdatingClause()
				}
				p.SetState(341)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(340)
						p.Match(TTQLParserSP)
					}

				}

				p.SetState(347)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(348)
				p.OC_With()
			}
			p.SetState(350)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(349)
					p.Match(TTQLParserSP)
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(354)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())
	}
	{
		p.SetState(356)
		p.OC_SinglePartQuery()
	}

	return localctx
}

// IOC_UpdatingClauseContext is an interface to support dynamic dispatch.
type IOC_UpdatingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_UpdatingClauseContext differentiates from other interfaces.
	IsOC_UpdatingClauseContext()
}

type OC_UpdatingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_UpdatingClauseContext() *OC_UpdatingClauseContext {
	var p = new(OC_UpdatingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_UpdatingClause
	return p
}

func (*OC_UpdatingClauseContext) IsOC_UpdatingClauseContext() {}

func NewOC_UpdatingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_UpdatingClauseContext {
	var p = new(OC_UpdatingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_UpdatingClause

	return p
}

func (s *OC_UpdatingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_UpdatingClauseContext) OC_Create() IOC_CreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_CreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_CreateContext)
}

func (s *OC_UpdatingClauseContext) OC_Merge() IOC_MergeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_MergeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_MergeContext)
}

func (s *OC_UpdatingClauseContext) OC_Delete() IOC_DeleteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_DeleteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_DeleteContext)
}

func (s *OC_UpdatingClauseContext) OC_Set() IOC_SetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SetContext)
}

func (s *OC_UpdatingClauseContext) OC_Remove() IOC_RemoveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_RemoveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_RemoveContext)
}

func (s *OC_UpdatingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_UpdatingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_UpdatingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_UpdatingClause(s)
	}
}

func (s *OC_UpdatingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_UpdatingClause(s)
	}
}

func (p *TTQLParser) OC_UpdatingClause() (localctx IOC_UpdatingClauseContext) {
	this := p
	_ = this

	localctx = NewOC_UpdatingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, TTQLParserRULE_oC_UpdatingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(363)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TTQLParserCREATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(358)
			p.OC_Create()
		}

	case TTQLParserMERGE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(359)
			p.OC_Merge()
		}

	case TTQLParserDETACH, TTQLParserDELETE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(360)
			p.OC_Delete()
		}

	case TTQLParserSET:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(361)
			p.OC_Set()
		}

	case TTQLParserREMOVE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(362)
			p.OC_Remove()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOC_ReadingClauseContext is an interface to support dynamic dispatch.
type IOC_ReadingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ReadingClauseContext differentiates from other interfaces.
	IsOC_ReadingClauseContext()
}

type OC_ReadingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ReadingClauseContext() *OC_ReadingClauseContext {
	var p = new(OC_ReadingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ReadingClause
	return p
}

func (*OC_ReadingClauseContext) IsOC_ReadingClauseContext() {}

func NewOC_ReadingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ReadingClauseContext {
	var p = new(OC_ReadingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ReadingClause

	return p
}

func (s *OC_ReadingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ReadingClauseContext) OC_Match() IOC_MatchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_MatchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_MatchContext)
}

func (s *OC_ReadingClauseContext) OC_Unwind() IOC_UnwindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_UnwindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_UnwindContext)
}

func (s *OC_ReadingClauseContext) OC_InQueryCall() IOC_InQueryCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_InQueryCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_InQueryCallContext)
}

func (s *OC_ReadingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ReadingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ReadingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ReadingClause(s)
	}
}

func (s *OC_ReadingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ReadingClause(s)
	}
}

func (p *TTQLParser) OC_ReadingClause() (localctx IOC_ReadingClauseContext) {
	this := p
	_ = this

	localctx = NewOC_ReadingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, TTQLParserRULE_oC_ReadingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(368)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TTQLParserOPTIONAL, TTQLParserMATCH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(365)
			p.OC_Match()
		}

	case TTQLParserUNWIND:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(366)
			p.OC_Unwind()
		}

	case TTQLParserCALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(367)
			p.OC_InQueryCall()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOC_MatchContext is an interface to support dynamic dispatch.
type IOC_MatchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_MatchContext differentiates from other interfaces.
	IsOC_MatchContext()
}

type OC_MatchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_MatchContext() *OC_MatchContext {
	var p = new(OC_MatchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Match
	return p
}

func (*OC_MatchContext) IsOC_MatchContext() {}

func NewOC_MatchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_MatchContext {
	var p = new(OC_MatchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Match

	return p
}

func (s *OC_MatchContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_MatchContext) MATCH() antlr.TerminalNode {
	return s.GetToken(TTQLParserMATCH, 0)
}

func (s *OC_MatchContext) OC_Pattern() IOC_PatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PatternContext)
}

func (s *OC_MatchContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(TTQLParserOPTIONAL, 0)
}

func (s *OC_MatchContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_MatchContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_MatchContext) OC_Where() IOC_WhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_WhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_WhereContext)
}

func (s *OC_MatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_MatchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_MatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Match(s)
	}
}

func (s *OC_MatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Match(s)
	}
}

func (p *TTQLParser) OC_Match() (localctx IOC_MatchContext) {
	this := p
	_ = this

	localctx = NewOC_MatchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, TTQLParserRULE_oC_Match)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(372)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserOPTIONAL {
		{
			p.SetState(370)
			p.Match(TTQLParserOPTIONAL)
		}
		{
			p.SetState(371)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(374)
		p.Match(TTQLParserMATCH)
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(375)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(378)
		p.OC_Pattern()
	}
	p.SetState(383)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
		p.SetState(380)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(379)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(382)
			p.OC_Where()
		}

	}

	return localctx
}

// IOC_UnwindContext is an interface to support dynamic dispatch.
type IOC_UnwindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_UnwindContext differentiates from other interfaces.
	IsOC_UnwindContext()
}

type OC_UnwindContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_UnwindContext() *OC_UnwindContext {
	var p = new(OC_UnwindContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Unwind
	return p
}

func (*OC_UnwindContext) IsOC_UnwindContext() {}

func NewOC_UnwindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_UnwindContext {
	var p = new(OC_UnwindContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Unwind

	return p
}

func (s *OC_UnwindContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_UnwindContext) UNWIND() antlr.TerminalNode {
	return s.GetToken(TTQLParserUNWIND, 0)
}

func (s *OC_UnwindContext) OC_Expression() IOC_ExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_UnwindContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_UnwindContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_UnwindContext) AS() antlr.TerminalNode {
	return s.GetToken(TTQLParserAS, 0)
}

func (s *OC_UnwindContext) OC_Variable() IOC_VariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_VariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_UnwindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_UnwindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_UnwindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Unwind(s)
	}
}

func (s *OC_UnwindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Unwind(s)
	}
}

func (p *TTQLParser) OC_Unwind() (localctx IOC_UnwindContext) {
	this := p
	_ = this

	localctx = NewOC_UnwindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, TTQLParserRULE_oC_Unwind)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(385)
		p.Match(TTQLParserUNWIND)
	}
	p.SetState(387)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(386)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(389)
		p.OC_Expression()
	}
	{
		p.SetState(390)
		p.Match(TTQLParserSP)
	}
	{
		p.SetState(391)
		p.Match(TTQLParserAS)
	}
	{
		p.SetState(392)
		p.Match(TTQLParserSP)
	}
	{
		p.SetState(393)
		p.OC_Variable()
	}

	return localctx
}

// IOC_MergeContext is an interface to support dynamic dispatch.
type IOC_MergeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_MergeContext differentiates from other interfaces.
	IsOC_MergeContext()
}

type OC_MergeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_MergeContext() *OC_MergeContext {
	var p = new(OC_MergeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Merge
	return p
}

func (*OC_MergeContext) IsOC_MergeContext() {}

func NewOC_MergeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_MergeContext {
	var p = new(OC_MergeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Merge

	return p
}

func (s *OC_MergeContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_MergeContext) MERGE() antlr.TerminalNode {
	return s.GetToken(TTQLParserMERGE, 0)
}

func (s *OC_MergeContext) OC_PatternPart() IOC_PatternPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PatternPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PatternPartContext)
}

func (s *OC_MergeContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_MergeContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_MergeContext) AllOC_MergeAction() []IOC_MergeActionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_MergeActionContext); ok {
			len++
		}
	}

	tst := make([]IOC_MergeActionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_MergeActionContext); ok {
			tst[i] = t.(IOC_MergeActionContext)
			i++
		}
	}

	return tst
}

func (s *OC_MergeContext) OC_MergeAction(i int) IOC_MergeActionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_MergeActionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_MergeActionContext)
}

func (s *OC_MergeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_MergeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_MergeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Merge(s)
	}
}

func (s *OC_MergeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Merge(s)
	}
}

func (p *TTQLParser) OC_Merge() (localctx IOC_MergeContext) {
	this := p
	_ = this

	localctx = NewOC_MergeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, TTQLParserRULE_oC_Merge)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(395)
		p.Match(TTQLParserMERGE)
	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(396)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(399)
		p.OC_PatternPart()
	}
	p.SetState(404)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(400)
				p.Match(TTQLParserSP)
			}
			{
				p.SetState(401)
				p.OC_MergeAction()
			}

		}
		p.SetState(406)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_MergeActionContext is an interface to support dynamic dispatch.
type IOC_MergeActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_MergeActionContext differentiates from other interfaces.
	IsOC_MergeActionContext()
}

type OC_MergeActionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_MergeActionContext() *OC_MergeActionContext {
	var p = new(OC_MergeActionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_MergeAction
	return p
}

func (*OC_MergeActionContext) IsOC_MergeActionContext() {}

func NewOC_MergeActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_MergeActionContext {
	var p = new(OC_MergeActionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_MergeAction

	return p
}

func (s *OC_MergeActionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_MergeActionContext) ON() antlr.TerminalNode {
	return s.GetToken(TTQLParserON, 0)
}

func (s *OC_MergeActionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_MergeActionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_MergeActionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(TTQLParserMATCH, 0)
}

func (s *OC_MergeActionContext) OC_Set() IOC_SetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SetContext)
}

func (s *OC_MergeActionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(TTQLParserCREATE, 0)
}

func (s *OC_MergeActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_MergeActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_MergeActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_MergeAction(s)
	}
}

func (s *OC_MergeActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_MergeAction(s)
	}
}

func (p *TTQLParser) OC_MergeAction() (localctx IOC_MergeActionContext) {
	this := p
	_ = this

	localctx = NewOC_MergeActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, TTQLParserRULE_oC_MergeAction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(407)
			p.Match(TTQLParserON)
		}
		{
			p.SetState(408)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(409)
			p.Match(TTQLParserMATCH)
		}
		{
			p.SetState(410)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(411)
			p.OC_Set()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(412)
			p.Match(TTQLParserON)
		}
		{
			p.SetState(413)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(414)
			p.Match(TTQLParserCREATE)
		}
		{
			p.SetState(415)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(416)
			p.OC_Set()
		}

	}

	return localctx
}

// IOC_CreateContext is an interface to support dynamic dispatch.
type IOC_CreateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_CreateContext differentiates from other interfaces.
	IsOC_CreateContext()
}

type OC_CreateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_CreateContext() *OC_CreateContext {
	var p = new(OC_CreateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Create
	return p
}

func (*OC_CreateContext) IsOC_CreateContext() {}

func NewOC_CreateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_CreateContext {
	var p = new(OC_CreateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Create

	return p
}

func (s *OC_CreateContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_CreateContext) CREATE() antlr.TerminalNode {
	return s.GetToken(TTQLParserCREATE, 0)
}

func (s *OC_CreateContext) OC_Pattern() IOC_PatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PatternContext)
}

func (s *OC_CreateContext) SP() antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, 0)
}

func (s *OC_CreateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_CreateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_CreateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Create(s)
	}
}

func (s *OC_CreateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Create(s)
	}
}

func (p *TTQLParser) OC_Create() (localctx IOC_CreateContext) {
	this := p
	_ = this

	localctx = NewOC_CreateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, TTQLParserRULE_oC_Create)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(419)
		p.Match(TTQLParserCREATE)
	}
	p.SetState(421)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(420)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(423)
		p.OC_Pattern()
	}

	return localctx
}

// IOC_SetContext is an interface to support dynamic dispatch.
type IOC_SetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SetContext differentiates from other interfaces.
	IsOC_SetContext()
}

type OC_SetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SetContext() *OC_SetContext {
	var p = new(OC_SetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Set
	return p
}

func (*OC_SetContext) IsOC_SetContext() {}

func NewOC_SetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SetContext {
	var p = new(OC_SetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Set

	return p
}

func (s *OC_SetContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SetContext) SET() antlr.TerminalNode {
	return s.GetToken(TTQLParserSET, 0)
}

func (s *OC_SetContext) AllOC_SetItem() []IOC_SetItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_SetItemContext); ok {
			len++
		}
	}

	tst := make([]IOC_SetItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_SetItemContext); ok {
			tst[i] = t.(IOC_SetItemContext)
			i++
		}
	}

	return tst
}

func (s *OC_SetContext) OC_SetItem(i int) IOC_SetItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SetItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SetItemContext)
}

func (s *OC_SetContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_SetContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_SetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_SetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Set(s)
	}
}

func (s *OC_SetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Set(s)
	}
}

func (p *TTQLParser) OC_Set() (localctx IOC_SetContext) {
	this := p
	_ = this

	localctx = NewOC_SetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, TTQLParserRULE_oC_Set)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(425)
		p.Match(TTQLParserSET)
	}
	p.SetState(427)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(426)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(429)
		p.OC_SetItem()
	}
	p.SetState(440)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(431)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(430)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(433)
				p.Match(TTQLParserT__1)
			}
			p.SetState(435)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(434)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(437)
				p.OC_SetItem()
			}

		}
		p.SetState(442)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_SetItemContext is an interface to support dynamic dispatch.
type IOC_SetItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SetItemContext differentiates from other interfaces.
	IsOC_SetItemContext()
}

type OC_SetItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SetItemContext() *OC_SetItemContext {
	var p = new(OC_SetItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_SetItem
	return p
}

func (*OC_SetItemContext) IsOC_SetItemContext() {}

func NewOC_SetItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SetItemContext {
	var p = new(OC_SetItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_SetItem

	return p
}

func (s *OC_SetItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SetItemContext) OC_PropertyExpression() IOC_PropertyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PropertyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PropertyExpressionContext)
}

func (s *OC_SetItemContext) OC_Expression() IOC_ExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_SetItemContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_SetItemContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_SetItemContext) OC_Variable() IOC_VariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_VariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_SetItemContext) OC_NodeLabels() IOC_NodeLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_NodeLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_NodeLabelsContext)
}

func (s *OC_SetItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SetItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_SetItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_SetItem(s)
	}
}

func (s *OC_SetItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_SetItem(s)
	}
}

func (p *TTQLParser) OC_SetItem() (localctx IOC_SetItemContext) {
	this := p
	_ = this

	localctx = NewOC_SetItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, TTQLParserRULE_oC_SetItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(479)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(443)
			p.OC_PropertyExpression()
		}
		p.SetState(445)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(444)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(447)
			p.Match(TTQLParserT__2)
		}
		p.SetState(449)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(448)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(451)
			p.OC_Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(453)
			p.OC_Variable()
		}
		p.SetState(455)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(454)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(457)
			p.Match(TTQLParserT__2)
		}
		p.SetState(459)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(458)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(461)
			p.OC_Expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(463)
			p.OC_Variable()
		}
		p.SetState(465)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(464)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(467)
			p.Match(TTQLParserT__3)
		}
		p.SetState(469)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(468)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(471)
			p.OC_Expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(473)
			p.OC_Variable()
		}
		p.SetState(475)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(474)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(477)
			p.OC_NodeLabels()
		}

	}

	return localctx
}

// IOC_DeleteContext is an interface to support dynamic dispatch.
type IOC_DeleteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_DeleteContext differentiates from other interfaces.
	IsOC_DeleteContext()
}

type OC_DeleteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_DeleteContext() *OC_DeleteContext {
	var p = new(OC_DeleteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Delete
	return p
}

func (*OC_DeleteContext) IsOC_DeleteContext() {}

func NewOC_DeleteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_DeleteContext {
	var p = new(OC_DeleteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Delete

	return p
}

func (s *OC_DeleteContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_DeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(TTQLParserDELETE, 0)
}

func (s *OC_DeleteContext) AllOC_Expression() []IOC_ExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_ExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_ExpressionContext); ok {
			tst[i] = t.(IOC_ExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_DeleteContext) OC_Expression(i int) IOC_ExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_DeleteContext) DETACH() antlr.TerminalNode {
	return s.GetToken(TTQLParserDETACH, 0)
}

func (s *OC_DeleteContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_DeleteContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_DeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_DeleteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_DeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Delete(s)
	}
}

func (s *OC_DeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Delete(s)
	}
}

func (p *TTQLParser) OC_Delete() (localctx IOC_DeleteContext) {
	this := p
	_ = this

	localctx = NewOC_DeleteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, TTQLParserRULE_oC_Delete)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserDETACH {
		{
			p.SetState(481)
			p.Match(TTQLParserDETACH)
		}
		{
			p.SetState(482)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(485)
		p.Match(TTQLParserDELETE)
	}
	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(486)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(489)
		p.OC_Expression()
	}
	p.SetState(500)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(491)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(490)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(493)
				p.Match(TTQLParserT__1)
			}
			p.SetState(495)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(494)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(497)
				p.OC_Expression()
			}

		}
		p.SetState(502)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_RemoveContext is an interface to support dynamic dispatch.
type IOC_RemoveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RemoveContext differentiates from other interfaces.
	IsOC_RemoveContext()
}

type OC_RemoveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RemoveContext() *OC_RemoveContext {
	var p = new(OC_RemoveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Remove
	return p
}

func (*OC_RemoveContext) IsOC_RemoveContext() {}

func NewOC_RemoveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RemoveContext {
	var p = new(OC_RemoveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Remove

	return p
}

func (s *OC_RemoveContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RemoveContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(TTQLParserREMOVE, 0)
}

func (s *OC_RemoveContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_RemoveContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_RemoveContext) AllOC_RemoveItem() []IOC_RemoveItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_RemoveItemContext); ok {
			len++
		}
	}

	tst := make([]IOC_RemoveItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_RemoveItemContext); ok {
			tst[i] = t.(IOC_RemoveItemContext)
			i++
		}
	}

	return tst
}

func (s *OC_RemoveContext) OC_RemoveItem(i int) IOC_RemoveItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_RemoveItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_RemoveItemContext)
}

func (s *OC_RemoveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RemoveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_RemoveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Remove(s)
	}
}

func (s *OC_RemoveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Remove(s)
	}
}

func (p *TTQLParser) OC_Remove() (localctx IOC_RemoveContext) {
	this := p
	_ = this

	localctx = NewOC_RemoveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, TTQLParserRULE_oC_Remove)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(503)
		p.Match(TTQLParserREMOVE)
	}
	{
		p.SetState(504)
		p.Match(TTQLParserSP)
	}
	{
		p.SetState(505)
		p.OC_RemoveItem()
	}
	p.SetState(516)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(507)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(506)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(509)
				p.Match(TTQLParserT__1)
			}
			p.SetState(511)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(510)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(513)
				p.OC_RemoveItem()
			}

		}
		p.SetState(518)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_RemoveItemContext is an interface to support dynamic dispatch.
type IOC_RemoveItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RemoveItemContext differentiates from other interfaces.
	IsOC_RemoveItemContext()
}

type OC_RemoveItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RemoveItemContext() *OC_RemoveItemContext {
	var p = new(OC_RemoveItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_RemoveItem
	return p
}

func (*OC_RemoveItemContext) IsOC_RemoveItemContext() {}

func NewOC_RemoveItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RemoveItemContext {
	var p = new(OC_RemoveItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_RemoveItem

	return p
}

func (s *OC_RemoveItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RemoveItemContext) OC_Variable() IOC_VariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_VariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_RemoveItemContext) OC_NodeLabels() IOC_NodeLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_NodeLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_NodeLabelsContext)
}

func (s *OC_RemoveItemContext) OC_PropertyExpression() IOC_PropertyExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PropertyExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PropertyExpressionContext)
}

func (s *OC_RemoveItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RemoveItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_RemoveItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_RemoveItem(s)
	}
}

func (s *OC_RemoveItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_RemoveItem(s)
	}
}

func (p *TTQLParser) OC_RemoveItem() (localctx IOC_RemoveItemContext) {
	this := p
	_ = this

	localctx = NewOC_RemoveItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, TTQLParserRULE_oC_RemoveItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(523)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(519)
			p.OC_Variable()
		}
		{
			p.SetState(520)
			p.OC_NodeLabels()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(522)
			p.OC_PropertyExpression()
		}

	}

	return localctx
}

// IOC_InQueryCallContext is an interface to support dynamic dispatch.
type IOC_InQueryCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_InQueryCallContext differentiates from other interfaces.
	IsOC_InQueryCallContext()
}

type OC_InQueryCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_InQueryCallContext() *OC_InQueryCallContext {
	var p = new(OC_InQueryCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_InQueryCall
	return p
}

func (*OC_InQueryCallContext) IsOC_InQueryCallContext() {}

func NewOC_InQueryCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_InQueryCallContext {
	var p = new(OC_InQueryCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_InQueryCall

	return p
}

func (s *OC_InQueryCallContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_InQueryCallContext) CALL() antlr.TerminalNode {
	return s.GetToken(TTQLParserCALL, 0)
}

func (s *OC_InQueryCallContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_InQueryCallContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_InQueryCallContext) OC_ExplicitProcedureInvocation() IOC_ExplicitProcedureInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExplicitProcedureInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExplicitProcedureInvocationContext)
}

func (s *OC_InQueryCallContext) YIELD() antlr.TerminalNode {
	return s.GetToken(TTQLParserYIELD, 0)
}

func (s *OC_InQueryCallContext) OC_YieldItems() IOC_YieldItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_YieldItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_YieldItemsContext)
}

func (s *OC_InQueryCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_InQueryCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_InQueryCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_InQueryCall(s)
	}
}

func (s *OC_InQueryCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_InQueryCall(s)
	}
}

func (p *TTQLParser) OC_InQueryCall() (localctx IOC_InQueryCallContext) {
	this := p
	_ = this

	localctx = NewOC_InQueryCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, TTQLParserRULE_oC_InQueryCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(525)
		p.Match(TTQLParserCALL)
	}
	{
		p.SetState(526)
		p.Match(TTQLParserSP)
	}
	{
		p.SetState(527)
		p.OC_ExplicitProcedureInvocation()
	}
	p.SetState(534)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
		p.SetState(529)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(528)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(531)
			p.Match(TTQLParserYIELD)
		}
		{
			p.SetState(532)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(533)
			p.OC_YieldItems()
		}

	}

	return localctx
}

// IOC_StandaloneCallContext is an interface to support dynamic dispatch.
type IOC_StandaloneCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_StandaloneCallContext differentiates from other interfaces.
	IsOC_StandaloneCallContext()
}

type OC_StandaloneCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_StandaloneCallContext() *OC_StandaloneCallContext {
	var p = new(OC_StandaloneCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_StandaloneCall
	return p
}

func (*OC_StandaloneCallContext) IsOC_StandaloneCallContext() {}

func NewOC_StandaloneCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_StandaloneCallContext {
	var p = new(OC_StandaloneCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_StandaloneCall

	return p
}

func (s *OC_StandaloneCallContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_StandaloneCallContext) CALL() antlr.TerminalNode {
	return s.GetToken(TTQLParserCALL, 0)
}

func (s *OC_StandaloneCallContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_StandaloneCallContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_StandaloneCallContext) OC_ExplicitProcedureInvocation() IOC_ExplicitProcedureInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExplicitProcedureInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExplicitProcedureInvocationContext)
}

func (s *OC_StandaloneCallContext) OC_ImplicitProcedureInvocation() IOC_ImplicitProcedureInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ImplicitProcedureInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ImplicitProcedureInvocationContext)
}

func (s *OC_StandaloneCallContext) YIELD() antlr.TerminalNode {
	return s.GetToken(TTQLParserYIELD, 0)
}

func (s *OC_StandaloneCallContext) OC_YieldItems() IOC_YieldItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_YieldItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_YieldItemsContext)
}

func (s *OC_StandaloneCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_StandaloneCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_StandaloneCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_StandaloneCall(s)
	}
}

func (s *OC_StandaloneCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_StandaloneCall(s)
	}
}

func (p *TTQLParser) OC_StandaloneCall() (localctx IOC_StandaloneCallContext) {
	this := p
	_ = this

	localctx = NewOC_StandaloneCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, TTQLParserRULE_oC_StandaloneCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(536)
		p.Match(TTQLParserCALL)
	}
	{
		p.SetState(537)
		p.Match(TTQLParserSP)
	}
	p.SetState(540)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(538)
			p.OC_ExplicitProcedureInvocation()
		}

	case 2:
		{
			p.SetState(539)
			p.OC_ImplicitProcedureInvocation()
		}

	}
	p.SetState(551)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
		p.SetState(543)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(542)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(545)
			p.Match(TTQLParserYIELD)
		}
		{
			p.SetState(546)
			p.Match(TTQLParserSP)
		}
		p.SetState(549)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case TTQLParserT__4:
			{
				p.SetState(547)
				p.Match(TTQLParserT__4)
			}

		case TTQLParserCOUNT, TTQLParserANY, TTQLParserNONE, TTQLParserSINGLE, TTQLParserHexLetter, TTQLParserFILTER, TTQLParserEXTRACT, TTQLParserUnescapedSymbolicName, TTQLParserEscapedSymbolicName:
			{
				p.SetState(548)
				p.OC_YieldItems()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IOC_YieldItemsContext is an interface to support dynamic dispatch.
type IOC_YieldItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_YieldItemsContext differentiates from other interfaces.
	IsOC_YieldItemsContext()
}

type OC_YieldItemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_YieldItemsContext() *OC_YieldItemsContext {
	var p = new(OC_YieldItemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_YieldItems
	return p
}

func (*OC_YieldItemsContext) IsOC_YieldItemsContext() {}

func NewOC_YieldItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_YieldItemsContext {
	var p = new(OC_YieldItemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_YieldItems

	return p
}

func (s *OC_YieldItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_YieldItemsContext) AllOC_YieldItem() []IOC_YieldItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_YieldItemContext); ok {
			len++
		}
	}

	tst := make([]IOC_YieldItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_YieldItemContext); ok {
			tst[i] = t.(IOC_YieldItemContext)
			i++
		}
	}

	return tst
}

func (s *OC_YieldItemsContext) OC_YieldItem(i int) IOC_YieldItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_YieldItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_YieldItemContext)
}

func (s *OC_YieldItemsContext) OC_Where() IOC_WhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_WhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_WhereContext)
}

func (s *OC_YieldItemsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_YieldItemsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_YieldItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_YieldItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_YieldItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_YieldItems(s)
	}
}

func (s *OC_YieldItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_YieldItems(s)
	}
}

func (p *TTQLParser) OC_YieldItems() (localctx IOC_YieldItemsContext) {
	this := p
	_ = this

	localctx = NewOC_YieldItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, TTQLParserRULE_oC_YieldItems)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		p.OC_YieldItem()
	}
	p.SetState(564)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(555)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(554)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(557)
				p.Match(TTQLParserT__1)
			}
			p.SetState(559)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(558)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(561)
				p.OC_YieldItem()
			}

		}
		p.SetState(566)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())
	}
	p.SetState(571)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(567)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(570)
			p.OC_Where()
		}

	}

	return localctx
}

// IOC_YieldItemContext is an interface to support dynamic dispatch.
type IOC_YieldItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_YieldItemContext differentiates from other interfaces.
	IsOC_YieldItemContext()
}

type OC_YieldItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_YieldItemContext() *OC_YieldItemContext {
	var p = new(OC_YieldItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_YieldItem
	return p
}

func (*OC_YieldItemContext) IsOC_YieldItemContext() {}

func NewOC_YieldItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_YieldItemContext {
	var p = new(OC_YieldItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_YieldItem

	return p
}

func (s *OC_YieldItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_YieldItemContext) OC_Variable() IOC_VariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_VariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_YieldItemContext) OC_ProcedureResultField() IOC_ProcedureResultFieldContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ProcedureResultFieldContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ProcedureResultFieldContext)
}

func (s *OC_YieldItemContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_YieldItemContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_YieldItemContext) AS() antlr.TerminalNode {
	return s.GetToken(TTQLParserAS, 0)
}

func (s *OC_YieldItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_YieldItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_YieldItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_YieldItem(s)
	}
}

func (s *OC_YieldItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_YieldItem(s)
	}
}

func (p *TTQLParser) OC_YieldItem() (localctx IOC_YieldItemContext) {
	this := p
	_ = this

	localctx = NewOC_YieldItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, TTQLParserRULE_oC_YieldItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(578)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(573)
			p.OC_ProcedureResultField()
		}
		{
			p.SetState(574)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(575)
			p.Match(TTQLParserAS)
		}
		{
			p.SetState(576)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(580)
		p.OC_Variable()
	}

	return localctx
}

// IOC_WithContext is an interface to support dynamic dispatch.
type IOC_WithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_WithContext differentiates from other interfaces.
	IsOC_WithContext()
}

type OC_WithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_WithContext() *OC_WithContext {
	var p = new(OC_WithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_With
	return p
}

func (*OC_WithContext) IsOC_WithContext() {}

func NewOC_WithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_WithContext {
	var p = new(OC_WithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_With

	return p
}

func (s *OC_WithContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_WithContext) WITH() antlr.TerminalNode {
	return s.GetToken(TTQLParserWITH, 0)
}

func (s *OC_WithContext) OC_ProjectionBody() IOC_ProjectionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ProjectionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ProjectionBodyContext)
}

func (s *OC_WithContext) OC_Where() IOC_WhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_WhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_WhereContext)
}

func (s *OC_WithContext) SP() antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, 0)
}

func (s *OC_WithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_WithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_WithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_With(s)
	}
}

func (s *OC_WithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_With(s)
	}
}

func (p *TTQLParser) OC_With() (localctx IOC_WithContext) {
	this := p
	_ = this

	localctx = NewOC_WithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, TTQLParserRULE_oC_With)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(582)
		p.Match(TTQLParserWITH)
	}
	{
		p.SetState(583)
		p.OC_ProjectionBody()
	}
	p.SetState(588)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
		p.SetState(585)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(584)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(587)
			p.OC_Where()
		}

	}

	return localctx
}

// IOC_ReturnContext is an interface to support dynamic dispatch.
type IOC_ReturnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ReturnContext differentiates from other interfaces.
	IsOC_ReturnContext()
}

type OC_ReturnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ReturnContext() *OC_ReturnContext {
	var p = new(OC_ReturnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Return
	return p
}

func (*OC_ReturnContext) IsOC_ReturnContext() {}

func NewOC_ReturnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ReturnContext {
	var p = new(OC_ReturnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Return

	return p
}

func (s *OC_ReturnContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ReturnContext) RETURN() antlr.TerminalNode {
	return s.GetToken(TTQLParserRETURN, 0)
}

func (s *OC_ReturnContext) OC_ProjectionBody() IOC_ProjectionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ProjectionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ProjectionBodyContext)
}

func (s *OC_ReturnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ReturnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ReturnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Return(s)
	}
}

func (s *OC_ReturnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Return(s)
	}
}

func (p *TTQLParser) OC_Return() (localctx IOC_ReturnContext) {
	this := p
	_ = this

	localctx = NewOC_ReturnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, TTQLParserRULE_oC_Return)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(590)
		p.Match(TTQLParserRETURN)
	}
	{
		p.SetState(591)
		p.OC_ProjectionBody()
	}

	return localctx
}

// IOC_ProjectionBodyContext is an interface to support dynamic dispatch.
type IOC_ProjectionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ProjectionBodyContext differentiates from other interfaces.
	IsOC_ProjectionBodyContext()
}

type OC_ProjectionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ProjectionBodyContext() *OC_ProjectionBodyContext {
	var p = new(OC_ProjectionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ProjectionBody
	return p
}

func (*OC_ProjectionBodyContext) IsOC_ProjectionBodyContext() {}

func NewOC_ProjectionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ProjectionBodyContext {
	var p = new(OC_ProjectionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ProjectionBody

	return p
}

func (s *OC_ProjectionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ProjectionBodyContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_ProjectionBodyContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_ProjectionBodyContext) OC_ProjectionItems() IOC_ProjectionItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ProjectionItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ProjectionItemsContext)
}

func (s *OC_ProjectionBodyContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(TTQLParserDISTINCT, 0)
}

func (s *OC_ProjectionBodyContext) OC_Order() IOC_OrderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_OrderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_OrderContext)
}

func (s *OC_ProjectionBodyContext) OC_Skip() IOC_SkipContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SkipContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SkipContext)
}

func (s *OC_ProjectionBodyContext) OC_Limit() IOC_LimitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_LimitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_LimitContext)
}

func (s *OC_ProjectionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ProjectionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ProjectionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ProjectionBody(s)
	}
}

func (s *OC_ProjectionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ProjectionBody(s)
	}
}

func (p *TTQLParser) OC_ProjectionBody() (localctx IOC_ProjectionBodyContext) {
	this := p
	_ = this

	localctx = NewOC_ProjectionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, TTQLParserRULE_oC_ProjectionBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(597)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
		p.SetState(594)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(593)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(596)
			p.Match(TTQLParserDISTINCT)
		}

	}
	{
		p.SetState(599)
		p.Match(TTQLParserSP)
	}
	{
		p.SetState(600)
		p.OC_ProjectionItems()
	}
	p.SetState(603)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(601)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(602)
			p.OC_Order()
		}

	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(605)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(606)
			p.OC_Skip()
		}

	}
	p.SetState(611)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(609)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(610)
			p.OC_Limit()
		}

	}

	return localctx
}

// IOC_ProjectionItemsContext is an interface to support dynamic dispatch.
type IOC_ProjectionItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ProjectionItemsContext differentiates from other interfaces.
	IsOC_ProjectionItemsContext()
}

type OC_ProjectionItemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ProjectionItemsContext() *OC_ProjectionItemsContext {
	var p = new(OC_ProjectionItemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ProjectionItems
	return p
}

func (*OC_ProjectionItemsContext) IsOC_ProjectionItemsContext() {}

func NewOC_ProjectionItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ProjectionItemsContext {
	var p = new(OC_ProjectionItemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ProjectionItems

	return p
}

func (s *OC_ProjectionItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ProjectionItemsContext) AllOC_ProjectionItem() []IOC_ProjectionItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_ProjectionItemContext); ok {
			len++
		}
	}

	tst := make([]IOC_ProjectionItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_ProjectionItemContext); ok {
			tst[i] = t.(IOC_ProjectionItemContext)
			i++
		}
	}

	return tst
}

func (s *OC_ProjectionItemsContext) OC_ProjectionItem(i int) IOC_ProjectionItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ProjectionItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ProjectionItemContext)
}

func (s *OC_ProjectionItemsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_ProjectionItemsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_ProjectionItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ProjectionItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ProjectionItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ProjectionItems(s)
	}
}

func (s *OC_ProjectionItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ProjectionItems(s)
	}
}

func (p *TTQLParser) OC_ProjectionItems() (localctx IOC_ProjectionItemsContext) {
	this := p
	_ = this

	localctx = NewOC_ProjectionItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, TTQLParserRULE_oC_ProjectionItems)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(641)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TTQLParserT__4:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(613)
			p.Match(TTQLParserT__4)
		}
		p.SetState(624)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(615)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(614)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(617)
					p.Match(TTQLParserT__1)
				}
				p.SetState(619)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(618)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(621)
					p.OC_ProjectionItem()
				}

			}
			p.SetState(626)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext())
		}

	case TTQLParserT__5, TTQLParserT__7, TTQLParserT__17, TTQLParserT__18, TTQLParserT__23, TTQLParserT__25, TTQLParserALL, TTQLParserNOT, TTQLParserNULL, TTQLParserCOUNT, TTQLParserCASE, TTQLParserANY, TTQLParserNONE, TTQLParserSINGLE, TTQLParserEXISTS, TTQLParserTRUE, TTQLParserFALSE, TTQLParserHexInteger, TTQLParserDecimalInteger, TTQLParserOctalInteger, TTQLParserHexLetter, TTQLParserExponentDecimalReal, TTQLParserRegularDecimalReal, TTQLParserStringLiteral, TTQLParserFILTER, TTQLParserEXTRACT, TTQLParserUnescapedSymbolicName, TTQLParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(627)
			p.OC_ProjectionItem()
		}
		p.SetState(638)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(629)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(628)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(631)
					p.Match(TTQLParserT__1)
				}
				p.SetState(633)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(632)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(635)
					p.OC_ProjectionItem()
				}

			}
			p.SetState(640)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOC_ProjectionItemContext is an interface to support dynamic dispatch.
type IOC_ProjectionItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ProjectionItemContext differentiates from other interfaces.
	IsOC_ProjectionItemContext()
}

type OC_ProjectionItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ProjectionItemContext() *OC_ProjectionItemContext {
	var p = new(OC_ProjectionItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ProjectionItem
	return p
}

func (*OC_ProjectionItemContext) IsOC_ProjectionItemContext() {}

func NewOC_ProjectionItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ProjectionItemContext {
	var p = new(OC_ProjectionItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ProjectionItem

	return p
}

func (s *OC_ProjectionItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ProjectionItemContext) OC_Expression() IOC_ExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_ProjectionItemContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_ProjectionItemContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_ProjectionItemContext) AS() antlr.TerminalNode {
	return s.GetToken(TTQLParserAS, 0)
}

func (s *OC_ProjectionItemContext) OC_Variable() IOC_VariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_VariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_ProjectionItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ProjectionItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ProjectionItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ProjectionItem(s)
	}
}

func (s *OC_ProjectionItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ProjectionItem(s)
	}
}

func (p *TTQLParser) OC_ProjectionItem() (localctx IOC_ProjectionItemContext) {
	this := p
	_ = this

	localctx = NewOC_ProjectionItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, TTQLParserRULE_oC_ProjectionItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(643)
			p.OC_Expression()
		}
		{
			p.SetState(644)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(645)
			p.Match(TTQLParserAS)
		}
		{
			p.SetState(646)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(647)
			p.OC_Variable()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(649)
			p.OC_Expression()
		}

	}

	return localctx
}

// IOC_OrderContext is an interface to support dynamic dispatch.
type IOC_OrderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_OrderContext differentiates from other interfaces.
	IsOC_OrderContext()
}

type OC_OrderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_OrderContext() *OC_OrderContext {
	var p = new(OC_OrderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Order
	return p
}

func (*OC_OrderContext) IsOC_OrderContext() {}

func NewOC_OrderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_OrderContext {
	var p = new(OC_OrderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Order

	return p
}

func (s *OC_OrderContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_OrderContext) ORDER() antlr.TerminalNode {
	return s.GetToken(TTQLParserORDER, 0)
}

func (s *OC_OrderContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_OrderContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_OrderContext) BY() antlr.TerminalNode {
	return s.GetToken(TTQLParserBY, 0)
}

func (s *OC_OrderContext) AllOC_SortItem() []IOC_SortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_SortItemContext); ok {
			len++
		}
	}

	tst := make([]IOC_SortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_SortItemContext); ok {
			tst[i] = t.(IOC_SortItemContext)
			i++
		}
	}

	return tst
}

func (s *OC_OrderContext) OC_SortItem(i int) IOC_SortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SortItemContext)
}

func (s *OC_OrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_OrderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_OrderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Order(s)
	}
}

func (s *OC_OrderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Order(s)
	}
}

func (p *TTQLParser) OC_Order() (localctx IOC_OrderContext) {
	this := p
	_ = this

	localctx = NewOC_OrderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, TTQLParserRULE_oC_Order)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(652)
		p.Match(TTQLParserORDER)
	}
	{
		p.SetState(653)
		p.Match(TTQLParserSP)
	}
	{
		p.SetState(654)
		p.Match(TTQLParserBY)
	}
	{
		p.SetState(655)
		p.Match(TTQLParserSP)
	}
	{
		p.SetState(656)
		p.OC_SortItem()
	}
	p.SetState(664)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == TTQLParserT__1 {
		{
			p.SetState(657)
			p.Match(TTQLParserT__1)
		}
		p.SetState(659)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(658)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(661)
			p.OC_SortItem()
		}

		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOC_SkipContext is an interface to support dynamic dispatch.
type IOC_SkipContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SkipContext differentiates from other interfaces.
	IsOC_SkipContext()
}

type OC_SkipContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SkipContext() *OC_SkipContext {
	var p = new(OC_SkipContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Skip
	return p
}

func (*OC_SkipContext) IsOC_SkipContext() {}

func NewOC_SkipContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SkipContext {
	var p = new(OC_SkipContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Skip

	return p
}

func (s *OC_SkipContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SkipContext) L_SKIP() antlr.TerminalNode {
	return s.GetToken(TTQLParserL_SKIP, 0)
}

func (s *OC_SkipContext) SP() antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, 0)
}

func (s *OC_SkipContext) OC_Expression() IOC_ExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_SkipContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SkipContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_SkipContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Skip(s)
	}
}

func (s *OC_SkipContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Skip(s)
	}
}

func (p *TTQLParser) OC_Skip() (localctx IOC_SkipContext) {
	this := p
	_ = this

	localctx = NewOC_SkipContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, TTQLParserRULE_oC_Skip)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(667)
		p.Match(TTQLParserL_SKIP)
	}
	{
		p.SetState(668)
		p.Match(TTQLParserSP)
	}
	{
		p.SetState(669)
		p.OC_Expression()
	}

	return localctx
}

// IOC_LimitContext is an interface to support dynamic dispatch.
type IOC_LimitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_LimitContext differentiates from other interfaces.
	IsOC_LimitContext()
}

type OC_LimitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_LimitContext() *OC_LimitContext {
	var p = new(OC_LimitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Limit
	return p
}

func (*OC_LimitContext) IsOC_LimitContext() {}

func NewOC_LimitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_LimitContext {
	var p = new(OC_LimitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Limit

	return p
}

func (s *OC_LimitContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_LimitContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(TTQLParserLIMIT, 0)
}

func (s *OC_LimitContext) SP() antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, 0)
}

func (s *OC_LimitContext) OC_Expression() IOC_ExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_LimitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_LimitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_LimitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Limit(s)
	}
}

func (s *OC_LimitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Limit(s)
	}
}

func (p *TTQLParser) OC_Limit() (localctx IOC_LimitContext) {
	this := p
	_ = this

	localctx = NewOC_LimitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, TTQLParserRULE_oC_Limit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(671)
		p.Match(TTQLParserLIMIT)
	}
	{
		p.SetState(672)
		p.Match(TTQLParserSP)
	}
	{
		p.SetState(673)
		p.OC_Expression()
	}

	return localctx
}

// IOC_SortItemContext is an interface to support dynamic dispatch.
type IOC_SortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SortItemContext differentiates from other interfaces.
	IsOC_SortItemContext()
}

type OC_SortItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SortItemContext() *OC_SortItemContext {
	var p = new(OC_SortItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_SortItem
	return p
}

func (*OC_SortItemContext) IsOC_SortItemContext() {}

func NewOC_SortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SortItemContext {
	var p = new(OC_SortItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_SortItem

	return p
}

func (s *OC_SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SortItemContext) OC_Expression() IOC_ExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_SortItemContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(TTQLParserASCENDING, 0)
}

func (s *OC_SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(TTQLParserASC, 0)
}

func (s *OC_SortItemContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(TTQLParserDESCENDING, 0)
}

func (s *OC_SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(TTQLParserDESC, 0)
}

func (s *OC_SortItemContext) SP() antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, 0)
}

func (s *OC_SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_SortItem(s)
	}
}

func (s *OC_SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_SortItem(s)
	}
}

func (p *TTQLParser) OC_SortItem() (localctx IOC_SortItemContext) {
	this := p
	_ = this

	localctx = NewOC_SortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, TTQLParserRULE_oC_SortItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(675)
		p.OC_Expression()
	}
	p.SetState(680)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
		p.SetState(677)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(676)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(679)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&15) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IOC_WhereContext is an interface to support dynamic dispatch.
type IOC_WhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_WhereContext differentiates from other interfaces.
	IsOC_WhereContext()
}

type OC_WhereContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_WhereContext() *OC_WhereContext {
	var p = new(OC_WhereContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Where
	return p
}

func (*OC_WhereContext) IsOC_WhereContext() {}

func NewOC_WhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_WhereContext {
	var p = new(OC_WhereContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Where

	return p
}

func (s *OC_WhereContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_WhereContext) WHERE() antlr.TerminalNode {
	return s.GetToken(TTQLParserWHERE, 0)
}

func (s *OC_WhereContext) SP() antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, 0)
}

func (s *OC_WhereContext) OC_Expression() IOC_ExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_WhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_WhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_WhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Where(s)
	}
}

func (s *OC_WhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Where(s)
	}
}

func (p *TTQLParser) OC_Where() (localctx IOC_WhereContext) {
	this := p
	_ = this

	localctx = NewOC_WhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, TTQLParserRULE_oC_Where)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(682)
		p.Match(TTQLParserWHERE)
	}
	{
		p.SetState(683)
		p.Match(TTQLParserSP)
	}
	{
		p.SetState(684)
		p.OC_Expression()
	}

	return localctx
}

// IOC_PatternContext is an interface to support dynamic dispatch.
type IOC_PatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PatternContext differentiates from other interfaces.
	IsOC_PatternContext()
}

type OC_PatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PatternContext() *OC_PatternContext {
	var p = new(OC_PatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Pattern
	return p
}

func (*OC_PatternContext) IsOC_PatternContext() {}

func NewOC_PatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PatternContext {
	var p = new(OC_PatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Pattern

	return p
}

func (s *OC_PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PatternContext) AllOC_PatternPart() []IOC_PatternPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_PatternPartContext); ok {
			len++
		}
	}

	tst := make([]IOC_PatternPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_PatternPartContext); ok {
			tst[i] = t.(IOC_PatternPartContext)
			i++
		}
	}

	return tst
}

func (s *OC_PatternContext) OC_PatternPart(i int) IOC_PatternPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PatternPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PatternPartContext)
}

func (s *OC_PatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_PatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Pattern(s)
	}
}

func (s *OC_PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Pattern(s)
	}
}

func (p *TTQLParser) OC_Pattern() (localctx IOC_PatternContext) {
	this := p
	_ = this

	localctx = NewOC_PatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, TTQLParserRULE_oC_Pattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.OC_PatternPart()
	}
	p.SetState(697)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(688)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(687)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(690)
				p.Match(TTQLParserT__1)
			}
			p.SetState(692)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(691)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(694)
				p.OC_PatternPart()
			}

		}
		p.SetState(699)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_PatternPartContext is an interface to support dynamic dispatch.
type IOC_PatternPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PatternPartContext differentiates from other interfaces.
	IsOC_PatternPartContext()
}

type OC_PatternPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PatternPartContext() *OC_PatternPartContext {
	var p = new(OC_PatternPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_PatternPart
	return p
}

func (*OC_PatternPartContext) IsOC_PatternPartContext() {}

func NewOC_PatternPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PatternPartContext {
	var p = new(OC_PatternPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_PatternPart

	return p
}

func (s *OC_PatternPartContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PatternPartContext) OC_Variable() IOC_VariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_VariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_PatternPartContext) OC_AnonymousPatternPart() IOC_AnonymousPatternPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_AnonymousPatternPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_AnonymousPatternPartContext)
}

func (s *OC_PatternPartContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_PatternPartContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_PatternPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PatternPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_PatternPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_PatternPart(s)
	}
}

func (s *OC_PatternPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_PatternPart(s)
	}
}

func (p *TTQLParser) OC_PatternPart() (localctx IOC_PatternPartContext) {
	this := p
	_ = this

	localctx = NewOC_PatternPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, TTQLParserRULE_oC_PatternPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(711)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TTQLParserCOUNT, TTQLParserANY, TTQLParserNONE, TTQLParserSINGLE, TTQLParserHexLetter, TTQLParserFILTER, TTQLParserEXTRACT, TTQLParserUnescapedSymbolicName, TTQLParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(700)
			p.OC_Variable()
		}
		p.SetState(702)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(701)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(704)
			p.Match(TTQLParserT__2)
		}
		p.SetState(706)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(705)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(708)
			p.OC_AnonymousPatternPart()
		}

	case TTQLParserT__5:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(710)
			p.OC_AnonymousPatternPart()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOC_AnonymousPatternPartContext is an interface to support dynamic dispatch.
type IOC_AnonymousPatternPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_AnonymousPatternPartContext differentiates from other interfaces.
	IsOC_AnonymousPatternPartContext()
}

type OC_AnonymousPatternPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_AnonymousPatternPartContext() *OC_AnonymousPatternPartContext {
	var p = new(OC_AnonymousPatternPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_AnonymousPatternPart
	return p
}

func (*OC_AnonymousPatternPartContext) IsOC_AnonymousPatternPartContext() {}

func NewOC_AnonymousPatternPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_AnonymousPatternPartContext {
	var p = new(OC_AnonymousPatternPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_AnonymousPatternPart

	return p
}

func (s *OC_AnonymousPatternPartContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_AnonymousPatternPartContext) OC_PatternElement() IOC_PatternElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PatternElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PatternElementContext)
}

func (s *OC_AnonymousPatternPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_AnonymousPatternPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_AnonymousPatternPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_AnonymousPatternPart(s)
	}
}

func (s *OC_AnonymousPatternPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_AnonymousPatternPart(s)
	}
}

func (p *TTQLParser) OC_AnonymousPatternPart() (localctx IOC_AnonymousPatternPartContext) {
	this := p
	_ = this

	localctx = NewOC_AnonymousPatternPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, TTQLParserRULE_oC_AnonymousPatternPart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(713)
		p.OC_PatternElement()
	}

	return localctx
}

// IOC_PatternElementContext is an interface to support dynamic dispatch.
type IOC_PatternElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PatternElementContext differentiates from other interfaces.
	IsOC_PatternElementContext()
}

type OC_PatternElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PatternElementContext() *OC_PatternElementContext {
	var p = new(OC_PatternElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_PatternElement
	return p
}

func (*OC_PatternElementContext) IsOC_PatternElementContext() {}

func NewOC_PatternElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PatternElementContext {
	var p = new(OC_PatternElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_PatternElement

	return p
}

func (s *OC_PatternElementContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PatternElementContext) OC_NodePattern() IOC_NodePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_NodePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_NodePatternContext)
}

func (s *OC_PatternElementContext) AllOC_PatternElementChain() []IOC_PatternElementChainContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_PatternElementChainContext); ok {
			len++
		}
	}

	tst := make([]IOC_PatternElementChainContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_PatternElementChainContext); ok {
			tst[i] = t.(IOC_PatternElementChainContext)
			i++
		}
	}

	return tst
}

func (s *OC_PatternElementContext) OC_PatternElementChain(i int) IOC_PatternElementChainContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PatternElementChainContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PatternElementChainContext)
}

func (s *OC_PatternElementContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_PatternElementContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_PatternElementContext) OC_PatternElement() IOC_PatternElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PatternElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PatternElementContext)
}

func (s *OC_PatternElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PatternElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_PatternElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_PatternElement(s)
	}
}

func (s *OC_PatternElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_PatternElement(s)
	}
}

func (p *TTQLParser) OC_PatternElement() (localctx IOC_PatternElementContext) {
	this := p
	_ = this

	localctx = NewOC_PatternElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, TTQLParserRULE_oC_PatternElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(729)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(715)
			p.OC_NodePattern()
		}
		p.SetState(722)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(717)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(716)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(719)
					p.OC_PatternElementChain()
				}

			}
			p.SetState(724)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(725)
			p.Match(TTQLParserT__5)
		}
		{
			p.SetState(726)
			p.OC_PatternElement()
		}
		{
			p.SetState(727)
			p.Match(TTQLParserT__6)
		}

	}

	return localctx
}

// IOC_RelationshipsPatternContext is an interface to support dynamic dispatch.
type IOC_RelationshipsPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RelationshipsPatternContext differentiates from other interfaces.
	IsOC_RelationshipsPatternContext()
}

type OC_RelationshipsPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RelationshipsPatternContext() *OC_RelationshipsPatternContext {
	var p = new(OC_RelationshipsPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_RelationshipsPattern
	return p
}

func (*OC_RelationshipsPatternContext) IsOC_RelationshipsPatternContext() {}

func NewOC_RelationshipsPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RelationshipsPatternContext {
	var p = new(OC_RelationshipsPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_RelationshipsPattern

	return p
}

func (s *OC_RelationshipsPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RelationshipsPatternContext) OC_NodePattern() IOC_NodePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_NodePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_NodePatternContext)
}

func (s *OC_RelationshipsPatternContext) AllOC_PatternElementChain() []IOC_PatternElementChainContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_PatternElementChainContext); ok {
			len++
		}
	}

	tst := make([]IOC_PatternElementChainContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_PatternElementChainContext); ok {
			tst[i] = t.(IOC_PatternElementChainContext)
			i++
		}
	}

	return tst
}

func (s *OC_RelationshipsPatternContext) OC_PatternElementChain(i int) IOC_PatternElementChainContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PatternElementChainContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PatternElementChainContext)
}

func (s *OC_RelationshipsPatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_RelationshipsPatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_RelationshipsPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RelationshipsPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_RelationshipsPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_RelationshipsPattern(s)
	}
}

func (s *OC_RelationshipsPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_RelationshipsPattern(s)
	}
}

func (p *TTQLParser) OC_RelationshipsPattern() (localctx IOC_RelationshipsPatternContext) {
	this := p
	_ = this

	localctx = NewOC_RelationshipsPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, TTQLParserRULE_oC_RelationshipsPattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(731)
		p.OC_NodePattern()
	}
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(733)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(732)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(735)
				p.OC_PatternElementChain()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(738)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_NodePatternContext is an interface to support dynamic dispatch.
type IOC_NodePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_NodePatternContext differentiates from other interfaces.
	IsOC_NodePatternContext()
}

type OC_NodePatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_NodePatternContext() *OC_NodePatternContext {
	var p = new(OC_NodePatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_NodePattern
	return p
}

func (*OC_NodePatternContext) IsOC_NodePatternContext() {}

func NewOC_NodePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_NodePatternContext {
	var p = new(OC_NodePatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_NodePattern

	return p
}

func (s *OC_NodePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_NodePatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_NodePatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_NodePatternContext) OC_Variable() IOC_VariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_VariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_NodePatternContext) OC_NodeLabels() IOC_NodeLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_NodeLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_NodeLabelsContext)
}

func (s *OC_NodePatternContext) OC_Properties() IOC_PropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PropertiesContext)
}

func (s *OC_NodePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_NodePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_NodePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_NodePattern(s)
	}
}

func (s *OC_NodePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_NodePattern(s)
	}
}

func (p *TTQLParser) OC_NodePattern() (localctx IOC_NodePatternContext) {
	this := p
	_ = this

	localctx = NewOC_NodePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, TTQLParserRULE_oC_NodePattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(740)
		p.Match(TTQLParserT__5)
	}
	p.SetState(742)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(741)
			p.Match(TTQLParserSP)
		}

	}
	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&2680059625921) != 0 {
		{
			p.SetState(744)
			p.OC_Variable()
		}
		p.SetState(746)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(745)
				p.Match(TTQLParserSP)
			}

		}

	}
	p.SetState(754)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserT__9 {
		{
			p.SetState(750)
			p.OC_NodeLabels()
		}
		p.SetState(752)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(751)
				p.Match(TTQLParserSP)
			}

		}

	}
	p.SetState(760)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserT__23 || _la == TTQLParserT__25 {
		{
			p.SetState(756)
			p.OC_Properties()
		}
		p.SetState(758)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(757)
				p.Match(TTQLParserSP)
			}

		}

	}
	{
		p.SetState(762)
		p.Match(TTQLParserT__6)
	}

	return localctx
}

// IOC_PatternElementChainContext is an interface to support dynamic dispatch.
type IOC_PatternElementChainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PatternElementChainContext differentiates from other interfaces.
	IsOC_PatternElementChainContext()
}

type OC_PatternElementChainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PatternElementChainContext() *OC_PatternElementChainContext {
	var p = new(OC_PatternElementChainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_PatternElementChain
	return p
}

func (*OC_PatternElementChainContext) IsOC_PatternElementChainContext() {}

func NewOC_PatternElementChainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PatternElementChainContext {
	var p = new(OC_PatternElementChainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_PatternElementChain

	return p
}

func (s *OC_PatternElementChainContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PatternElementChainContext) OC_RelationshipPattern() IOC_RelationshipPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_RelationshipPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_RelationshipPatternContext)
}

func (s *OC_PatternElementChainContext) OC_NodePattern() IOC_NodePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_NodePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_NodePatternContext)
}

func (s *OC_PatternElementChainContext) SP() antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, 0)
}

func (s *OC_PatternElementChainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PatternElementChainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_PatternElementChainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_PatternElementChain(s)
	}
}

func (s *OC_PatternElementChainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_PatternElementChain(s)
	}
}

func (p *TTQLParser) OC_PatternElementChain() (localctx IOC_PatternElementChainContext) {
	this := p
	_ = this

	localctx = NewOC_PatternElementChainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, TTQLParserRULE_oC_PatternElementChain)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(764)
		p.OC_RelationshipPattern()
	}
	p.SetState(766)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(765)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(768)
		p.OC_NodePattern()
	}

	return localctx
}

// IOC_RelationshipPatternContext is an interface to support dynamic dispatch.
type IOC_RelationshipPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RelationshipPatternContext differentiates from other interfaces.
	IsOC_RelationshipPatternContext()
}

type OC_RelationshipPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RelationshipPatternContext() *OC_RelationshipPatternContext {
	var p = new(OC_RelationshipPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_RelationshipPattern
	return p
}

func (*OC_RelationshipPatternContext) IsOC_RelationshipPatternContext() {}

func NewOC_RelationshipPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RelationshipPatternContext {
	var p = new(OC_RelationshipPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_RelationshipPattern

	return p
}

func (s *OC_RelationshipPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RelationshipPatternContext) OC_LeftArrowHead() IOC_LeftArrowHeadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_LeftArrowHeadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_LeftArrowHeadContext)
}

func (s *OC_RelationshipPatternContext) AllOC_Dash() []IOC_DashContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_DashContext); ok {
			len++
		}
	}

	tst := make([]IOC_DashContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_DashContext); ok {
			tst[i] = t.(IOC_DashContext)
			i++
		}
	}

	return tst
}

func (s *OC_RelationshipPatternContext) OC_Dash(i int) IOC_DashContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_DashContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_DashContext)
}

func (s *OC_RelationshipPatternContext) OC_RightArrowHead() IOC_RightArrowHeadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_RightArrowHeadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_RightArrowHeadContext)
}

func (s *OC_RelationshipPatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_RelationshipPatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_RelationshipPatternContext) OC_RelationshipDetail() IOC_RelationshipDetailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_RelationshipDetailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_RelationshipDetailContext)
}

func (s *OC_RelationshipPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RelationshipPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_RelationshipPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_RelationshipPattern(s)
	}
}

func (s *OC_RelationshipPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_RelationshipPattern(s)
	}
}

func (p *TTQLParser) OC_RelationshipPattern() (localctx IOC_RelationshipPatternContext) {
	this := p
	_ = this

	localctx = NewOC_RelationshipPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, TTQLParserRULE_oC_RelationshipPattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(834)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(770)
			p.OC_LeftArrowHead()
		}
		p.SetState(772)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(771)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(774)
			p.OC_Dash()
		}
		p.SetState(776)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(775)
				p.Match(TTQLParserSP)
			}

		}
		p.SetState(779)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserT__7 {
			{
				p.SetState(778)
				p.OC_RelationshipDetail()
			}

		}
		p.SetState(782)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(781)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(784)
			p.OC_Dash()
		}
		p.SetState(786)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(785)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(788)
			p.OC_RightArrowHead()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(790)
			p.OC_LeftArrowHead()
		}
		p.SetState(792)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(791)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(794)
			p.OC_Dash()
		}
		p.SetState(796)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(795)
				p.Match(TTQLParserSP)
			}

		}
		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserT__7 {
			{
				p.SetState(798)
				p.OC_RelationshipDetail()
			}

		}
		p.SetState(802)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(801)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(804)
			p.OC_Dash()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(806)
			p.OC_Dash()
		}
		p.SetState(808)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(807)
				p.Match(TTQLParserSP)
			}

		}
		p.SetState(811)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserT__7 {
			{
				p.SetState(810)
				p.OC_RelationshipDetail()
			}

		}
		p.SetState(814)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(813)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(816)
			p.OC_Dash()
		}
		p.SetState(818)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(817)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(820)
			p.OC_RightArrowHead()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(822)
			p.OC_Dash()
		}
		p.SetState(824)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(823)
				p.Match(TTQLParserSP)
			}

		}
		p.SetState(827)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserT__7 {
			{
				p.SetState(826)
				p.OC_RelationshipDetail()
			}

		}
		p.SetState(830)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(829)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(832)
			p.OC_Dash()
		}

	}

	return localctx
}

// IOC_RelationshipDetailContext is an interface to support dynamic dispatch.
type IOC_RelationshipDetailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RelationshipDetailContext differentiates from other interfaces.
	IsOC_RelationshipDetailContext()
}

type OC_RelationshipDetailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RelationshipDetailContext() *OC_RelationshipDetailContext {
	var p = new(OC_RelationshipDetailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_RelationshipDetail
	return p
}

func (*OC_RelationshipDetailContext) IsOC_RelationshipDetailContext() {}

func NewOC_RelationshipDetailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RelationshipDetailContext {
	var p = new(OC_RelationshipDetailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_RelationshipDetail

	return p
}

func (s *OC_RelationshipDetailContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RelationshipDetailContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_RelationshipDetailContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_RelationshipDetailContext) OC_Variable() IOC_VariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_VariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_RelationshipDetailContext) OC_RelationshipTypes() IOC_RelationshipTypesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_RelationshipTypesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_RelationshipTypesContext)
}

func (s *OC_RelationshipDetailContext) OC_RangeLiteral() IOC_RangeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_RangeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_RangeLiteralContext)
}

func (s *OC_RelationshipDetailContext) OC_Properties() IOC_PropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PropertiesContext)
}

func (s *OC_RelationshipDetailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RelationshipDetailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_RelationshipDetailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_RelationshipDetail(s)
	}
}

func (s *OC_RelationshipDetailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_RelationshipDetail(s)
	}
}

func (p *TTQLParser) OC_RelationshipDetail() (localctx IOC_RelationshipDetailContext) {
	this := p
	_ = this

	localctx = NewOC_RelationshipDetailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, TTQLParserRULE_oC_RelationshipDetail)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(836)
		p.Match(TTQLParserT__7)
	}
	p.SetState(838)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(837)
			p.Match(TTQLParserSP)
		}

	}
	p.SetState(844)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&2680059625921) != 0 {
		{
			p.SetState(840)
			p.OC_Variable()
		}
		p.SetState(842)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(841)
				p.Match(TTQLParserSP)
			}

		}

	}
	p.SetState(850)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserT__9 {
		{
			p.SetState(846)
			p.OC_RelationshipTypes()
		}
		p.SetState(848)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(847)
				p.Match(TTQLParserSP)
			}

		}

	}
	p.SetState(853)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserT__4 {
		{
			p.SetState(852)
			p.OC_RangeLiteral()
		}

	}
	p.SetState(859)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserT__23 || _la == TTQLParserT__25 {
		{
			p.SetState(855)
			p.OC_Properties()
		}
		p.SetState(857)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(856)
				p.Match(TTQLParserSP)
			}

		}

	}
	{
		p.SetState(861)
		p.Match(TTQLParserT__8)
	}

	return localctx
}

// IOC_PropertiesContext is an interface to support dynamic dispatch.
type IOC_PropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PropertiesContext differentiates from other interfaces.
	IsOC_PropertiesContext()
}

type OC_PropertiesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PropertiesContext() *OC_PropertiesContext {
	var p = new(OC_PropertiesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Properties
	return p
}

func (*OC_PropertiesContext) IsOC_PropertiesContext() {}

func NewOC_PropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PropertiesContext {
	var p = new(OC_PropertiesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Properties

	return p
}

func (s *OC_PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PropertiesContext) OC_MapLiteral() IOC_MapLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_MapLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_MapLiteralContext)
}

func (s *OC_PropertiesContext) OC_Parameter() IOC_ParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ParameterContext)
}

func (s *OC_PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_PropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Properties(s)
	}
}

func (s *OC_PropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Properties(s)
	}
}

func (p *TTQLParser) OC_Properties() (localctx IOC_PropertiesContext) {
	this := p
	_ = this

	localctx = NewOC_PropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, TTQLParserRULE_oC_Properties)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(865)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TTQLParserT__23:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(863)
			p.OC_MapLiteral()
		}

	case TTQLParserT__25:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(864)
			p.OC_Parameter()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOC_RelationshipTypesContext is an interface to support dynamic dispatch.
type IOC_RelationshipTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RelationshipTypesContext differentiates from other interfaces.
	IsOC_RelationshipTypesContext()
}

type OC_RelationshipTypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RelationshipTypesContext() *OC_RelationshipTypesContext {
	var p = new(OC_RelationshipTypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_RelationshipTypes
	return p
}

func (*OC_RelationshipTypesContext) IsOC_RelationshipTypesContext() {}

func NewOC_RelationshipTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RelationshipTypesContext {
	var p = new(OC_RelationshipTypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_RelationshipTypes

	return p
}

func (s *OC_RelationshipTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RelationshipTypesContext) AllOC_RelTypeName() []IOC_RelTypeNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_RelTypeNameContext); ok {
			len++
		}
	}

	tst := make([]IOC_RelTypeNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_RelTypeNameContext); ok {
			tst[i] = t.(IOC_RelTypeNameContext)
			i++
		}
	}

	return tst
}

func (s *OC_RelationshipTypesContext) OC_RelTypeName(i int) IOC_RelTypeNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_RelTypeNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_RelTypeNameContext)
}

func (s *OC_RelationshipTypesContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_RelationshipTypesContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_RelationshipTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RelationshipTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_RelationshipTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_RelationshipTypes(s)
	}
}

func (s *OC_RelationshipTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_RelationshipTypes(s)
	}
}

func (p *TTQLParser) OC_RelationshipTypes() (localctx IOC_RelationshipTypesContext) {
	this := p
	_ = this

	localctx = NewOC_RelationshipTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, TTQLParserRULE_oC_RelationshipTypes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(867)
		p.Match(TTQLParserT__9)
	}
	p.SetState(869)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(868)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(871)
		p.OC_RelTypeName()
	}
	p.SetState(885)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(873)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(872)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(875)
				p.Match(TTQLParserT__10)
			}
			p.SetState(877)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserT__9 {
				{
					p.SetState(876)
					p.Match(TTQLParserT__9)
				}

			}
			p.SetState(880)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(879)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(882)
				p.OC_RelTypeName()
			}

		}
		p.SetState(887)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_NodeLabelsContext is an interface to support dynamic dispatch.
type IOC_NodeLabelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_NodeLabelsContext differentiates from other interfaces.
	IsOC_NodeLabelsContext()
}

type OC_NodeLabelsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_NodeLabelsContext() *OC_NodeLabelsContext {
	var p = new(OC_NodeLabelsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_NodeLabels
	return p
}

func (*OC_NodeLabelsContext) IsOC_NodeLabelsContext() {}

func NewOC_NodeLabelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_NodeLabelsContext {
	var p = new(OC_NodeLabelsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_NodeLabels

	return p
}

func (s *OC_NodeLabelsContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_NodeLabelsContext) AllOC_NodeLabel() []IOC_NodeLabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_NodeLabelContext); ok {
			len++
		}
	}

	tst := make([]IOC_NodeLabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_NodeLabelContext); ok {
			tst[i] = t.(IOC_NodeLabelContext)
			i++
		}
	}

	return tst
}

func (s *OC_NodeLabelsContext) OC_NodeLabel(i int) IOC_NodeLabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_NodeLabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_NodeLabelContext)
}

func (s *OC_NodeLabelsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_NodeLabelsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_NodeLabelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_NodeLabelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_NodeLabelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_NodeLabels(s)
	}
}

func (s *OC_NodeLabelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_NodeLabels(s)
	}
}

func (p *TTQLParser) OC_NodeLabels() (localctx IOC_NodeLabelsContext) {
	this := p
	_ = this

	localctx = NewOC_NodeLabelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, TTQLParserRULE_oC_NodeLabels)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(888)
		p.OC_NodeLabel()
	}
	p.SetState(895)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(890)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(889)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(892)
				p.OC_NodeLabel()
			}

		}
		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_NodeLabelContext is an interface to support dynamic dispatch.
type IOC_NodeLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_NodeLabelContext differentiates from other interfaces.
	IsOC_NodeLabelContext()
}

type OC_NodeLabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_NodeLabelContext() *OC_NodeLabelContext {
	var p = new(OC_NodeLabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_NodeLabel
	return p
}

func (*OC_NodeLabelContext) IsOC_NodeLabelContext() {}

func NewOC_NodeLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_NodeLabelContext {
	var p = new(OC_NodeLabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_NodeLabel

	return p
}

func (s *OC_NodeLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_NodeLabelContext) OC_LabelName() IOC_LabelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_LabelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_LabelNameContext)
}

func (s *OC_NodeLabelContext) SP() antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, 0)
}

func (s *OC_NodeLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_NodeLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_NodeLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_NodeLabel(s)
	}
}

func (s *OC_NodeLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_NodeLabel(s)
	}
}

func (p *TTQLParser) OC_NodeLabel() (localctx IOC_NodeLabelContext) {
	this := p
	_ = this

	localctx = NewOC_NodeLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, TTQLParserRULE_oC_NodeLabel)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(898)
		p.Match(TTQLParserT__9)
	}
	p.SetState(900)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(899)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(902)
		p.OC_LabelName()
	}

	return localctx
}

// IOC_RangeLiteralContext is an interface to support dynamic dispatch.
type IOC_RangeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RangeLiteralContext differentiates from other interfaces.
	IsOC_RangeLiteralContext()
}

type OC_RangeLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RangeLiteralContext() *OC_RangeLiteralContext {
	var p = new(OC_RangeLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_RangeLiteral
	return p
}

func (*OC_RangeLiteralContext) IsOC_RangeLiteralContext() {}

func NewOC_RangeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RangeLiteralContext {
	var p = new(OC_RangeLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_RangeLiteral

	return p
}

func (s *OC_RangeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RangeLiteralContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_RangeLiteralContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_RangeLiteralContext) AllOC_IntegerLiteral() []IOC_IntegerLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_IntegerLiteralContext); ok {
			len++
		}
	}

	tst := make([]IOC_IntegerLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_IntegerLiteralContext); ok {
			tst[i] = t.(IOC_IntegerLiteralContext)
			i++
		}
	}

	return tst
}

func (s *OC_RangeLiteralContext) OC_IntegerLiteral(i int) IOC_IntegerLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_IntegerLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_IntegerLiteralContext)
}

func (s *OC_RangeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RangeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_RangeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_RangeLiteral(s)
	}
}

func (s *OC_RangeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_RangeLiteral(s)
	}
}

func (p *TTQLParser) OC_RangeLiteral() (localctx IOC_RangeLiteralContext) {
	this := p
	_ = this

	localctx = NewOC_RangeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, TTQLParserRULE_oC_RangeLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(904)
		p.Match(TTQLParserT__4)
	}
	p.SetState(906)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(905)
			p.Match(TTQLParserSP)
		}

	}
	p.SetState(912)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-100)) & ^0x3f) == 0 && ((int64(1)<<(_la-100))&7) != 0 {
		{
			p.SetState(908)
			p.OC_IntegerLiteral()
		}
		p.SetState(910)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(909)
				p.Match(TTQLParserSP)
			}

		}

	}
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserT__11 {
		{
			p.SetState(914)
			p.Match(TTQLParserT__11)
		}
		p.SetState(916)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(915)
				p.Match(TTQLParserSP)
			}

		}
		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-100)) & ^0x3f) == 0 && ((int64(1)<<(_la-100))&7) != 0 {
			{
				p.SetState(918)
				p.OC_IntegerLiteral()
			}
			p.SetState(920)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(919)
					p.Match(TTQLParserSP)
				}

			}

		}

	}

	return localctx
}

// IOC_LabelNameContext is an interface to support dynamic dispatch.
type IOC_LabelNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_LabelNameContext differentiates from other interfaces.
	IsOC_LabelNameContext()
}

type OC_LabelNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_LabelNameContext() *OC_LabelNameContext {
	var p = new(OC_LabelNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_LabelName
	return p
}

func (*OC_LabelNameContext) IsOC_LabelNameContext() {}

func NewOC_LabelNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_LabelNameContext {
	var p = new(OC_LabelNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_LabelName

	return p
}

func (s *OC_LabelNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_LabelNameContext) OC_SchemaName() IOC_SchemaNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SchemaNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SchemaNameContext)
}

func (s *OC_LabelNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_LabelNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_LabelNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_LabelName(s)
	}
}

func (s *OC_LabelNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_LabelName(s)
	}
}

func (p *TTQLParser) OC_LabelName() (localctx IOC_LabelNameContext) {
	this := p
	_ = this

	localctx = NewOC_LabelNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, TTQLParserRULE_oC_LabelName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(926)
		p.OC_SchemaName()
	}

	return localctx
}

// IOC_RelTypeNameContext is an interface to support dynamic dispatch.
type IOC_RelTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RelTypeNameContext differentiates from other interfaces.
	IsOC_RelTypeNameContext()
}

type OC_RelTypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RelTypeNameContext() *OC_RelTypeNameContext {
	var p = new(OC_RelTypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_RelTypeName
	return p
}

func (*OC_RelTypeNameContext) IsOC_RelTypeNameContext() {}

func NewOC_RelTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RelTypeNameContext {
	var p = new(OC_RelTypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_RelTypeName

	return p
}

func (s *OC_RelTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RelTypeNameContext) OC_SchemaName() IOC_SchemaNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SchemaNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SchemaNameContext)
}

func (s *OC_RelTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RelTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_RelTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_RelTypeName(s)
	}
}

func (s *OC_RelTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_RelTypeName(s)
	}
}

func (p *TTQLParser) OC_RelTypeName() (localctx IOC_RelTypeNameContext) {
	this := p
	_ = this

	localctx = NewOC_RelTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, TTQLParserRULE_oC_RelTypeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(928)
		p.OC_SchemaName()
	}

	return localctx
}

// IOC_PropertyExpressionContext is an interface to support dynamic dispatch.
type IOC_PropertyExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PropertyExpressionContext differentiates from other interfaces.
	IsOC_PropertyExpressionContext()
}

type OC_PropertyExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PropertyExpressionContext() *OC_PropertyExpressionContext {
	var p = new(OC_PropertyExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_PropertyExpression
	return p
}

func (*OC_PropertyExpressionContext) IsOC_PropertyExpressionContext() {}

func NewOC_PropertyExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PropertyExpressionContext {
	var p = new(OC_PropertyExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_PropertyExpression

	return p
}

func (s *OC_PropertyExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PropertyExpressionContext) OC_Atom() IOC_AtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_AtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_AtomContext)
}

func (s *OC_PropertyExpressionContext) AllOC_PropertyLookup() []IOC_PropertyLookupContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_PropertyLookupContext); ok {
			len++
		}
	}

	tst := make([]IOC_PropertyLookupContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_PropertyLookupContext); ok {
			tst[i] = t.(IOC_PropertyLookupContext)
			i++
		}
	}

	return tst
}

func (s *OC_PropertyExpressionContext) OC_PropertyLookup(i int) IOC_PropertyLookupContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PropertyLookupContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PropertyLookupContext)
}

func (s *OC_PropertyExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_PropertyExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_PropertyExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PropertyExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_PropertyExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_PropertyExpression(s)
	}
}

func (s *OC_PropertyExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_PropertyExpression(s)
	}
}

func (p *TTQLParser) OC_PropertyExpression() (localctx IOC_PropertyExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_PropertyExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, TTQLParserRULE_oC_PropertyExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(930)
		p.OC_Atom()
	}
	p.SetState(935)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(932)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(931)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(934)
				p.OC_PropertyLookup()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(937)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_ExpressionContext is an interface to support dynamic dispatch.
type IOC_ExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ExpressionContext differentiates from other interfaces.
	IsOC_ExpressionContext()
}

type OC_ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ExpressionContext() *OC_ExpressionContext {
	var p = new(OC_ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Expression
	return p
}

func (*OC_ExpressionContext) IsOC_ExpressionContext() {}

func NewOC_ExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ExpressionContext {
	var p = new(OC_ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Expression

	return p
}

func (s *OC_ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ExpressionContext) OC_OrExpression() IOC_OrExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_OrExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_OrExpressionContext)
}

func (s *OC_ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Expression(s)
	}
}

func (s *OC_ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Expression(s)
	}
}

func (p *TTQLParser) OC_Expression() (localctx IOC_ExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_ExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, TTQLParserRULE_oC_Expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(939)
		p.OC_OrExpression()
	}

	return localctx
}

// IOC_OrExpressionContext is an interface to support dynamic dispatch.
type IOC_OrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_OrExpressionContext differentiates from other interfaces.
	IsOC_OrExpressionContext()
}

type OC_OrExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_OrExpressionContext() *OC_OrExpressionContext {
	var p = new(OC_OrExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_OrExpression
	return p
}

func (*OC_OrExpressionContext) IsOC_OrExpressionContext() {}

func NewOC_OrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_OrExpressionContext {
	var p = new(OC_OrExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_OrExpression

	return p
}

func (s *OC_OrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_OrExpressionContext) AllOC_XorExpression() []IOC_XorExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_XorExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_XorExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_XorExpressionContext); ok {
			tst[i] = t.(IOC_XorExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_OrExpressionContext) OC_XorExpression(i int) IOC_XorExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_XorExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_XorExpressionContext)
}

func (s *OC_OrExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_OrExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_OrExpressionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserOR)
}

func (s *OC_OrExpressionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserOR, i)
}

func (s *OC_OrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_OrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_OrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_OrExpression(s)
	}
}

func (s *OC_OrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_OrExpression(s)
	}
}

func (p *TTQLParser) OC_OrExpression() (localctx IOC_OrExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_OrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, TTQLParserRULE_oC_OrExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(941)
		p.OC_XorExpression()
	}
	p.SetState(948)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(942)
				p.Match(TTQLParserSP)
			}
			{
				p.SetState(943)
				p.Match(TTQLParserOR)
			}
			{
				p.SetState(944)
				p.Match(TTQLParserSP)
			}
			{
				p.SetState(945)
				p.OC_XorExpression()
			}

		}
		p.SetState(950)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_XorExpressionContext is an interface to support dynamic dispatch.
type IOC_XorExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_XorExpressionContext differentiates from other interfaces.
	IsOC_XorExpressionContext()
}

type OC_XorExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_XorExpressionContext() *OC_XorExpressionContext {
	var p = new(OC_XorExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_XorExpression
	return p
}

func (*OC_XorExpressionContext) IsOC_XorExpressionContext() {}

func NewOC_XorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_XorExpressionContext {
	var p = new(OC_XorExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_XorExpression

	return p
}

func (s *OC_XorExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_XorExpressionContext) AllOC_AndExpression() []IOC_AndExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_AndExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_AndExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_AndExpressionContext); ok {
			tst[i] = t.(IOC_AndExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_XorExpressionContext) OC_AndExpression(i int) IOC_AndExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_AndExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_AndExpressionContext)
}

func (s *OC_XorExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_XorExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_XorExpressionContext) AllXOR() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserXOR)
}

func (s *OC_XorExpressionContext) XOR(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserXOR, i)
}

func (s *OC_XorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_XorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_XorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_XorExpression(s)
	}
}

func (s *OC_XorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_XorExpression(s)
	}
}

func (p *TTQLParser) OC_XorExpression() (localctx IOC_XorExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_XorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, TTQLParserRULE_oC_XorExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(951)
		p.OC_AndExpression()
	}
	p.SetState(958)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(952)
				p.Match(TTQLParserSP)
			}
			{
				p.SetState(953)
				p.Match(TTQLParserXOR)
			}
			{
				p.SetState(954)
				p.Match(TTQLParserSP)
			}
			{
				p.SetState(955)
				p.OC_AndExpression()
			}

		}
		p.SetState(960)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_AndExpressionContext is an interface to support dynamic dispatch.
type IOC_AndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_AndExpressionContext differentiates from other interfaces.
	IsOC_AndExpressionContext()
}

type OC_AndExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_AndExpressionContext() *OC_AndExpressionContext {
	var p = new(OC_AndExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_AndExpression
	return p
}

func (*OC_AndExpressionContext) IsOC_AndExpressionContext() {}

func NewOC_AndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_AndExpressionContext {
	var p = new(OC_AndExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_AndExpression

	return p
}

func (s *OC_AndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_AndExpressionContext) AllOC_NotExpression() []IOC_NotExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_NotExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_NotExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_NotExpressionContext); ok {
			tst[i] = t.(IOC_NotExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_AndExpressionContext) OC_NotExpression(i int) IOC_NotExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_NotExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_NotExpressionContext)
}

func (s *OC_AndExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_AndExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_AndExpressionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserAND)
}

func (s *OC_AndExpressionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserAND, i)
}

func (s *OC_AndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_AndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_AndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_AndExpression(s)
	}
}

func (s *OC_AndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_AndExpression(s)
	}
}

func (p *TTQLParser) OC_AndExpression() (localctx IOC_AndExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_AndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, TTQLParserRULE_oC_AndExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(961)
		p.OC_NotExpression()
	}
	p.SetState(968)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(962)
				p.Match(TTQLParserSP)
			}
			{
				p.SetState(963)
				p.Match(TTQLParserAND)
			}
			{
				p.SetState(964)
				p.Match(TTQLParserSP)
			}
			{
				p.SetState(965)
				p.OC_NotExpression()
			}

		}
		p.SetState(970)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_NotExpressionContext is an interface to support dynamic dispatch.
type IOC_NotExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_NotExpressionContext differentiates from other interfaces.
	IsOC_NotExpressionContext()
}

type OC_NotExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_NotExpressionContext() *OC_NotExpressionContext {
	var p = new(OC_NotExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_NotExpression
	return p
}

func (*OC_NotExpressionContext) IsOC_NotExpressionContext() {}

func NewOC_NotExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_NotExpressionContext {
	var p = new(OC_NotExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_NotExpression

	return p
}

func (s *OC_NotExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_NotExpressionContext) OC_ComparisonExpression() IOC_ComparisonExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ComparisonExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ComparisonExpressionContext)
}

func (s *OC_NotExpressionContext) AllNOT() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserNOT)
}

func (s *OC_NotExpressionContext) NOT(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserNOT, i)
}

func (s *OC_NotExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_NotExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_NotExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_NotExpression(s)
	}
}

func (s *OC_NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_NotExpression(s)
	}
}

func (p *TTQLParser) OC_NotExpression() (localctx IOC_NotExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_NotExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, TTQLParserRULE_oC_NotExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(977)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == TTQLParserNOT {
		{
			p.SetState(971)
			p.Match(TTQLParserNOT)
		}
		p.SetState(973)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(972)
				p.Match(TTQLParserSP)
			}

		}

		p.SetState(979)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(980)
		p.OC_ComparisonExpression()
	}

	return localctx
}

// IOC_ComparisonExpressionContext is an interface to support dynamic dispatch.
type IOC_ComparisonExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ComparisonExpressionContext differentiates from other interfaces.
	IsOC_ComparisonExpressionContext()
}

type OC_ComparisonExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ComparisonExpressionContext() *OC_ComparisonExpressionContext {
	var p = new(OC_ComparisonExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ComparisonExpression
	return p
}

func (*OC_ComparisonExpressionContext) IsOC_ComparisonExpressionContext() {}

func NewOC_ComparisonExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ComparisonExpressionContext {
	var p = new(OC_ComparisonExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ComparisonExpression

	return p
}

func (s *OC_ComparisonExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ComparisonExpressionContext) OC_StringListNullPredicateExpression() IOC_StringListNullPredicateExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_StringListNullPredicateExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_StringListNullPredicateExpressionContext)
}

func (s *OC_ComparisonExpressionContext) AllOC_PartialComparisonExpression() []IOC_PartialComparisonExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_PartialComparisonExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_PartialComparisonExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_PartialComparisonExpressionContext); ok {
			tst[i] = t.(IOC_PartialComparisonExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_ComparisonExpressionContext) OC_PartialComparisonExpression(i int) IOC_PartialComparisonExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PartialComparisonExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PartialComparisonExpressionContext)
}

func (s *OC_ComparisonExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_ComparisonExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_ComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ComparisonExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ComparisonExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ComparisonExpression(s)
	}
}

func (s *OC_ComparisonExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ComparisonExpression(s)
	}
}

func (p *TTQLParser) OC_ComparisonExpression() (localctx IOC_ComparisonExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_ComparisonExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, TTQLParserRULE_oC_ComparisonExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(982)
		p.OC_StringListNullPredicateExpression()
	}
	p.SetState(989)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(984)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(983)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(986)
				p.OC_PartialComparisonExpression()
			}

		}
		p.SetState(991)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_PartialComparisonExpressionContext is an interface to support dynamic dispatch.
type IOC_PartialComparisonExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PartialComparisonExpressionContext differentiates from other interfaces.
	IsOC_PartialComparisonExpressionContext()
}

type OC_PartialComparisonExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PartialComparisonExpressionContext() *OC_PartialComparisonExpressionContext {
	var p = new(OC_PartialComparisonExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_PartialComparisonExpression
	return p
}

func (*OC_PartialComparisonExpressionContext) IsOC_PartialComparisonExpressionContext() {}

func NewOC_PartialComparisonExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PartialComparisonExpressionContext {
	var p = new(OC_PartialComparisonExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_PartialComparisonExpression

	return p
}

func (s *OC_PartialComparisonExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PartialComparisonExpressionContext) OC_StringListNullPredicateExpression() IOC_StringListNullPredicateExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_StringListNullPredicateExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_StringListNullPredicateExpressionContext)
}

func (s *OC_PartialComparisonExpressionContext) SP() antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, 0)
}

func (s *OC_PartialComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PartialComparisonExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_PartialComparisonExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_PartialComparisonExpression(s)
	}
}

func (s *OC_PartialComparisonExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_PartialComparisonExpression(s)
	}
}

func (p *TTQLParser) OC_PartialComparisonExpression() (localctx IOC_PartialComparisonExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_PartialComparisonExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, TTQLParserRULE_oC_PartialComparisonExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1022)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TTQLParserT__2:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(992)
			p.Match(TTQLParserT__2)
		}
		p.SetState(994)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(993)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(996)
			p.OC_StringListNullPredicateExpression()
		}

	case TTQLParserT__12:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(997)
			p.Match(TTQLParserT__12)
		}
		p.SetState(999)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(998)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1001)
			p.OC_StringListNullPredicateExpression()
		}

	case TTQLParserT__13:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1002)
			p.Match(TTQLParserT__13)
		}
		p.SetState(1004)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1003)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1006)
			p.OC_StringListNullPredicateExpression()
		}

	case TTQLParserT__14:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1007)
			p.Match(TTQLParserT__14)
		}
		p.SetState(1009)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1008)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1011)
			p.OC_StringListNullPredicateExpression()
		}

	case TTQLParserT__15:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1012)
			p.Match(TTQLParserT__15)
		}
		p.SetState(1014)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1013)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1016)
			p.OC_StringListNullPredicateExpression()
		}

	case TTQLParserT__16:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1017)
			p.Match(TTQLParserT__16)
		}
		p.SetState(1019)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1018)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1021)
			p.OC_StringListNullPredicateExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOC_StringListNullPredicateExpressionContext is an interface to support dynamic dispatch.
type IOC_StringListNullPredicateExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_StringListNullPredicateExpressionContext differentiates from other interfaces.
	IsOC_StringListNullPredicateExpressionContext()
}

type OC_StringListNullPredicateExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_StringListNullPredicateExpressionContext() *OC_StringListNullPredicateExpressionContext {
	var p = new(OC_StringListNullPredicateExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_StringListNullPredicateExpression
	return p
}

func (*OC_StringListNullPredicateExpressionContext) IsOC_StringListNullPredicateExpressionContext() {}

func NewOC_StringListNullPredicateExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_StringListNullPredicateExpressionContext {
	var p = new(OC_StringListNullPredicateExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_StringListNullPredicateExpression

	return p
}

func (s *OC_StringListNullPredicateExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_StringListNullPredicateExpressionContext) OC_AddOrSubtractExpression() IOC_AddOrSubtractExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_AddOrSubtractExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_AddOrSubtractExpressionContext)
}

func (s *OC_StringListNullPredicateExpressionContext) AllOC_StringPredicateExpression() []IOC_StringPredicateExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_StringPredicateExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_StringPredicateExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_StringPredicateExpressionContext); ok {
			tst[i] = t.(IOC_StringPredicateExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_StringListNullPredicateExpressionContext) OC_StringPredicateExpression(i int) IOC_StringPredicateExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_StringPredicateExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_StringPredicateExpressionContext)
}

func (s *OC_StringListNullPredicateExpressionContext) AllOC_ListPredicateExpression() []IOC_ListPredicateExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_ListPredicateExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_ListPredicateExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_ListPredicateExpressionContext); ok {
			tst[i] = t.(IOC_ListPredicateExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_StringListNullPredicateExpressionContext) OC_ListPredicateExpression(i int) IOC_ListPredicateExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ListPredicateExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ListPredicateExpressionContext)
}

func (s *OC_StringListNullPredicateExpressionContext) AllOC_NullPredicateExpression() []IOC_NullPredicateExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_NullPredicateExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_NullPredicateExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_NullPredicateExpressionContext); ok {
			tst[i] = t.(IOC_NullPredicateExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_StringListNullPredicateExpressionContext) OC_NullPredicateExpression(i int) IOC_NullPredicateExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_NullPredicateExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_NullPredicateExpressionContext)
}

func (s *OC_StringListNullPredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_StringListNullPredicateExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_StringListNullPredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_StringListNullPredicateExpression(s)
	}
}

func (s *OC_StringListNullPredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_StringListNullPredicateExpression(s)
	}
}

func (p *TTQLParser) OC_StringListNullPredicateExpression() (localctx IOC_StringListNullPredicateExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_StringListNullPredicateExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, TTQLParserRULE_oC_StringListNullPredicateExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1024)
		p.OC_AddOrSubtractExpression()
	}
	p.SetState(1030)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1028)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1025)
					p.OC_StringPredicateExpression()
				}

			case 2:
				{
					p.SetState(1026)
					p.OC_ListPredicateExpression()
				}

			case 3:
				{
					p.SetState(1027)
					p.OC_NullPredicateExpression()
				}

			}

		}
		p.SetState(1032)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_StringPredicateExpressionContext is an interface to support dynamic dispatch.
type IOC_StringPredicateExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_StringPredicateExpressionContext differentiates from other interfaces.
	IsOC_StringPredicateExpressionContext()
}

type OC_StringPredicateExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_StringPredicateExpressionContext() *OC_StringPredicateExpressionContext {
	var p = new(OC_StringPredicateExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_StringPredicateExpression
	return p
}

func (*OC_StringPredicateExpressionContext) IsOC_StringPredicateExpressionContext() {}

func NewOC_StringPredicateExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_StringPredicateExpressionContext {
	var p = new(OC_StringPredicateExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_StringPredicateExpression

	return p
}

func (s *OC_StringPredicateExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_StringPredicateExpressionContext) OC_AddOrSubtractExpression() IOC_AddOrSubtractExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_AddOrSubtractExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_AddOrSubtractExpressionContext)
}

func (s *OC_StringPredicateExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_StringPredicateExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_StringPredicateExpressionContext) STARTS() antlr.TerminalNode {
	return s.GetToken(TTQLParserSTARTS, 0)
}

func (s *OC_StringPredicateExpressionContext) WITH() antlr.TerminalNode {
	return s.GetToken(TTQLParserWITH, 0)
}

func (s *OC_StringPredicateExpressionContext) ENDS() antlr.TerminalNode {
	return s.GetToken(TTQLParserENDS, 0)
}

func (s *OC_StringPredicateExpressionContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(TTQLParserCONTAINS, 0)
}

func (s *OC_StringPredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_StringPredicateExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_StringPredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_StringPredicateExpression(s)
	}
}

func (s *OC_StringPredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_StringPredicateExpression(s)
	}
}

func (p *TTQLParser) OC_StringPredicateExpression() (localctx IOC_StringPredicateExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_StringPredicateExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, TTQLParserRULE_oC_StringPredicateExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1043)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1033)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(1034)
			p.Match(TTQLParserSTARTS)
		}
		{
			p.SetState(1035)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(1036)
			p.Match(TTQLParserWITH)
		}

	case 2:
		{
			p.SetState(1037)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(1038)
			p.Match(TTQLParserENDS)
		}
		{
			p.SetState(1039)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(1040)
			p.Match(TTQLParserWITH)
		}

	case 3:
		{
			p.SetState(1041)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(1042)
			p.Match(TTQLParserCONTAINS)
		}

	}
	p.SetState(1046)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1045)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1048)
		p.OC_AddOrSubtractExpression()
	}

	return localctx
}

// IOC_ListPredicateExpressionContext is an interface to support dynamic dispatch.
type IOC_ListPredicateExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ListPredicateExpressionContext differentiates from other interfaces.
	IsOC_ListPredicateExpressionContext()
}

type OC_ListPredicateExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ListPredicateExpressionContext() *OC_ListPredicateExpressionContext {
	var p = new(OC_ListPredicateExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ListPredicateExpression
	return p
}

func (*OC_ListPredicateExpressionContext) IsOC_ListPredicateExpressionContext() {}

func NewOC_ListPredicateExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ListPredicateExpressionContext {
	var p = new(OC_ListPredicateExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ListPredicateExpression

	return p
}

func (s *OC_ListPredicateExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ListPredicateExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_ListPredicateExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_ListPredicateExpressionContext) IN() antlr.TerminalNode {
	return s.GetToken(TTQLParserIN, 0)
}

func (s *OC_ListPredicateExpressionContext) OC_AddOrSubtractExpression() IOC_AddOrSubtractExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_AddOrSubtractExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_AddOrSubtractExpressionContext)
}

func (s *OC_ListPredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ListPredicateExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ListPredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ListPredicateExpression(s)
	}
}

func (s *OC_ListPredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ListPredicateExpression(s)
	}
}

func (p *TTQLParser) OC_ListPredicateExpression() (localctx IOC_ListPredicateExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_ListPredicateExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, TTQLParserRULE_oC_ListPredicateExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1050)
		p.Match(TTQLParserSP)
	}
	{
		p.SetState(1051)
		p.Match(TTQLParserIN)
	}
	p.SetState(1053)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1052)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1055)
		p.OC_AddOrSubtractExpression()
	}

	return localctx
}

// IOC_NullPredicateExpressionContext is an interface to support dynamic dispatch.
type IOC_NullPredicateExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_NullPredicateExpressionContext differentiates from other interfaces.
	IsOC_NullPredicateExpressionContext()
}

type OC_NullPredicateExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_NullPredicateExpressionContext() *OC_NullPredicateExpressionContext {
	var p = new(OC_NullPredicateExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_NullPredicateExpression
	return p
}

func (*OC_NullPredicateExpressionContext) IsOC_NullPredicateExpressionContext() {}

func NewOC_NullPredicateExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_NullPredicateExpressionContext {
	var p = new(OC_NullPredicateExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_NullPredicateExpression

	return p
}

func (s *OC_NullPredicateExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_NullPredicateExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_NullPredicateExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_NullPredicateExpressionContext) IS() antlr.TerminalNode {
	return s.GetToken(TTQLParserIS, 0)
}

func (s *OC_NullPredicateExpressionContext) NULL() antlr.TerminalNode {
	return s.GetToken(TTQLParserNULL, 0)
}

func (s *OC_NullPredicateExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(TTQLParserNOT, 0)
}

func (s *OC_NullPredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_NullPredicateExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_NullPredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_NullPredicateExpression(s)
	}
}

func (s *OC_NullPredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_NullPredicateExpression(s)
	}
}

func (p *TTQLParser) OC_NullPredicateExpression() (localctx IOC_NullPredicateExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_NullPredicateExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, TTQLParserRULE_oC_NullPredicateExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1067)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1057)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(1058)
			p.Match(TTQLParserIS)
		}
		{
			p.SetState(1059)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(1060)
			p.Match(TTQLParserNULL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1061)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(1062)
			p.Match(TTQLParserIS)
		}
		{
			p.SetState(1063)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(1064)
			p.Match(TTQLParserNOT)
		}
		{
			p.SetState(1065)
			p.Match(TTQLParserSP)
		}
		{
			p.SetState(1066)
			p.Match(TTQLParserNULL)
		}

	}

	return localctx
}

// IOC_AddOrSubtractExpressionContext is an interface to support dynamic dispatch.
type IOC_AddOrSubtractExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_AddOrSubtractExpressionContext differentiates from other interfaces.
	IsOC_AddOrSubtractExpressionContext()
}

type OC_AddOrSubtractExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_AddOrSubtractExpressionContext() *OC_AddOrSubtractExpressionContext {
	var p = new(OC_AddOrSubtractExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_AddOrSubtractExpression
	return p
}

func (*OC_AddOrSubtractExpressionContext) IsOC_AddOrSubtractExpressionContext() {}

func NewOC_AddOrSubtractExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_AddOrSubtractExpressionContext {
	var p = new(OC_AddOrSubtractExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_AddOrSubtractExpression

	return p
}

func (s *OC_AddOrSubtractExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_AddOrSubtractExpressionContext) AllOC_MultiplyDivideModuloExpression() []IOC_MultiplyDivideModuloExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_MultiplyDivideModuloExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_MultiplyDivideModuloExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_MultiplyDivideModuloExpressionContext); ok {
			tst[i] = t.(IOC_MultiplyDivideModuloExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_AddOrSubtractExpressionContext) OC_MultiplyDivideModuloExpression(i int) IOC_MultiplyDivideModuloExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_MultiplyDivideModuloExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_MultiplyDivideModuloExpressionContext)
}

func (s *OC_AddOrSubtractExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_AddOrSubtractExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_AddOrSubtractExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_AddOrSubtractExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_AddOrSubtractExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_AddOrSubtractExpression(s)
	}
}

func (s *OC_AddOrSubtractExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_AddOrSubtractExpression(s)
	}
}

func (p *TTQLParser) OC_AddOrSubtractExpression() (localctx IOC_AddOrSubtractExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_AddOrSubtractExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, TTQLParserRULE_oC_AddOrSubtractExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1069)
		p.OC_MultiplyDivideModuloExpression()
	}
	p.SetState(1088)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1086)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 181, p.GetParserRuleContext()) {
			case 1:
				p.SetState(1071)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(1070)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(1073)
					p.Match(TTQLParserT__17)
				}
				p.SetState(1075)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(1074)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(1077)
					p.OC_MultiplyDivideModuloExpression()
				}

			case 2:
				p.SetState(1079)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(1078)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(1081)
					p.Match(TTQLParserT__18)
				}
				p.SetState(1083)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(1082)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(1085)
					p.OC_MultiplyDivideModuloExpression()
				}

			}

		}
		p.SetState(1090)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_MultiplyDivideModuloExpressionContext is an interface to support dynamic dispatch.
type IOC_MultiplyDivideModuloExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_MultiplyDivideModuloExpressionContext differentiates from other interfaces.
	IsOC_MultiplyDivideModuloExpressionContext()
}

type OC_MultiplyDivideModuloExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_MultiplyDivideModuloExpressionContext() *OC_MultiplyDivideModuloExpressionContext {
	var p = new(OC_MultiplyDivideModuloExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_MultiplyDivideModuloExpression
	return p
}

func (*OC_MultiplyDivideModuloExpressionContext) IsOC_MultiplyDivideModuloExpressionContext() {}

func NewOC_MultiplyDivideModuloExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_MultiplyDivideModuloExpressionContext {
	var p = new(OC_MultiplyDivideModuloExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_MultiplyDivideModuloExpression

	return p
}

func (s *OC_MultiplyDivideModuloExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_MultiplyDivideModuloExpressionContext) AllOC_PowerOfExpression() []IOC_PowerOfExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_PowerOfExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_PowerOfExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_PowerOfExpressionContext); ok {
			tst[i] = t.(IOC_PowerOfExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_MultiplyDivideModuloExpressionContext) OC_PowerOfExpression(i int) IOC_PowerOfExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PowerOfExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PowerOfExpressionContext)
}

func (s *OC_MultiplyDivideModuloExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_MultiplyDivideModuloExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_MultiplyDivideModuloExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_MultiplyDivideModuloExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_MultiplyDivideModuloExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_MultiplyDivideModuloExpression(s)
	}
}

func (s *OC_MultiplyDivideModuloExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_MultiplyDivideModuloExpression(s)
	}
}

func (p *TTQLParser) OC_MultiplyDivideModuloExpression() (localctx IOC_MultiplyDivideModuloExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_MultiplyDivideModuloExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, TTQLParserRULE_oC_MultiplyDivideModuloExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1091)
		p.OC_PowerOfExpression()
	}
	p.SetState(1118)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 190, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1116)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 189, p.GetParserRuleContext()) {
			case 1:
				p.SetState(1093)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(1092)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(1095)
					p.Match(TTQLParserT__4)
				}
				p.SetState(1097)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(1096)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(1099)
					p.OC_PowerOfExpression()
				}

			case 2:
				p.SetState(1101)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(1100)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(1103)
					p.Match(TTQLParserT__19)
				}
				p.SetState(1105)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(1104)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(1107)
					p.OC_PowerOfExpression()
				}

			case 3:
				p.SetState(1109)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(1108)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(1111)
					p.Match(TTQLParserT__20)
				}
				p.SetState(1113)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(1112)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(1115)
					p.OC_PowerOfExpression()
				}

			}

		}
		p.SetState(1120)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 190, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_PowerOfExpressionContext is an interface to support dynamic dispatch.
type IOC_PowerOfExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PowerOfExpressionContext differentiates from other interfaces.
	IsOC_PowerOfExpressionContext()
}

type OC_PowerOfExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PowerOfExpressionContext() *OC_PowerOfExpressionContext {
	var p = new(OC_PowerOfExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_PowerOfExpression
	return p
}

func (*OC_PowerOfExpressionContext) IsOC_PowerOfExpressionContext() {}

func NewOC_PowerOfExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PowerOfExpressionContext {
	var p = new(OC_PowerOfExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_PowerOfExpression

	return p
}

func (s *OC_PowerOfExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PowerOfExpressionContext) AllOC_UnaryAddOrSubtractExpression() []IOC_UnaryAddOrSubtractExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_UnaryAddOrSubtractExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_UnaryAddOrSubtractExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_UnaryAddOrSubtractExpressionContext); ok {
			tst[i] = t.(IOC_UnaryAddOrSubtractExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_PowerOfExpressionContext) OC_UnaryAddOrSubtractExpression(i int) IOC_UnaryAddOrSubtractExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_UnaryAddOrSubtractExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_UnaryAddOrSubtractExpressionContext)
}

func (s *OC_PowerOfExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_PowerOfExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_PowerOfExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PowerOfExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_PowerOfExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_PowerOfExpression(s)
	}
}

func (s *OC_PowerOfExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_PowerOfExpression(s)
	}
}

func (p *TTQLParser) OC_PowerOfExpression() (localctx IOC_PowerOfExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_PowerOfExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, TTQLParserRULE_oC_PowerOfExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1121)
		p.OC_UnaryAddOrSubtractExpression()
	}
	p.SetState(1132)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1123)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(1122)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(1125)
				p.Match(TTQLParserT__21)
			}
			p.SetState(1127)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(1126)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(1129)
				p.OC_UnaryAddOrSubtractExpression()
			}

		}
		p.SetState(1134)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_UnaryAddOrSubtractExpressionContext is an interface to support dynamic dispatch.
type IOC_UnaryAddOrSubtractExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_UnaryAddOrSubtractExpressionContext differentiates from other interfaces.
	IsOC_UnaryAddOrSubtractExpressionContext()
}

type OC_UnaryAddOrSubtractExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_UnaryAddOrSubtractExpressionContext() *OC_UnaryAddOrSubtractExpressionContext {
	var p = new(OC_UnaryAddOrSubtractExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_UnaryAddOrSubtractExpression
	return p
}

func (*OC_UnaryAddOrSubtractExpressionContext) IsOC_UnaryAddOrSubtractExpressionContext() {}

func NewOC_UnaryAddOrSubtractExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_UnaryAddOrSubtractExpressionContext {
	var p = new(OC_UnaryAddOrSubtractExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_UnaryAddOrSubtractExpression

	return p
}

func (s *OC_UnaryAddOrSubtractExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_UnaryAddOrSubtractExpressionContext) OC_ListOperatorExpression() IOC_ListOperatorExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ListOperatorExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ListOperatorExpressionContext)
}

func (s *OC_UnaryAddOrSubtractExpressionContext) SP() antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, 0)
}

func (s *OC_UnaryAddOrSubtractExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_UnaryAddOrSubtractExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_UnaryAddOrSubtractExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_UnaryAddOrSubtractExpression(s)
	}
}

func (s *OC_UnaryAddOrSubtractExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_UnaryAddOrSubtractExpression(s)
	}
}

func (p *TTQLParser) OC_UnaryAddOrSubtractExpression() (localctx IOC_UnaryAddOrSubtractExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_UnaryAddOrSubtractExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, TTQLParserRULE_oC_UnaryAddOrSubtractExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1141)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TTQLParserT__5, TTQLParserT__7, TTQLParserT__23, TTQLParserT__25, TTQLParserALL, TTQLParserNULL, TTQLParserCOUNT, TTQLParserCASE, TTQLParserANY, TTQLParserNONE, TTQLParserSINGLE, TTQLParserEXISTS, TTQLParserTRUE, TTQLParserFALSE, TTQLParserHexInteger, TTQLParserDecimalInteger, TTQLParserOctalInteger, TTQLParserHexLetter, TTQLParserExponentDecimalReal, TTQLParserRegularDecimalReal, TTQLParserStringLiteral, TTQLParserFILTER, TTQLParserEXTRACT, TTQLParserUnescapedSymbolicName, TTQLParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1135)
			p.OC_ListOperatorExpression()
		}

	case TTQLParserT__17, TTQLParserT__18:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1136)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TTQLParserT__17 || _la == TTQLParserT__18) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1138)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1137)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1140)
			p.OC_ListOperatorExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOC_ListOperatorExpressionContext is an interface to support dynamic dispatch.
type IOC_ListOperatorExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ListOperatorExpressionContext differentiates from other interfaces.
	IsOC_ListOperatorExpressionContext()
}

type OC_ListOperatorExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ListOperatorExpressionContext() *OC_ListOperatorExpressionContext {
	var p = new(OC_ListOperatorExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ListOperatorExpression
	return p
}

func (*OC_ListOperatorExpressionContext) IsOC_ListOperatorExpressionContext() {}

func NewOC_ListOperatorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ListOperatorExpressionContext {
	var p = new(OC_ListOperatorExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ListOperatorExpression

	return p
}

func (s *OC_ListOperatorExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ListOperatorExpressionContext) OC_PropertyOrLabelsExpression() IOC_PropertyOrLabelsExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PropertyOrLabelsExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PropertyOrLabelsExpressionContext)
}

func (s *OC_ListOperatorExpressionContext) AllOC_Expression() []IOC_ExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_ExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_ExpressionContext); ok {
			tst[i] = t.(IOC_ExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_ListOperatorExpressionContext) OC_Expression(i int) IOC_ExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_ListOperatorExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_ListOperatorExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_ListOperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ListOperatorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ListOperatorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ListOperatorExpression(s)
	}
}

func (s *OC_ListOperatorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ListOperatorExpression(s)
	}
}

func (p *TTQLParser) OC_ListOperatorExpression() (localctx IOC_ListOperatorExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_ListOperatorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, TTQLParserRULE_oC_ListOperatorExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1143)
		p.OC_PropertyOrLabelsExpression()
	}
	p.SetState(1165)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1163)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 200, p.GetParserRuleContext()) {
			case 1:
				p.SetState(1145)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(1144)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(1147)
					p.Match(TTQLParserT__7)
				}
				{
					p.SetState(1148)
					p.OC_Expression()
				}
				{
					p.SetState(1149)
					p.Match(TTQLParserT__8)
				}

			case 2:
				p.SetState(1152)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(1151)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(1154)
					p.Match(TTQLParserT__7)
				}
				p.SetState(1156)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4503599712043328) != 0 || (int64((_la-81)) & ^0x3f) == 0 && ((int64(1)<<(_la-81))&343051394343361) != 0 {
					{
						p.SetState(1155)
						p.OC_Expression()
					}

				}
				{
					p.SetState(1158)
					p.Match(TTQLParserT__11)
				}
				p.SetState(1160)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4503599712043328) != 0 || (int64((_la-81)) & ^0x3f) == 0 && ((int64(1)<<(_la-81))&343051394343361) != 0 {
					{
						p.SetState(1159)
						p.OC_Expression()
					}

				}
				{
					p.SetState(1162)
					p.Match(TTQLParserT__8)
				}

			}

		}
		p.SetState(1167)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_PropertyOrLabelsExpressionContext is an interface to support dynamic dispatch.
type IOC_PropertyOrLabelsExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PropertyOrLabelsExpressionContext differentiates from other interfaces.
	IsOC_PropertyOrLabelsExpressionContext()
}

type OC_PropertyOrLabelsExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PropertyOrLabelsExpressionContext() *OC_PropertyOrLabelsExpressionContext {
	var p = new(OC_PropertyOrLabelsExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_PropertyOrLabelsExpression
	return p
}

func (*OC_PropertyOrLabelsExpressionContext) IsOC_PropertyOrLabelsExpressionContext() {}

func NewOC_PropertyOrLabelsExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PropertyOrLabelsExpressionContext {
	var p = new(OC_PropertyOrLabelsExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_PropertyOrLabelsExpression

	return p
}

func (s *OC_PropertyOrLabelsExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PropertyOrLabelsExpressionContext) OC_Atom() IOC_AtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_AtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_AtomContext)
}

func (s *OC_PropertyOrLabelsExpressionContext) AllOC_PropertyLookup() []IOC_PropertyLookupContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_PropertyLookupContext); ok {
			len++
		}
	}

	tst := make([]IOC_PropertyLookupContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_PropertyLookupContext); ok {
			tst[i] = t.(IOC_PropertyLookupContext)
			i++
		}
	}

	return tst
}

func (s *OC_PropertyOrLabelsExpressionContext) OC_PropertyLookup(i int) IOC_PropertyLookupContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PropertyLookupContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PropertyLookupContext)
}

func (s *OC_PropertyOrLabelsExpressionContext) OC_NodeLabels() IOC_NodeLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_NodeLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_NodeLabelsContext)
}

func (s *OC_PropertyOrLabelsExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_PropertyOrLabelsExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_PropertyOrLabelsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PropertyOrLabelsExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_PropertyOrLabelsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_PropertyOrLabelsExpression(s)
	}
}

func (s *OC_PropertyOrLabelsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_PropertyOrLabelsExpression(s)
	}
}

func (p *TTQLParser) OC_PropertyOrLabelsExpression() (localctx IOC_PropertyOrLabelsExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_PropertyOrLabelsExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, TTQLParserRULE_oC_PropertyOrLabelsExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1168)
		p.OC_Atom()
	}
	p.SetState(1175)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1170)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(1169)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(1172)
				p.OC_PropertyLookup()
			}

		}
		p.SetState(1177)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext())
	}
	p.SetState(1182)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
		p.SetState(1179)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1178)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1181)
			p.OC_NodeLabels()
		}

	}

	return localctx
}

// IOC_PropertyLookupContext is an interface to support dynamic dispatch.
type IOC_PropertyLookupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PropertyLookupContext differentiates from other interfaces.
	IsOC_PropertyLookupContext()
}

type OC_PropertyLookupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PropertyLookupContext() *OC_PropertyLookupContext {
	var p = new(OC_PropertyLookupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_PropertyLookup
	return p
}

func (*OC_PropertyLookupContext) IsOC_PropertyLookupContext() {}

func NewOC_PropertyLookupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PropertyLookupContext {
	var p = new(OC_PropertyLookupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_PropertyLookup

	return p
}

func (s *OC_PropertyLookupContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PropertyLookupContext) OC_PropertyKeyName() IOC_PropertyKeyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PropertyKeyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PropertyKeyNameContext)
}

func (s *OC_PropertyLookupContext) SP() antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, 0)
}

func (s *OC_PropertyLookupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PropertyLookupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_PropertyLookupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_PropertyLookup(s)
	}
}

func (s *OC_PropertyLookupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_PropertyLookup(s)
	}
}

func (p *TTQLParser) OC_PropertyLookup() (localctx IOC_PropertyLookupContext) {
	this := p
	_ = this

	localctx = NewOC_PropertyLookupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, TTQLParserRULE_oC_PropertyLookup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1184)
		p.Match(TTQLParserT__22)
	}
	p.SetState(1186)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1185)
			p.Match(TTQLParserSP)
		}

	}

	{
		p.SetState(1188)
		p.OC_PropertyKeyName()
	}

	return localctx
}

// IOC_AtomContext is an interface to support dynamic dispatch.
type IOC_AtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_AtomContext differentiates from other interfaces.
	IsOC_AtomContext()
}

type OC_AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_AtomContext() *OC_AtomContext {
	var p = new(OC_AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Atom
	return p
}

func (*OC_AtomContext) IsOC_AtomContext() {}

func NewOC_AtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_AtomContext {
	var p = new(OC_AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Atom

	return p
}

func (s *OC_AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_AtomContext) OC_Literal() IOC_LiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_LiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_LiteralContext)
}

func (s *OC_AtomContext) OC_Parameter() IOC_ParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ParameterContext)
}

func (s *OC_AtomContext) OC_CaseExpression() IOC_CaseExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_CaseExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_CaseExpressionContext)
}

func (s *OC_AtomContext) COUNT() antlr.TerminalNode {
	return s.GetToken(TTQLParserCOUNT, 0)
}

func (s *OC_AtomContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_AtomContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_AtomContext) OC_ListComprehension() IOC_ListComprehensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ListComprehensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ListComprehensionContext)
}

func (s *OC_AtomContext) OC_PatternComprehension() IOC_PatternComprehensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PatternComprehensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PatternComprehensionContext)
}

func (s *OC_AtomContext) OC_Quantifier() IOC_QuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_QuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_QuantifierContext)
}

func (s *OC_AtomContext) OC_PatternPredicate() IOC_PatternPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PatternPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PatternPredicateContext)
}

func (s *OC_AtomContext) OC_ParenthesizedExpression() IOC_ParenthesizedExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ParenthesizedExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ParenthesizedExpressionContext)
}

func (s *OC_AtomContext) OC_FunctionInvocation() IOC_FunctionInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_FunctionInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_FunctionInvocationContext)
}

func (s *OC_AtomContext) OC_ExistentialSubquery() IOC_ExistentialSubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExistentialSubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExistentialSubqueryContext)
}

func (s *OC_AtomContext) OC_Variable() IOC_VariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_VariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Atom(s)
	}
}

func (s *OC_AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Atom(s)
	}
}

func (p *TTQLParser) OC_Atom() (localctx IOC_AtomContext) {
	this := p
	_ = this

	localctx = NewOC_AtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, TTQLParserRULE_oC_Atom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1214)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1190)
			p.OC_Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1191)
			p.OC_Parameter()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1192)
			p.OC_CaseExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1193)
			p.Match(TTQLParserCOUNT)
		}
		p.SetState(1195)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1194)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1197)
			p.Match(TTQLParserT__5)
		}
		p.SetState(1199)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1198)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1201)
			p.Match(TTQLParserT__4)
		}
		p.SetState(1203)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1202)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1205)
			p.Match(TTQLParserT__6)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1206)
			p.OC_ListComprehension()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1207)
			p.OC_PatternComprehension()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1208)
			p.OC_Quantifier()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1209)
			p.OC_PatternPredicate()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1210)
			p.OC_ParenthesizedExpression()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1211)
			p.OC_FunctionInvocation()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1212)
			p.OC_ExistentialSubquery()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1213)
			p.OC_Variable()
		}

	}

	return localctx
}

// IOC_CaseExpressionContext is an interface to support dynamic dispatch.
type IOC_CaseExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_CaseExpressionContext differentiates from other interfaces.
	IsOC_CaseExpressionContext()
}

type OC_CaseExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_CaseExpressionContext() *OC_CaseExpressionContext {
	var p = new(OC_CaseExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_CaseExpression
	return p
}

func (*OC_CaseExpressionContext) IsOC_CaseExpressionContext() {}

func NewOC_CaseExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_CaseExpressionContext {
	var p = new(OC_CaseExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_CaseExpression

	return p
}

func (s *OC_CaseExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_CaseExpressionContext) END() antlr.TerminalNode {
	return s.GetToken(TTQLParserEND, 0)
}

func (s *OC_CaseExpressionContext) ELSE() antlr.TerminalNode {
	return s.GetToken(TTQLParserELSE, 0)
}

func (s *OC_CaseExpressionContext) AllOC_Expression() []IOC_ExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_ExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_ExpressionContext); ok {
			tst[i] = t.(IOC_ExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_CaseExpressionContext) OC_Expression(i int) IOC_ExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_CaseExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_CaseExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_CaseExpressionContext) CASE() antlr.TerminalNode {
	return s.GetToken(TTQLParserCASE, 0)
}

func (s *OC_CaseExpressionContext) AllOC_CaseAlternative() []IOC_CaseAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_CaseAlternativeContext); ok {
			len++
		}
	}

	tst := make([]IOC_CaseAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_CaseAlternativeContext); ok {
			tst[i] = t.(IOC_CaseAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *OC_CaseExpressionContext) OC_CaseAlternative(i int) IOC_CaseAlternativeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_CaseAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_CaseAlternativeContext)
}

func (s *OC_CaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_CaseExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_CaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_CaseExpression(s)
	}
}

func (s *OC_CaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_CaseExpression(s)
	}
}

func (p *TTQLParser) OC_CaseExpression() (localctx IOC_CaseExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_CaseExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, TTQLParserRULE_oC_CaseExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1238)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 216, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1216)
			p.Match(TTQLParserCASE)
		}
		p.SetState(1221)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(1218)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(1217)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(1220)
					p.OC_CaseAlternative()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1223)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 212, p.GetParserRuleContext())
		}

	case 2:
		{
			p.SetState(1225)
			p.Match(TTQLParserCASE)
		}
		p.SetState(1227)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1226)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1229)
			p.OC_Expression()
		}
		p.SetState(1234)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(1231)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == TTQLParserSP {
					{
						p.SetState(1230)
						p.Match(TTQLParserSP)
					}

				}
				{
					p.SetState(1233)
					p.OC_CaseAlternative()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1236)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 215, p.GetParserRuleContext())
		}

	}
	p.SetState(1248)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 219, p.GetParserRuleContext()) == 1 {
		p.SetState(1241)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1240)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1243)
			p.Match(TTQLParserELSE)
		}
		p.SetState(1245)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1244)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1247)
			p.OC_Expression()
		}

	}
	p.SetState(1251)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1250)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1253)
		p.Match(TTQLParserEND)
	}

	return localctx
}

// IOC_CaseAlternativeContext is an interface to support dynamic dispatch.
type IOC_CaseAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_CaseAlternativeContext differentiates from other interfaces.
	IsOC_CaseAlternativeContext()
}

type OC_CaseAlternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_CaseAlternativeContext() *OC_CaseAlternativeContext {
	var p = new(OC_CaseAlternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_CaseAlternative
	return p
}

func (*OC_CaseAlternativeContext) IsOC_CaseAlternativeContext() {}

func NewOC_CaseAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_CaseAlternativeContext {
	var p = new(OC_CaseAlternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_CaseAlternative

	return p
}

func (s *OC_CaseAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_CaseAlternativeContext) WHEN() antlr.TerminalNode {
	return s.GetToken(TTQLParserWHEN, 0)
}

func (s *OC_CaseAlternativeContext) AllOC_Expression() []IOC_ExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_ExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_ExpressionContext); ok {
			tst[i] = t.(IOC_ExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_CaseAlternativeContext) OC_Expression(i int) IOC_ExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_CaseAlternativeContext) THEN() antlr.TerminalNode {
	return s.GetToken(TTQLParserTHEN, 0)
}

func (s *OC_CaseAlternativeContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_CaseAlternativeContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_CaseAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_CaseAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_CaseAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_CaseAlternative(s)
	}
}

func (s *OC_CaseAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_CaseAlternative(s)
	}
}

func (p *TTQLParser) OC_CaseAlternative() (localctx IOC_CaseAlternativeContext) {
	this := p
	_ = this

	localctx = NewOC_CaseAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, TTQLParserRULE_oC_CaseAlternative)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1255)
		p.Match(TTQLParserWHEN)
	}
	p.SetState(1257)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1256)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1259)
		p.OC_Expression()
	}
	p.SetState(1261)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1260)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1263)
		p.Match(TTQLParserTHEN)
	}
	p.SetState(1265)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1264)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1267)
		p.OC_Expression()
	}

	return localctx
}

// IOC_ListComprehensionContext is an interface to support dynamic dispatch.
type IOC_ListComprehensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ListComprehensionContext differentiates from other interfaces.
	IsOC_ListComprehensionContext()
}

type OC_ListComprehensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ListComprehensionContext() *OC_ListComprehensionContext {
	var p = new(OC_ListComprehensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ListComprehension
	return p
}

func (*OC_ListComprehensionContext) IsOC_ListComprehensionContext() {}

func NewOC_ListComprehensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ListComprehensionContext {
	var p = new(OC_ListComprehensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ListComprehension

	return p
}

func (s *OC_ListComprehensionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ListComprehensionContext) OC_FilterExpression() IOC_FilterExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_FilterExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_FilterExpressionContext)
}

func (s *OC_ListComprehensionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_ListComprehensionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_ListComprehensionContext) OC_Expression() IOC_ExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_ListComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ListComprehensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ListComprehensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ListComprehension(s)
	}
}

func (s *OC_ListComprehensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ListComprehension(s)
	}
}

func (p *TTQLParser) OC_ListComprehension() (localctx IOC_ListComprehensionContext) {
	this := p
	_ = this

	localctx = NewOC_ListComprehensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, TTQLParserRULE_oC_ListComprehension)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1269)
		p.Match(TTQLParserT__7)
	}
	p.SetState(1271)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1270)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1273)
		p.OC_FilterExpression()
	}
	p.SetState(1282)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 227, p.GetParserRuleContext()) == 1 {
		p.SetState(1275)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1274)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1277)
			p.Match(TTQLParserT__10)
		}
		p.SetState(1279)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1278)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1281)
			p.OC_Expression()
		}

	}
	p.SetState(1285)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1284)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1287)
		p.Match(TTQLParserT__8)
	}

	return localctx
}

// IOC_PatternComprehensionContext is an interface to support dynamic dispatch.
type IOC_PatternComprehensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PatternComprehensionContext differentiates from other interfaces.
	IsOC_PatternComprehensionContext()
}

type OC_PatternComprehensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PatternComprehensionContext() *OC_PatternComprehensionContext {
	var p = new(OC_PatternComprehensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_PatternComprehension
	return p
}

func (*OC_PatternComprehensionContext) IsOC_PatternComprehensionContext() {}

func NewOC_PatternComprehensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PatternComprehensionContext {
	var p = new(OC_PatternComprehensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_PatternComprehension

	return p
}

func (s *OC_PatternComprehensionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PatternComprehensionContext) OC_RelationshipsPattern() IOC_RelationshipsPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_RelationshipsPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_RelationshipsPatternContext)
}

func (s *OC_PatternComprehensionContext) OC_Expression() IOC_ExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_PatternComprehensionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_PatternComprehensionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_PatternComprehensionContext) OC_Variable() IOC_VariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_VariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_PatternComprehensionContext) OC_Where() IOC_WhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_WhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_WhereContext)
}

func (s *OC_PatternComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PatternComprehensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_PatternComprehensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_PatternComprehension(s)
	}
}

func (s *OC_PatternComprehensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_PatternComprehension(s)
	}
}

func (p *TTQLParser) OC_PatternComprehension() (localctx IOC_PatternComprehensionContext) {
	this := p
	_ = this

	localctx = NewOC_PatternComprehensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, TTQLParserRULE_oC_PatternComprehension)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1289)
		p.Match(TTQLParserT__7)
	}
	p.SetState(1291)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1290)
			p.Match(TTQLParserSP)
		}

	}
	p.SetState(1301)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&2680059625921) != 0 {
		{
			p.SetState(1293)
			p.OC_Variable()
		}
		p.SetState(1295)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1294)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1297)
			p.Match(TTQLParserT__2)
		}
		p.SetState(1299)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1298)
				p.Match(TTQLParserSP)
			}

		}

	}
	{
		p.SetState(1303)
		p.OC_RelationshipsPattern()
	}
	p.SetState(1305)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1304)
			p.Match(TTQLParserSP)
		}

	}
	p.SetState(1311)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserWHERE {
		{
			p.SetState(1307)
			p.OC_Where()
		}
		p.SetState(1309)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1308)
				p.Match(TTQLParserSP)
			}

		}

	}
	{
		p.SetState(1313)
		p.Match(TTQLParserT__10)
	}
	p.SetState(1315)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1314)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1317)
		p.OC_Expression()
	}
	p.SetState(1319)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1318)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1321)
		p.Match(TTQLParserT__8)
	}

	return localctx
}

// IOC_QuantifierContext is an interface to support dynamic dispatch.
type IOC_QuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_QuantifierContext differentiates from other interfaces.
	IsOC_QuantifierContext()
}

type OC_QuantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_QuantifierContext() *OC_QuantifierContext {
	var p = new(OC_QuantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Quantifier
	return p
}

func (*OC_QuantifierContext) IsOC_QuantifierContext() {}

func NewOC_QuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_QuantifierContext {
	var p = new(OC_QuantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Quantifier

	return p
}

func (s *OC_QuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_QuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(TTQLParserALL, 0)
}

func (s *OC_QuantifierContext) OC_FilterExpression() IOC_FilterExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_FilterExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_FilterExpressionContext)
}

func (s *OC_QuantifierContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_QuantifierContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_QuantifierContext) ANY() antlr.TerminalNode {
	return s.GetToken(TTQLParserANY, 0)
}

func (s *OC_QuantifierContext) NONE() antlr.TerminalNode {
	return s.GetToken(TTQLParserNONE, 0)
}

func (s *OC_QuantifierContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(TTQLParserSINGLE, 0)
}

func (s *OC_QuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_QuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_QuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Quantifier(s)
	}
}

func (s *OC_QuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Quantifier(s)
	}
}

func (p *TTQLParser) OC_Quantifier() (localctx IOC_QuantifierContext) {
	this := p
	_ = this

	localctx = NewOC_QuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, TTQLParserRULE_oC_Quantifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1379)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TTQLParserALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1323)
			p.Match(TTQLParserALL)
		}
		p.SetState(1325)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1324)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1327)
			p.Match(TTQLParserT__5)
		}
		p.SetState(1329)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1328)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1331)
			p.OC_FilterExpression()
		}
		p.SetState(1333)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1332)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1335)
			p.Match(TTQLParserT__6)
		}

	case TTQLParserANY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1337)
			p.Match(TTQLParserANY)
		}
		p.SetState(1339)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1338)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1341)
			p.Match(TTQLParserT__5)
		}
		p.SetState(1343)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1342)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1345)
			p.OC_FilterExpression()
		}
		p.SetState(1347)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1346)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1349)
			p.Match(TTQLParserT__6)
		}

	case TTQLParserNONE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1351)
			p.Match(TTQLParserNONE)
		}
		p.SetState(1353)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1352)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1355)
			p.Match(TTQLParserT__5)
		}
		p.SetState(1357)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1356)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1359)
			p.OC_FilterExpression()
		}
		p.SetState(1361)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1360)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1363)
			p.Match(TTQLParserT__6)
		}

	case TTQLParserSINGLE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1365)
			p.Match(TTQLParserSINGLE)
		}
		p.SetState(1367)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1366)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1369)
			p.Match(TTQLParserT__5)
		}
		p.SetState(1371)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1370)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1373)
			p.OC_FilterExpression()
		}
		p.SetState(1375)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1374)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1377)
			p.Match(TTQLParserT__6)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOC_FilterExpressionContext is an interface to support dynamic dispatch.
type IOC_FilterExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_FilterExpressionContext differentiates from other interfaces.
	IsOC_FilterExpressionContext()
}

type OC_FilterExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_FilterExpressionContext() *OC_FilterExpressionContext {
	var p = new(OC_FilterExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_FilterExpression
	return p
}

func (*OC_FilterExpressionContext) IsOC_FilterExpressionContext() {}

func NewOC_FilterExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_FilterExpressionContext {
	var p = new(OC_FilterExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_FilterExpression

	return p
}

func (s *OC_FilterExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_FilterExpressionContext) OC_IdInColl() IOC_IdInCollContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_IdInCollContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_IdInCollContext)
}

func (s *OC_FilterExpressionContext) OC_Where() IOC_WhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_WhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_WhereContext)
}

func (s *OC_FilterExpressionContext) SP() antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, 0)
}

func (s *OC_FilterExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_FilterExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_FilterExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_FilterExpression(s)
	}
}

func (s *OC_FilterExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_FilterExpression(s)
	}
}

func (p *TTQLParser) OC_FilterExpression() (localctx IOC_FilterExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_FilterExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, TTQLParserRULE_oC_FilterExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1381)
		p.OC_IdInColl()
	}
	p.SetState(1386)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 252, p.GetParserRuleContext()) == 1 {
		p.SetState(1383)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1382)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1385)
			p.OC_Where()
		}

	}

	return localctx
}

// IOC_PatternPredicateContext is an interface to support dynamic dispatch.
type IOC_PatternPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PatternPredicateContext differentiates from other interfaces.
	IsOC_PatternPredicateContext()
}

type OC_PatternPredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PatternPredicateContext() *OC_PatternPredicateContext {
	var p = new(OC_PatternPredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_PatternPredicate
	return p
}

func (*OC_PatternPredicateContext) IsOC_PatternPredicateContext() {}

func NewOC_PatternPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PatternPredicateContext {
	var p = new(OC_PatternPredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_PatternPredicate

	return p
}

func (s *OC_PatternPredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PatternPredicateContext) OC_RelationshipsPattern() IOC_RelationshipsPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_RelationshipsPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_RelationshipsPatternContext)
}

func (s *OC_PatternPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PatternPredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_PatternPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_PatternPredicate(s)
	}
}

func (s *OC_PatternPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_PatternPredicate(s)
	}
}

func (p *TTQLParser) OC_PatternPredicate() (localctx IOC_PatternPredicateContext) {
	this := p
	_ = this

	localctx = NewOC_PatternPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, TTQLParserRULE_oC_PatternPredicate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1388)
		p.OC_RelationshipsPattern()
	}

	return localctx
}

// IOC_ParenthesizedExpressionContext is an interface to support dynamic dispatch.
type IOC_ParenthesizedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ParenthesizedExpressionContext differentiates from other interfaces.
	IsOC_ParenthesizedExpressionContext()
}

type OC_ParenthesizedExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ParenthesizedExpressionContext() *OC_ParenthesizedExpressionContext {
	var p = new(OC_ParenthesizedExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ParenthesizedExpression
	return p
}

func (*OC_ParenthesizedExpressionContext) IsOC_ParenthesizedExpressionContext() {}

func NewOC_ParenthesizedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ParenthesizedExpressionContext {
	var p = new(OC_ParenthesizedExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ParenthesizedExpression

	return p
}

func (s *OC_ParenthesizedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ParenthesizedExpressionContext) OC_Expression() IOC_ExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_ParenthesizedExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_ParenthesizedExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ParenthesizedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ParenthesizedExpression(s)
	}
}

func (s *OC_ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ParenthesizedExpression(s)
	}
}

func (p *TTQLParser) OC_ParenthesizedExpression() (localctx IOC_ParenthesizedExpressionContext) {
	this := p
	_ = this

	localctx = NewOC_ParenthesizedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, TTQLParserRULE_oC_ParenthesizedExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1390)
		p.Match(TTQLParserT__5)
	}
	p.SetState(1392)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1391)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1394)
		p.OC_Expression()
	}
	p.SetState(1396)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1395)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1398)
		p.Match(TTQLParserT__6)
	}

	return localctx
}

// IOC_IdInCollContext is an interface to support dynamic dispatch.
type IOC_IdInCollContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_IdInCollContext differentiates from other interfaces.
	IsOC_IdInCollContext()
}

type OC_IdInCollContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_IdInCollContext() *OC_IdInCollContext {
	var p = new(OC_IdInCollContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_IdInColl
	return p
}

func (*OC_IdInCollContext) IsOC_IdInCollContext() {}

func NewOC_IdInCollContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_IdInCollContext {
	var p = new(OC_IdInCollContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_IdInColl

	return p
}

func (s *OC_IdInCollContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_IdInCollContext) OC_Variable() IOC_VariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_VariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_IdInCollContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_IdInCollContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_IdInCollContext) IN() antlr.TerminalNode {
	return s.GetToken(TTQLParserIN, 0)
}

func (s *OC_IdInCollContext) OC_Expression() IOC_ExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_IdInCollContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_IdInCollContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_IdInCollContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_IdInColl(s)
	}
}

func (s *OC_IdInCollContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_IdInColl(s)
	}
}

func (p *TTQLParser) OC_IdInColl() (localctx IOC_IdInCollContext) {
	this := p
	_ = this

	localctx = NewOC_IdInCollContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, TTQLParserRULE_oC_IdInColl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1400)
		p.OC_Variable()
	}
	{
		p.SetState(1401)
		p.Match(TTQLParserSP)
	}
	{
		p.SetState(1402)
		p.Match(TTQLParserIN)
	}
	{
		p.SetState(1403)
		p.Match(TTQLParserSP)
	}
	{
		p.SetState(1404)
		p.OC_Expression()
	}

	return localctx
}

// IOC_FunctionInvocationContext is an interface to support dynamic dispatch.
type IOC_FunctionInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_FunctionInvocationContext differentiates from other interfaces.
	IsOC_FunctionInvocationContext()
}

type OC_FunctionInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_FunctionInvocationContext() *OC_FunctionInvocationContext {
	var p = new(OC_FunctionInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_FunctionInvocation
	return p
}

func (*OC_FunctionInvocationContext) IsOC_FunctionInvocationContext() {}

func NewOC_FunctionInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_FunctionInvocationContext {
	var p = new(OC_FunctionInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_FunctionInvocation

	return p
}

func (s *OC_FunctionInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_FunctionInvocationContext) OC_FunctionName() IOC_FunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_FunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_FunctionNameContext)
}

func (s *OC_FunctionInvocationContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_FunctionInvocationContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_FunctionInvocationContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(TTQLParserDISTINCT, 0)
}

func (s *OC_FunctionInvocationContext) AllOC_Expression() []IOC_ExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_ExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_ExpressionContext); ok {
			tst[i] = t.(IOC_ExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_FunctionInvocationContext) OC_Expression(i int) IOC_ExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_FunctionInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_FunctionInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_FunctionInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_FunctionInvocation(s)
	}
}

func (s *OC_FunctionInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_FunctionInvocation(s)
	}
}

func (p *TTQLParser) OC_FunctionInvocation() (localctx IOC_FunctionInvocationContext) {
	this := p
	_ = this

	localctx = NewOC_FunctionInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, TTQLParserRULE_oC_FunctionInvocation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1406)
		p.OC_FunctionName()
	}
	p.SetState(1408)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1407)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1410)
		p.Match(TTQLParserT__5)
	}
	p.SetState(1412)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1411)
			p.Match(TTQLParserSP)
		}

	}
	p.SetState(1418)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserDISTINCT {
		{
			p.SetState(1414)
			p.Match(TTQLParserDISTINCT)
		}
		p.SetState(1416)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1415)
				p.Match(TTQLParserSP)
			}

		}

	}
	p.SetState(1437)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4503599712043328) != 0 || (int64((_la-81)) & ^0x3f) == 0 && ((int64(1)<<(_la-81))&343051394343361) != 0 {
		{
			p.SetState(1420)
			p.OC_Expression()
		}
		p.SetState(1422)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1421)
				p.Match(TTQLParserSP)
			}

		}
		p.SetState(1434)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == TTQLParserT__1 {
			{
				p.SetState(1424)
				p.Match(TTQLParserT__1)
			}
			p.SetState(1426)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(1425)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(1428)
				p.OC_Expression()
			}
			p.SetState(1430)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(1429)
					p.Match(TTQLParserSP)
				}

			}

			p.SetState(1436)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1439)
		p.Match(TTQLParserT__6)
	}

	return localctx
}

// IOC_FunctionNameContext is an interface to support dynamic dispatch.
type IOC_FunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_FunctionNameContext differentiates from other interfaces.
	IsOC_FunctionNameContext()
}

type OC_FunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_FunctionNameContext() *OC_FunctionNameContext {
	var p = new(OC_FunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_FunctionName
	return p
}

func (*OC_FunctionNameContext) IsOC_FunctionNameContext() {}

func NewOC_FunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_FunctionNameContext {
	var p = new(OC_FunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_FunctionName

	return p
}

func (s *OC_FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_FunctionNameContext) OC_Namespace() IOC_NamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_NamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_NamespaceContext)
}

func (s *OC_FunctionNameContext) OC_SymbolicName() IOC_SymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SymbolicNameContext)
}

func (s *OC_FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_FunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_FunctionName(s)
	}
}

func (s *OC_FunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_FunctionName(s)
	}
}

func (p *TTQLParser) OC_FunctionName() (localctx IOC_FunctionNameContext) {
	this := p
	_ = this

	localctx = NewOC_FunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, TTQLParserRULE_oC_FunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1441)
		p.OC_Namespace()
	}
	{
		p.SetState(1442)
		p.OC_SymbolicName()
	}

	return localctx
}

// IOC_ExistentialSubqueryContext is an interface to support dynamic dispatch.
type IOC_ExistentialSubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ExistentialSubqueryContext differentiates from other interfaces.
	IsOC_ExistentialSubqueryContext()
}

type OC_ExistentialSubqueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ExistentialSubqueryContext() *OC_ExistentialSubqueryContext {
	var p = new(OC_ExistentialSubqueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ExistentialSubquery
	return p
}

func (*OC_ExistentialSubqueryContext) IsOC_ExistentialSubqueryContext() {}

func NewOC_ExistentialSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ExistentialSubqueryContext {
	var p = new(OC_ExistentialSubqueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ExistentialSubquery

	return p
}

func (s *OC_ExistentialSubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ExistentialSubqueryContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(TTQLParserEXISTS, 0)
}

func (s *OC_ExistentialSubqueryContext) OC_RegularQuery() IOC_RegularQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_RegularQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_RegularQueryContext)
}

func (s *OC_ExistentialSubqueryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_ExistentialSubqueryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_ExistentialSubqueryContext) OC_Pattern() IOC_PatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PatternContext)
}

func (s *OC_ExistentialSubqueryContext) OC_Where() IOC_WhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_WhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_WhereContext)
}

func (s *OC_ExistentialSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ExistentialSubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ExistentialSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ExistentialSubquery(s)
	}
}

func (s *OC_ExistentialSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ExistentialSubquery(s)
	}
}

func (p *TTQLParser) OC_ExistentialSubquery() (localctx IOC_ExistentialSubqueryContext) {
	this := p
	_ = this

	localctx = NewOC_ExistentialSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, TTQLParserRULE_oC_ExistentialSubquery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1444)
		p.Match(TTQLParserEXISTS)
	}
	p.SetState(1446)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1445)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1448)
		p.Match(TTQLParserT__23)
	}
	p.SetState(1450)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1449)
			p.Match(TTQLParserSP)
		}

	}
	p.SetState(1460)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TTQLParserOPTIONAL, TTQLParserMATCH, TTQLParserUNWIND, TTQLParserMERGE, TTQLParserCREATE, TTQLParserSET, TTQLParserDETACH, TTQLParserDELETE, TTQLParserREMOVE, TTQLParserCALL, TTQLParserWITH, TTQLParserRETURN:
		{
			p.SetState(1452)
			p.OC_RegularQuery()
		}

	case TTQLParserT__5, TTQLParserCOUNT, TTQLParserANY, TTQLParserNONE, TTQLParserSINGLE, TTQLParserHexLetter, TTQLParserFILTER, TTQLParserEXTRACT, TTQLParserUnescapedSymbolicName, TTQLParserEscapedSymbolicName:
		{
			p.SetState(1453)
			p.OC_Pattern()
		}
		p.SetState(1458)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 267, p.GetParserRuleContext()) == 1 {
			p.SetState(1455)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(1454)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(1457)
				p.OC_Where()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1463)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1462)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1465)
		p.Match(TTQLParserT__24)
	}

	return localctx
}

// IOC_ExplicitProcedureInvocationContext is an interface to support dynamic dispatch.
type IOC_ExplicitProcedureInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ExplicitProcedureInvocationContext differentiates from other interfaces.
	IsOC_ExplicitProcedureInvocationContext()
}

type OC_ExplicitProcedureInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ExplicitProcedureInvocationContext() *OC_ExplicitProcedureInvocationContext {
	var p = new(OC_ExplicitProcedureInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ExplicitProcedureInvocation
	return p
}

func (*OC_ExplicitProcedureInvocationContext) IsOC_ExplicitProcedureInvocationContext() {}

func NewOC_ExplicitProcedureInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ExplicitProcedureInvocationContext {
	var p = new(OC_ExplicitProcedureInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ExplicitProcedureInvocation

	return p
}

func (s *OC_ExplicitProcedureInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ExplicitProcedureInvocationContext) OC_ProcedureName() IOC_ProcedureNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ProcedureNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ProcedureNameContext)
}

func (s *OC_ExplicitProcedureInvocationContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_ExplicitProcedureInvocationContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_ExplicitProcedureInvocationContext) AllOC_Expression() []IOC_ExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_ExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_ExpressionContext); ok {
			tst[i] = t.(IOC_ExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_ExplicitProcedureInvocationContext) OC_Expression(i int) IOC_ExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_ExplicitProcedureInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ExplicitProcedureInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ExplicitProcedureInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ExplicitProcedureInvocation(s)
	}
}

func (s *OC_ExplicitProcedureInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ExplicitProcedureInvocation(s)
	}
}

func (p *TTQLParser) OC_ExplicitProcedureInvocation() (localctx IOC_ExplicitProcedureInvocationContext) {
	this := p
	_ = this

	localctx = NewOC_ExplicitProcedureInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, TTQLParserRULE_oC_ExplicitProcedureInvocation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1467)
		p.OC_ProcedureName()
	}
	p.SetState(1469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1468)
			p.Match(TTQLParserSP)
		}

	}
	{
		p.SetState(1471)
		p.Match(TTQLParserT__5)
	}
	p.SetState(1473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1472)
			p.Match(TTQLParserSP)
		}

	}
	p.SetState(1492)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4503599712043328) != 0 || (int64((_la-81)) & ^0x3f) == 0 && ((int64(1)<<(_la-81))&343051394343361) != 0 {
		{
			p.SetState(1475)
			p.OC_Expression()
		}
		p.SetState(1477)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1476)
				p.Match(TTQLParserSP)
			}

		}
		p.SetState(1489)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == TTQLParserT__1 {
			{
				p.SetState(1479)
				p.Match(TTQLParserT__1)
			}
			p.SetState(1481)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(1480)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(1483)
				p.OC_Expression()
			}
			p.SetState(1485)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(1484)
					p.Match(TTQLParserSP)
				}

			}

			p.SetState(1491)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1494)
		p.Match(TTQLParserT__6)
	}

	return localctx
}

// IOC_ImplicitProcedureInvocationContext is an interface to support dynamic dispatch.
type IOC_ImplicitProcedureInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ImplicitProcedureInvocationContext differentiates from other interfaces.
	IsOC_ImplicitProcedureInvocationContext()
}

type OC_ImplicitProcedureInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ImplicitProcedureInvocationContext() *OC_ImplicitProcedureInvocationContext {
	var p = new(OC_ImplicitProcedureInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ImplicitProcedureInvocation
	return p
}

func (*OC_ImplicitProcedureInvocationContext) IsOC_ImplicitProcedureInvocationContext() {}

func NewOC_ImplicitProcedureInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ImplicitProcedureInvocationContext {
	var p = new(OC_ImplicitProcedureInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ImplicitProcedureInvocation

	return p
}

func (s *OC_ImplicitProcedureInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ImplicitProcedureInvocationContext) OC_ProcedureName() IOC_ProcedureNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ProcedureNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ProcedureNameContext)
}

func (s *OC_ImplicitProcedureInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ImplicitProcedureInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ImplicitProcedureInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ImplicitProcedureInvocation(s)
	}
}

func (s *OC_ImplicitProcedureInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ImplicitProcedureInvocation(s)
	}
}

func (p *TTQLParser) OC_ImplicitProcedureInvocation() (localctx IOC_ImplicitProcedureInvocationContext) {
	this := p
	_ = this

	localctx = NewOC_ImplicitProcedureInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, TTQLParserRULE_oC_ImplicitProcedureInvocation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1496)
		p.OC_ProcedureName()
	}

	return localctx
}

// IOC_ProcedureResultFieldContext is an interface to support dynamic dispatch.
type IOC_ProcedureResultFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ProcedureResultFieldContext differentiates from other interfaces.
	IsOC_ProcedureResultFieldContext()
}

type OC_ProcedureResultFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ProcedureResultFieldContext() *OC_ProcedureResultFieldContext {
	var p = new(OC_ProcedureResultFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ProcedureResultField
	return p
}

func (*OC_ProcedureResultFieldContext) IsOC_ProcedureResultFieldContext() {}

func NewOC_ProcedureResultFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ProcedureResultFieldContext {
	var p = new(OC_ProcedureResultFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ProcedureResultField

	return p
}

func (s *OC_ProcedureResultFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ProcedureResultFieldContext) OC_SymbolicName() IOC_SymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SymbolicNameContext)
}

func (s *OC_ProcedureResultFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ProcedureResultFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ProcedureResultFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ProcedureResultField(s)
	}
}

func (s *OC_ProcedureResultFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ProcedureResultField(s)
	}
}

func (p *TTQLParser) OC_ProcedureResultField() (localctx IOC_ProcedureResultFieldContext) {
	this := p
	_ = this

	localctx = NewOC_ProcedureResultFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, TTQLParserRULE_oC_ProcedureResultField)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1498)
		p.OC_SymbolicName()
	}

	return localctx
}

// IOC_ProcedureNameContext is an interface to support dynamic dispatch.
type IOC_ProcedureNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ProcedureNameContext differentiates from other interfaces.
	IsOC_ProcedureNameContext()
}

type OC_ProcedureNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ProcedureNameContext() *OC_ProcedureNameContext {
	var p = new(OC_ProcedureNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ProcedureName
	return p
}

func (*OC_ProcedureNameContext) IsOC_ProcedureNameContext() {}

func NewOC_ProcedureNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ProcedureNameContext {
	var p = new(OC_ProcedureNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ProcedureName

	return p
}

func (s *OC_ProcedureNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ProcedureNameContext) OC_Namespace() IOC_NamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_NamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_NamespaceContext)
}

func (s *OC_ProcedureNameContext) OC_SymbolicName() IOC_SymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SymbolicNameContext)
}

func (s *OC_ProcedureNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ProcedureNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ProcedureNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ProcedureName(s)
	}
}

func (s *OC_ProcedureNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ProcedureName(s)
	}
}

func (p *TTQLParser) OC_ProcedureName() (localctx IOC_ProcedureNameContext) {
	this := p
	_ = this

	localctx = NewOC_ProcedureNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, TTQLParserRULE_oC_ProcedureName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1500)
		p.OC_Namespace()
	}
	{
		p.SetState(1501)
		p.OC_SymbolicName()
	}

	return localctx
}

// IOC_NamespaceContext is an interface to support dynamic dispatch.
type IOC_NamespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_NamespaceContext differentiates from other interfaces.
	IsOC_NamespaceContext()
}

type OC_NamespaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_NamespaceContext() *OC_NamespaceContext {
	var p = new(OC_NamespaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Namespace
	return p
}

func (*OC_NamespaceContext) IsOC_NamespaceContext() {}

func NewOC_NamespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_NamespaceContext {
	var p = new(OC_NamespaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Namespace

	return p
}

func (s *OC_NamespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_NamespaceContext) AllOC_SymbolicName() []IOC_SymbolicNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_SymbolicNameContext); ok {
			len++
		}
	}

	tst := make([]IOC_SymbolicNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_SymbolicNameContext); ok {
			tst[i] = t.(IOC_SymbolicNameContext)
			i++
		}
	}

	return tst
}

func (s *OC_NamespaceContext) OC_SymbolicName(i int) IOC_SymbolicNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SymbolicNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SymbolicNameContext)
}

func (s *OC_NamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_NamespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_NamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Namespace(s)
	}
}

func (s *OC_NamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Namespace(s)
	}
}

func (p *TTQLParser) OC_Namespace() (localctx IOC_NamespaceContext) {
	this := p
	_ = this

	localctx = NewOC_NamespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, TTQLParserRULE_oC_Namespace)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1508)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 277, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1503)
				p.OC_SymbolicName()
			}
			{
				p.SetState(1504)
				p.Match(TTQLParserT__22)
			}

		}
		p.SetState(1510)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 277, p.GetParserRuleContext())
	}

	return localctx
}

// IOC_VariableContext is an interface to support dynamic dispatch.
type IOC_VariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_VariableContext differentiates from other interfaces.
	IsOC_VariableContext()
}

type OC_VariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_VariableContext() *OC_VariableContext {
	var p = new(OC_VariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Variable
	return p
}

func (*OC_VariableContext) IsOC_VariableContext() {}

func NewOC_VariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_VariableContext {
	var p = new(OC_VariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Variable

	return p
}

func (s *OC_VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_VariableContext) OC_SymbolicName() IOC_SymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SymbolicNameContext)
}

func (s *OC_VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_VariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Variable(s)
	}
}

func (s *OC_VariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Variable(s)
	}
}

func (p *TTQLParser) OC_Variable() (localctx IOC_VariableContext) {
	this := p
	_ = this

	localctx = NewOC_VariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, TTQLParserRULE_oC_Variable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1511)
		p.OC_SymbolicName()
	}

	return localctx
}

// IOC_LiteralContext is an interface to support dynamic dispatch.
type IOC_LiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_LiteralContext differentiates from other interfaces.
	IsOC_LiteralContext()
}

type OC_LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_LiteralContext() *OC_LiteralContext {
	var p = new(OC_LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Literal
	return p
}

func (*OC_LiteralContext) IsOC_LiteralContext() {}

func NewOC_LiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_LiteralContext {
	var p = new(OC_LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Literal

	return p
}

func (s *OC_LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_LiteralContext) OC_BooleanLiteral() IOC_BooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_BooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_BooleanLiteralContext)
}

func (s *OC_LiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(TTQLParserNULL, 0)
}

func (s *OC_LiteralContext) OC_NumberLiteral() IOC_NumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_NumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_NumberLiteralContext)
}

func (s *OC_LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(TTQLParserStringLiteral, 0)
}

func (s *OC_LiteralContext) OC_ListLiteral() IOC_ListLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ListLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ListLiteralContext)
}

func (s *OC_LiteralContext) OC_MapLiteral() IOC_MapLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_MapLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_MapLiteralContext)
}

func (s *OC_LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Literal(s)
	}
}

func (s *OC_LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Literal(s)
	}
}

func (p *TTQLParser) OC_Literal() (localctx IOC_LiteralContext) {
	this := p
	_ = this

	localctx = NewOC_LiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, TTQLParserRULE_oC_Literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1519)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TTQLParserTRUE, TTQLParserFALSE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1513)
			p.OC_BooleanLiteral()
		}

	case TTQLParserNULL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1514)
			p.Match(TTQLParserNULL)
		}

	case TTQLParserHexInteger, TTQLParserDecimalInteger, TTQLParserOctalInteger, TTQLParserExponentDecimalReal, TTQLParserRegularDecimalReal:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1515)
			p.OC_NumberLiteral()
		}

	case TTQLParserStringLiteral:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1516)
			p.Match(TTQLParserStringLiteral)
		}

	case TTQLParserT__7:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1517)
			p.OC_ListLiteral()
		}

	case TTQLParserT__23:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1518)
			p.OC_MapLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOC_BooleanLiteralContext is an interface to support dynamic dispatch.
type IOC_BooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_BooleanLiteralContext differentiates from other interfaces.
	IsOC_BooleanLiteralContext()
}

type OC_BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_BooleanLiteralContext() *OC_BooleanLiteralContext {
	var p = new(OC_BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_BooleanLiteral
	return p
}

func (*OC_BooleanLiteralContext) IsOC_BooleanLiteralContext() {}

func NewOC_BooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_BooleanLiteralContext {
	var p = new(OC_BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_BooleanLiteral

	return p
}

func (s *OC_BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(TTQLParserTRUE, 0)
}

func (s *OC_BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(TTQLParserFALSE, 0)
}

func (s *OC_BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_BooleanLiteral(s)
	}
}

func (s *OC_BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_BooleanLiteral(s)
	}
}

func (p *TTQLParser) OC_BooleanLiteral() (localctx IOC_BooleanLiteralContext) {
	this := p
	_ = this

	localctx = NewOC_BooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, TTQLParserRULE_oC_BooleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1521)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TTQLParserTRUE || _la == TTQLParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOC_NumberLiteralContext is an interface to support dynamic dispatch.
type IOC_NumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_NumberLiteralContext differentiates from other interfaces.
	IsOC_NumberLiteralContext()
}

type OC_NumberLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_NumberLiteralContext() *OC_NumberLiteralContext {
	var p = new(OC_NumberLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_NumberLiteral
	return p
}

func (*OC_NumberLiteralContext) IsOC_NumberLiteralContext() {}

func NewOC_NumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_NumberLiteralContext {
	var p = new(OC_NumberLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_NumberLiteral

	return p
}

func (s *OC_NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_NumberLiteralContext) OC_DoubleLiteral() IOC_DoubleLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_DoubleLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_DoubleLiteralContext)
}

func (s *OC_NumberLiteralContext) OC_IntegerLiteral() IOC_IntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_IntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_IntegerLiteralContext)
}

func (s *OC_NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_NumberLiteral(s)
	}
}

func (s *OC_NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_NumberLiteral(s)
	}
}

func (p *TTQLParser) OC_NumberLiteral() (localctx IOC_NumberLiteralContext) {
	this := p
	_ = this

	localctx = NewOC_NumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, TTQLParserRULE_oC_NumberLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1525)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TTQLParserExponentDecimalReal, TTQLParserRegularDecimalReal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1523)
			p.OC_DoubleLiteral()
		}

	case TTQLParserHexInteger, TTQLParserDecimalInteger, TTQLParserOctalInteger:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1524)
			p.OC_IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOC_IntegerLiteralContext is an interface to support dynamic dispatch.
type IOC_IntegerLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_IntegerLiteralContext differentiates from other interfaces.
	IsOC_IntegerLiteralContext()
}

type OC_IntegerLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_IntegerLiteralContext() *OC_IntegerLiteralContext {
	var p = new(OC_IntegerLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_IntegerLiteral
	return p
}

func (*OC_IntegerLiteralContext) IsOC_IntegerLiteralContext() {}

func NewOC_IntegerLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_IntegerLiteralContext {
	var p = new(OC_IntegerLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_IntegerLiteral

	return p
}

func (s *OC_IntegerLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_IntegerLiteralContext) HexInteger() antlr.TerminalNode {
	return s.GetToken(TTQLParserHexInteger, 0)
}

func (s *OC_IntegerLiteralContext) OctalInteger() antlr.TerminalNode {
	return s.GetToken(TTQLParserOctalInteger, 0)
}

func (s *OC_IntegerLiteralContext) DecimalInteger() antlr.TerminalNode {
	return s.GetToken(TTQLParserDecimalInteger, 0)
}

func (s *OC_IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_IntegerLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_IntegerLiteral(s)
	}
}

func (s *OC_IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_IntegerLiteral(s)
	}
}

func (p *TTQLParser) OC_IntegerLiteral() (localctx IOC_IntegerLiteralContext) {
	this := p
	_ = this

	localctx = NewOC_IntegerLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, TTQLParserRULE_oC_IntegerLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1527)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-100)) & ^0x3f) == 0 && ((int64(1)<<(_la-100))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOC_DoubleLiteralContext is an interface to support dynamic dispatch.
type IOC_DoubleLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_DoubleLiteralContext differentiates from other interfaces.
	IsOC_DoubleLiteralContext()
}

type OC_DoubleLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_DoubleLiteralContext() *OC_DoubleLiteralContext {
	var p = new(OC_DoubleLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_DoubleLiteral
	return p
}

func (*OC_DoubleLiteralContext) IsOC_DoubleLiteralContext() {}

func NewOC_DoubleLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_DoubleLiteralContext {
	var p = new(OC_DoubleLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_DoubleLiteral

	return p
}

func (s *OC_DoubleLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_DoubleLiteralContext) ExponentDecimalReal() antlr.TerminalNode {
	return s.GetToken(TTQLParserExponentDecimalReal, 0)
}

func (s *OC_DoubleLiteralContext) RegularDecimalReal() antlr.TerminalNode {
	return s.GetToken(TTQLParserRegularDecimalReal, 0)
}

func (s *OC_DoubleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_DoubleLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_DoubleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_DoubleLiteral(s)
	}
}

func (s *OC_DoubleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_DoubleLiteral(s)
	}
}

func (p *TTQLParser) OC_DoubleLiteral() (localctx IOC_DoubleLiteralContext) {
	this := p
	_ = this

	localctx = NewOC_DoubleLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, TTQLParserRULE_oC_DoubleLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1529)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TTQLParserExponentDecimalReal || _la == TTQLParserRegularDecimalReal) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOC_ListLiteralContext is an interface to support dynamic dispatch.
type IOC_ListLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ListLiteralContext differentiates from other interfaces.
	IsOC_ListLiteralContext()
}

type OC_ListLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ListLiteralContext() *OC_ListLiteralContext {
	var p = new(OC_ListLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ListLiteral
	return p
}

func (*OC_ListLiteralContext) IsOC_ListLiteralContext() {}

func NewOC_ListLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ListLiteralContext {
	var p = new(OC_ListLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ListLiteral

	return p
}

func (s *OC_ListLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ListLiteralContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_ListLiteralContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_ListLiteralContext) AllOC_Expression() []IOC_ExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_ExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_ExpressionContext); ok {
			tst[i] = t.(IOC_ExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_ListLiteralContext) OC_Expression(i int) IOC_ExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_ListLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ListLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ListLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ListLiteral(s)
	}
}

func (s *OC_ListLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ListLiteral(s)
	}
}

func (p *TTQLParser) OC_ListLiteral() (localctx IOC_ListLiteralContext) {
	this := p
	_ = this

	localctx = NewOC_ListLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, TTQLParserRULE_oC_ListLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1531)
		p.Match(TTQLParserT__7)
	}
	p.SetState(1533)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1532)
			p.Match(TTQLParserSP)
		}

	}
	p.SetState(1552)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4503599712043328) != 0 || (int64((_la-81)) & ^0x3f) == 0 && ((int64(1)<<(_la-81))&343051394343361) != 0 {
		{
			p.SetState(1535)
			p.OC_Expression()
		}
		p.SetState(1537)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1536)
				p.Match(TTQLParserSP)
			}

		}
		p.SetState(1549)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == TTQLParserT__1 {
			{
				p.SetState(1539)
				p.Match(TTQLParserT__1)
			}
			p.SetState(1541)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(1540)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(1543)
				p.OC_Expression()
			}
			p.SetState(1545)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(1544)
					p.Match(TTQLParserSP)
				}

			}

			p.SetState(1551)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1554)
		p.Match(TTQLParserT__8)
	}

	return localctx
}

// IOC_MapLiteralContext is an interface to support dynamic dispatch.
type IOC_MapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_MapLiteralContext differentiates from other interfaces.
	IsOC_MapLiteralContext()
}

type OC_MapLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_MapLiteralContext() *OC_MapLiteralContext {
	var p = new(OC_MapLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_MapLiteral
	return p
}

func (*OC_MapLiteralContext) IsOC_MapLiteralContext() {}

func NewOC_MapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_MapLiteralContext {
	var p = new(OC_MapLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_MapLiteral

	return p
}

func (s *OC_MapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_MapLiteralContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(TTQLParserSP)
}

func (s *OC_MapLiteralContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(TTQLParserSP, i)
}

func (s *OC_MapLiteralContext) AllOC_PropertyKeyName() []IOC_PropertyKeyNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_PropertyKeyNameContext); ok {
			len++
		}
	}

	tst := make([]IOC_PropertyKeyNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_PropertyKeyNameContext); ok {
			tst[i] = t.(IOC_PropertyKeyNameContext)
			i++
		}
	}

	return tst
}

func (s *OC_MapLiteralContext) OC_PropertyKeyName(i int) IOC_PropertyKeyNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_PropertyKeyNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_PropertyKeyNameContext)
}

func (s *OC_MapLiteralContext) AllOC_Expression() []IOC_ExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOC_ExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOC_ExpressionContext); ok {
			tst[i] = t.(IOC_ExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OC_MapLiteralContext) OC_Expression(i int) IOC_ExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_MapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_MapLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_MapLiteral(s)
	}
}

func (s *OC_MapLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_MapLiteral(s)
	}
}

func (p *TTQLParser) OC_MapLiteral() (localctx IOC_MapLiteralContext) {
	this := p
	_ = this

	localctx = NewOC_MapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, TTQLParserRULE_oC_MapLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1556)
		p.Match(TTQLParserT__23)
	}
	p.SetState(1558)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == TTQLParserSP {
		{
			p.SetState(1557)
			p.Match(TTQLParserSP)
		}

	}
	p.SetState(1593)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2251799813685248) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6917810347998969857) != 0 {
		{
			p.SetState(1560)
			p.OC_PropertyKeyName()
		}
		p.SetState(1562)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1561)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1564)
			p.Match(TTQLParserT__9)
		}
		p.SetState(1566)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1565)
				p.Match(TTQLParserSP)
			}

		}
		{
			p.SetState(1568)
			p.OC_Expression()
		}
		p.SetState(1570)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == TTQLParserSP {
			{
				p.SetState(1569)
				p.Match(TTQLParserSP)
			}

		}
		p.SetState(1590)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == TTQLParserT__1 {
			{
				p.SetState(1572)
				p.Match(TTQLParserT__1)
			}
			p.SetState(1574)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(1573)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(1576)
				p.OC_PropertyKeyName()
			}
			p.SetState(1578)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(1577)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(1580)
				p.Match(TTQLParserT__9)
			}
			p.SetState(1582)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(1581)
					p.Match(TTQLParserSP)
				}

			}
			{
				p.SetState(1584)
				p.OC_Expression()
			}
			p.SetState(1586)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == TTQLParserSP {
				{
					p.SetState(1585)
					p.Match(TTQLParserSP)
				}

			}

			p.SetState(1592)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1595)
		p.Match(TTQLParserT__24)
	}

	return localctx
}

// IOC_PropertyKeyNameContext is an interface to support dynamic dispatch.
type IOC_PropertyKeyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PropertyKeyNameContext differentiates from other interfaces.
	IsOC_PropertyKeyNameContext()
}

type OC_PropertyKeyNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PropertyKeyNameContext() *OC_PropertyKeyNameContext {
	var p = new(OC_PropertyKeyNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_PropertyKeyName
	return p
}

func (*OC_PropertyKeyNameContext) IsOC_PropertyKeyNameContext() {}

func NewOC_PropertyKeyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PropertyKeyNameContext {
	var p = new(OC_PropertyKeyNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_PropertyKeyName

	return p
}

func (s *OC_PropertyKeyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PropertyKeyNameContext) OC_SchemaName() IOC_SchemaNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SchemaNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SchemaNameContext)
}

func (s *OC_PropertyKeyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PropertyKeyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_PropertyKeyNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_PropertyKeyName(s)
	}
}

func (s *OC_PropertyKeyNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_PropertyKeyName(s)
	}
}

func (p *TTQLParser) OC_PropertyKeyName() (localctx IOC_PropertyKeyNameContext) {
	this := p
	_ = this

	localctx = NewOC_PropertyKeyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, TTQLParserRULE_oC_PropertyKeyName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1597)
		p.OC_SchemaName()
	}

	return localctx
}

// IOC_ParameterContext is an interface to support dynamic dispatch.
type IOC_ParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ParameterContext differentiates from other interfaces.
	IsOC_ParameterContext()
}

type OC_ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ParameterContext() *OC_ParameterContext {
	var p = new(OC_ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Parameter
	return p
}

func (*OC_ParameterContext) IsOC_ParameterContext() {}

func NewOC_ParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ParameterContext {
	var p = new(OC_ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Parameter

	return p
}

func (s *OC_ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ParameterContext) OC_SymbolicName() IOC_SymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SymbolicNameContext)
}

func (s *OC_ParameterContext) DecimalInteger() antlr.TerminalNode {
	return s.GetToken(TTQLParserDecimalInteger, 0)
}

func (s *OC_ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Parameter(s)
	}
}

func (s *OC_ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Parameter(s)
	}
}

func (p *TTQLParser) OC_Parameter() (localctx IOC_ParameterContext) {
	this := p
	_ = this

	localctx = NewOC_ParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, TTQLParserRULE_oC_Parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1599)
		p.Match(TTQLParserT__25)
	}
	p.SetState(1602)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TTQLParserCOUNT, TTQLParserANY, TTQLParserNONE, TTQLParserSINGLE, TTQLParserHexLetter, TTQLParserFILTER, TTQLParserEXTRACT, TTQLParserUnescapedSymbolicName, TTQLParserEscapedSymbolicName:
		{
			p.SetState(1600)
			p.OC_SymbolicName()
		}

	case TTQLParserDecimalInteger:
		{
			p.SetState(1601)
			p.Match(TTQLParserDecimalInteger)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOC_SchemaNameContext is an interface to support dynamic dispatch.
type IOC_SchemaNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SchemaNameContext differentiates from other interfaces.
	IsOC_SchemaNameContext()
}

type OC_SchemaNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SchemaNameContext() *OC_SchemaNameContext {
	var p = new(OC_SchemaNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_SchemaName
	return p
}

func (*OC_SchemaNameContext) IsOC_SchemaNameContext() {}

func NewOC_SchemaNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SchemaNameContext {
	var p = new(OC_SchemaNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_SchemaName

	return p
}

func (s *OC_SchemaNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SchemaNameContext) OC_SymbolicName() IOC_SymbolicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_SymbolicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_SymbolicNameContext)
}

func (s *OC_SchemaNameContext) OC_ReservedWord() IOC_ReservedWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOC_ReservedWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOC_ReservedWordContext)
}

func (s *OC_SchemaNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SchemaNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_SchemaNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_SchemaName(s)
	}
}

func (s *OC_SchemaNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_SchemaName(s)
	}
}

func (p *TTQLParser) OC_SchemaName() (localctx IOC_SchemaNameContext) {
	this := p
	_ = this

	localctx = NewOC_SchemaNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, TTQLParserRULE_oC_SchemaName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1606)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case TTQLParserCOUNT, TTQLParserANY, TTQLParserNONE, TTQLParserSINGLE, TTQLParserHexLetter, TTQLParserFILTER, TTQLParserEXTRACT, TTQLParserUnescapedSymbolicName, TTQLParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1604)
			p.OC_SymbolicName()
		}

	case TTQLParserUNION, TTQLParserALL, TTQLParserOPTIONAL, TTQLParserMATCH, TTQLParserUNWIND, TTQLParserAS, TTQLParserMERGE, TTQLParserON, TTQLParserCREATE, TTQLParserSET, TTQLParserDETACH, TTQLParserDELETE, TTQLParserREMOVE, TTQLParserWITH, TTQLParserRETURN, TTQLParserDISTINCT, TTQLParserORDER, TTQLParserBY, TTQLParserL_SKIP, TTQLParserLIMIT, TTQLParserASCENDING, TTQLParserASC, TTQLParserDESCENDING, TTQLParserDESC, TTQLParserWHERE, TTQLParserOR, TTQLParserXOR, TTQLParserAND, TTQLParserNOT, TTQLParserSTARTS, TTQLParserENDS, TTQLParserCONTAINS, TTQLParserIN, TTQLParserIS, TTQLParserNULL, TTQLParserCASE, TTQLParserELSE, TTQLParserEND, TTQLParserWHEN, TTQLParserTHEN, TTQLParserEXISTS, TTQLParserTRUE, TTQLParserFALSE, TTQLParserCONSTRAINT, TTQLParserDO, TTQLParserFOR, TTQLParserREQUIRE, TTQLParserUNIQUE, TTQLParserMANDATORY, TTQLParserSCALAR, TTQLParserOF, TTQLParserADD, TTQLParserDROP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1605)
			p.OC_ReservedWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOC_ReservedWordContext is an interface to support dynamic dispatch.
type IOC_ReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ReservedWordContext differentiates from other interfaces.
	IsOC_ReservedWordContext()
}

type OC_ReservedWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ReservedWordContext() *OC_ReservedWordContext {
	var p = new(OC_ReservedWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_ReservedWord
	return p
}

func (*OC_ReservedWordContext) IsOC_ReservedWordContext() {}

func NewOC_ReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ReservedWordContext {
	var p = new(OC_ReservedWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_ReservedWord

	return p
}

func (s *OC_ReservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ReservedWordContext) ALL() antlr.TerminalNode {
	return s.GetToken(TTQLParserALL, 0)
}

func (s *OC_ReservedWordContext) ASC() antlr.TerminalNode {
	return s.GetToken(TTQLParserASC, 0)
}

func (s *OC_ReservedWordContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(TTQLParserASCENDING, 0)
}

func (s *OC_ReservedWordContext) BY() antlr.TerminalNode {
	return s.GetToken(TTQLParserBY, 0)
}

func (s *OC_ReservedWordContext) CREATE() antlr.TerminalNode {
	return s.GetToken(TTQLParserCREATE, 0)
}

func (s *OC_ReservedWordContext) DELETE() antlr.TerminalNode {
	return s.GetToken(TTQLParserDELETE, 0)
}

func (s *OC_ReservedWordContext) DESC() antlr.TerminalNode {
	return s.GetToken(TTQLParserDESC, 0)
}

func (s *OC_ReservedWordContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(TTQLParserDESCENDING, 0)
}

func (s *OC_ReservedWordContext) DETACH() antlr.TerminalNode {
	return s.GetToken(TTQLParserDETACH, 0)
}

func (s *OC_ReservedWordContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(TTQLParserEXISTS, 0)
}

func (s *OC_ReservedWordContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(TTQLParserLIMIT, 0)
}

func (s *OC_ReservedWordContext) MATCH() antlr.TerminalNode {
	return s.GetToken(TTQLParserMATCH, 0)
}

func (s *OC_ReservedWordContext) MERGE() antlr.TerminalNode {
	return s.GetToken(TTQLParserMERGE, 0)
}

func (s *OC_ReservedWordContext) ON() antlr.TerminalNode {
	return s.GetToken(TTQLParserON, 0)
}

func (s *OC_ReservedWordContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(TTQLParserOPTIONAL, 0)
}

func (s *OC_ReservedWordContext) ORDER() antlr.TerminalNode {
	return s.GetToken(TTQLParserORDER, 0)
}

func (s *OC_ReservedWordContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(TTQLParserREMOVE, 0)
}

func (s *OC_ReservedWordContext) RETURN() antlr.TerminalNode {
	return s.GetToken(TTQLParserRETURN, 0)
}

func (s *OC_ReservedWordContext) SET() antlr.TerminalNode {
	return s.GetToken(TTQLParserSET, 0)
}

func (s *OC_ReservedWordContext) L_SKIP() antlr.TerminalNode {
	return s.GetToken(TTQLParserL_SKIP, 0)
}

func (s *OC_ReservedWordContext) WHERE() antlr.TerminalNode {
	return s.GetToken(TTQLParserWHERE, 0)
}

func (s *OC_ReservedWordContext) WITH() antlr.TerminalNode {
	return s.GetToken(TTQLParserWITH, 0)
}

func (s *OC_ReservedWordContext) UNION() antlr.TerminalNode {
	return s.GetToken(TTQLParserUNION, 0)
}

func (s *OC_ReservedWordContext) UNWIND() antlr.TerminalNode {
	return s.GetToken(TTQLParserUNWIND, 0)
}

func (s *OC_ReservedWordContext) AND() antlr.TerminalNode {
	return s.GetToken(TTQLParserAND, 0)
}

func (s *OC_ReservedWordContext) AS() antlr.TerminalNode {
	return s.GetToken(TTQLParserAS, 0)
}

func (s *OC_ReservedWordContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(TTQLParserCONTAINS, 0)
}

func (s *OC_ReservedWordContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(TTQLParserDISTINCT, 0)
}

func (s *OC_ReservedWordContext) ENDS() antlr.TerminalNode {
	return s.GetToken(TTQLParserENDS, 0)
}

func (s *OC_ReservedWordContext) IN() antlr.TerminalNode {
	return s.GetToken(TTQLParserIN, 0)
}

func (s *OC_ReservedWordContext) IS() antlr.TerminalNode {
	return s.GetToken(TTQLParserIS, 0)
}

func (s *OC_ReservedWordContext) NOT() antlr.TerminalNode {
	return s.GetToken(TTQLParserNOT, 0)
}

func (s *OC_ReservedWordContext) OR() antlr.TerminalNode {
	return s.GetToken(TTQLParserOR, 0)
}

func (s *OC_ReservedWordContext) STARTS() antlr.TerminalNode {
	return s.GetToken(TTQLParserSTARTS, 0)
}

func (s *OC_ReservedWordContext) XOR() antlr.TerminalNode {
	return s.GetToken(TTQLParserXOR, 0)
}

func (s *OC_ReservedWordContext) FALSE() antlr.TerminalNode {
	return s.GetToken(TTQLParserFALSE, 0)
}

func (s *OC_ReservedWordContext) TRUE() antlr.TerminalNode {
	return s.GetToken(TTQLParserTRUE, 0)
}

func (s *OC_ReservedWordContext) NULL() antlr.TerminalNode {
	return s.GetToken(TTQLParserNULL, 0)
}

func (s *OC_ReservedWordContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(TTQLParserCONSTRAINT, 0)
}

func (s *OC_ReservedWordContext) DO() antlr.TerminalNode {
	return s.GetToken(TTQLParserDO, 0)
}

func (s *OC_ReservedWordContext) FOR() antlr.TerminalNode {
	return s.GetToken(TTQLParserFOR, 0)
}

func (s *OC_ReservedWordContext) REQUIRE() antlr.TerminalNode {
	return s.GetToken(TTQLParserREQUIRE, 0)
}

func (s *OC_ReservedWordContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(TTQLParserUNIQUE, 0)
}

func (s *OC_ReservedWordContext) CASE() antlr.TerminalNode {
	return s.GetToken(TTQLParserCASE, 0)
}

func (s *OC_ReservedWordContext) WHEN() antlr.TerminalNode {
	return s.GetToken(TTQLParserWHEN, 0)
}

func (s *OC_ReservedWordContext) THEN() antlr.TerminalNode {
	return s.GetToken(TTQLParserTHEN, 0)
}

func (s *OC_ReservedWordContext) ELSE() antlr.TerminalNode {
	return s.GetToken(TTQLParserELSE, 0)
}

func (s *OC_ReservedWordContext) END() antlr.TerminalNode {
	return s.GetToken(TTQLParserEND, 0)
}

func (s *OC_ReservedWordContext) MANDATORY() antlr.TerminalNode {
	return s.GetToken(TTQLParserMANDATORY, 0)
}

func (s *OC_ReservedWordContext) SCALAR() antlr.TerminalNode {
	return s.GetToken(TTQLParserSCALAR, 0)
}

func (s *OC_ReservedWordContext) OF() antlr.TerminalNode {
	return s.GetToken(TTQLParserOF, 0)
}

func (s *OC_ReservedWordContext) ADD() antlr.TerminalNode {
	return s.GetToken(TTQLParserADD, 0)
}

func (s *OC_ReservedWordContext) DROP() antlr.TerminalNode {
	return s.GetToken(TTQLParserDROP, 0)
}

func (s *OC_ReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_ReservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_ReservedWord(s)
	}
}

func (s *OC_ReservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_ReservedWord(s)
	}
}

func (p *TTQLParser) OC_ReservedWord() (localctx IOC_ReservedWordContext) {
	this := p
	_ = this

	localctx = NewOC_ReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, TTQLParserRULE_oC_ReservedWord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1608)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2251799813685248) != 0 || (int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&287948916471627775) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOC_SymbolicNameContext is an interface to support dynamic dispatch.
type IOC_SymbolicNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SymbolicNameContext differentiates from other interfaces.
	IsOC_SymbolicNameContext()
}

type OC_SymbolicNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SymbolicNameContext() *OC_SymbolicNameContext {
	var p = new(OC_SymbolicNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_SymbolicName
	return p
}

func (*OC_SymbolicNameContext) IsOC_SymbolicNameContext() {}

func NewOC_SymbolicNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SymbolicNameContext {
	var p = new(OC_SymbolicNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_SymbolicName

	return p
}

func (s *OC_SymbolicNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SymbolicNameContext) UnescapedSymbolicName() antlr.TerminalNode {
	return s.GetToken(TTQLParserUnescapedSymbolicName, 0)
}

func (s *OC_SymbolicNameContext) EscapedSymbolicName() antlr.TerminalNode {
	return s.GetToken(TTQLParserEscapedSymbolicName, 0)
}

func (s *OC_SymbolicNameContext) HexLetter() antlr.TerminalNode {
	return s.GetToken(TTQLParserHexLetter, 0)
}

func (s *OC_SymbolicNameContext) COUNT() antlr.TerminalNode {
	return s.GetToken(TTQLParserCOUNT, 0)
}

func (s *OC_SymbolicNameContext) FILTER() antlr.TerminalNode {
	return s.GetToken(TTQLParserFILTER, 0)
}

func (s *OC_SymbolicNameContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(TTQLParserEXTRACT, 0)
}

func (s *OC_SymbolicNameContext) ANY() antlr.TerminalNode {
	return s.GetToken(TTQLParserANY, 0)
}

func (s *OC_SymbolicNameContext) NONE() antlr.TerminalNode {
	return s.GetToken(TTQLParserNONE, 0)
}

func (s *OC_SymbolicNameContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(TTQLParserSINGLE, 0)
}

func (s *OC_SymbolicNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SymbolicNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_SymbolicNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_SymbolicName(s)
	}
}

func (s *OC_SymbolicNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_SymbolicName(s)
	}
}

func (p *TTQLParser) OC_SymbolicName() (localctx IOC_SymbolicNameContext) {
	this := p
	_ = this

	localctx = NewOC_SymbolicNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, TTQLParserRULE_oC_SymbolicName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1610)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&2680059625921) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOC_LeftArrowHeadContext is an interface to support dynamic dispatch.
type IOC_LeftArrowHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_LeftArrowHeadContext differentiates from other interfaces.
	IsOC_LeftArrowHeadContext()
}

type OC_LeftArrowHeadContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_LeftArrowHeadContext() *OC_LeftArrowHeadContext {
	var p = new(OC_LeftArrowHeadContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_LeftArrowHead
	return p
}

func (*OC_LeftArrowHeadContext) IsOC_LeftArrowHeadContext() {}

func NewOC_LeftArrowHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_LeftArrowHeadContext {
	var p = new(OC_LeftArrowHeadContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_LeftArrowHead

	return p
}

func (s *OC_LeftArrowHeadContext) GetParser() antlr.Parser { return s.parser }
func (s *OC_LeftArrowHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_LeftArrowHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_LeftArrowHeadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_LeftArrowHead(s)
	}
}

func (s *OC_LeftArrowHeadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_LeftArrowHead(s)
	}
}

func (p *TTQLParser) OC_LeftArrowHead() (localctx IOC_LeftArrowHeadContext) {
	this := p
	_ = this

	localctx = NewOC_LeftArrowHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, TTQLParserRULE_oC_LeftArrowHead)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1612)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2013282304) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOC_RightArrowHeadContext is an interface to support dynamic dispatch.
type IOC_RightArrowHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RightArrowHeadContext differentiates from other interfaces.
	IsOC_RightArrowHeadContext()
}

type OC_RightArrowHeadContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RightArrowHeadContext() *OC_RightArrowHeadContext {
	var p = new(OC_RightArrowHeadContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_RightArrowHead
	return p
}

func (*OC_RightArrowHeadContext) IsOC_RightArrowHeadContext() {}

func NewOC_RightArrowHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RightArrowHeadContext {
	var p = new(OC_RightArrowHeadContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_RightArrowHead

	return p
}

func (s *OC_RightArrowHeadContext) GetParser() antlr.Parser { return s.parser }
func (s *OC_RightArrowHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RightArrowHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_RightArrowHeadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_RightArrowHead(s)
	}
}

func (s *OC_RightArrowHeadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_RightArrowHead(s)
	}
}

func (p *TTQLParser) OC_RightArrowHead() (localctx IOC_RightArrowHeadContext) {
	this := p
	_ = this

	localctx = NewOC_RightArrowHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, TTQLParserRULE_oC_RightArrowHead)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1614)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&32212287488) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOC_DashContext is an interface to support dynamic dispatch.
type IOC_DashContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_DashContext differentiates from other interfaces.
	IsOC_DashContext()
}

type OC_DashContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_DashContext() *OC_DashContext {
	var p = new(OC_DashContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = TTQLParserRULE_oC_Dash
	return p
}

func (*OC_DashContext) IsOC_DashContext() {}

func NewOC_DashContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_DashContext {
	var p = new(OC_DashContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = TTQLParserRULE_oC_Dash

	return p
}

func (s *OC_DashContext) GetParser() antlr.Parser { return s.parser }
func (s *OC_DashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_DashContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OC_DashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.EnterOC_Dash(s)
	}
}

func (s *OC_DashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TTQLListener); ok {
		listenerT.ExitOC_Dash(s)
	}
}

func (p *TTQLParser) OC_Dash() (localctx IOC_DashContext) {
	this := p
	_ = this

	localctx = NewOC_DashContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, TTQLParserRULE_oC_Dash)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1616)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&70334384963584) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}
