add properties to a group of existing nodes:
  MATCH (n:Node)
  SET n += { properties_Risc_1_value: 60, properties_Risc_1_start: 10, properties_Risc_1_end: 12}
  RETURN n

  Query properties of a node n which start with a certain string: 
    MATCH (n)
    WHERE ID(n) = 1 AND ANY(x IN keys(n) WHERE x STARTS WITH 'properties_Risc_' AND n[x] > 10)
    RETURN n
  
  Query nodes n with properties which start with a certain string: 
    MATCH (n)
    WHERE ANY(x IN keys(n) WHERE x STARTS WITH 'properties_Risc_' AND n[x] > 10)
    RETURN n
 
  Query nodes which contain a certain property and fulfill conditions on it 
    query:  FROM 1 TO 4 Match (n) where n.score IS NOT NULL AND n.score > 20 return n.score  | note: FROM is inclusive, TO is exclusive (from,to]
 

######################################
######################################
## Anfragen die ich umsetzen möchte ## 
######################################
######################################

- note: ALLE Anfragen starten mit von X bis Y (setzen einen Zeitrahmen)
1. gib mir alle knoten n zurück   
2. gib mir alle knoten id zurück
3. gib mir alle knoten n:label zurück
4. gib mir alle  

  MATCH (c:City)
  WHERE c.name = "London"   // query all nodes, query properties name and population_size, return c.population_size
  RETURN c.population_size;

  MATCH (city:City)-[:IN]-(country:Country)     // query resp all nodes, query city.name and country.name properties, throw out nodes which do not fit the condition
  WHERE city.name = "London"                    // return    
  RETURN country.name;

  MATCH (c:City)   // query resp nodes, query all properties of these nodes and merge results
  RETURN c;

  MATCH (c)       // same as before
  WHERE c:City
  RETURN c;

  MATCH (c:City:Country)    // just need to query all properties and merge results
  RETURN c;

  MATCH (c)            // i think i prefere the version before. Maybe only use WHERE clause for property stuff. Therefore use property stuff ONLY in the WHERE clause
  WHERE c:City AND c:Country
  RETURN c;

######################################
############## ONLY NEO  #############
######################################

 
######################################
########## timetravelDB  #############
######################################

 

######################################
######################################







Problem: Wie kann ich die einzelnen geflatteten properties abfragen? Zum beispiel wenn ich von einer speziellen property die mit
Property1_property1.1_ anfängt alle properties haben möchte die um 10:00 oder später beginnen, dann brauche ich alle properties mit
Property1_property1.1_{ID}_begin und muss diese auf >= 10:00 checken. Wenn das Ergebnis true ist, will ich aber für alle diese properties
den value von der Property Property1_property1.1_{ID}_value zurückgeben. Und das für jeden wert der für {ID} existiert.
1. Ansatz: regular expressions 
  Ich glaube es ist nicht möglich regular expressions in einem property name zu benutzen. Aber ich habe es auf stackoverflow gefragt: 
  https://stackoverflow.com/questions/75042118/regular-expression-on-the-string-of-a-property-name-in-cypher
2. liste speichern mit IDs für jede property. Also wenn ich eine Property "Mainboard.Components.CPU.." habe, dann speichere ich in einer
  property "Mainboard.Components.CPU.IDs: idlist []string" eine liste von ids ab (am besten aufsteigend). zb:
  idlist []string = ["1","2","3","4",..]. dann kann ich die Property abfragen, und weiß, dass für jede dieser IDs eine property existiert:

  Property1_property1.1_1_value  Property1_property1.1_1_start Property1_property1.1_1_end 
  Property1_property1.1_2_value  Property1_property1.1_2_start Property1_property1.1_2_end
  Property1_property1.1_3_value  Property1_property1.1_3_start Property1_property1.1_3_end
  Property1_property1.1_4_value  Property1_property1.1_4_start Property1_property1.1_4_end
  ...                            ...                           ...

  existieren alle. aufgefallenes problem: jeder knoten hat eigene Properties. ist das überhaupt möglich? oder brauchen die dann alle
  ein eigenes label? das wäre ziemlicher overhead
 


# queries to implement:
- question: hide shallow or make it expilicit. ?
  - hiding it would be better 
  - hide it where possible
  - use it where necessary
- Shallow 
  - get all nodes (of a type)
  - get property names
- Not Shallow
  - path queries, other graph pattern queries
    - not so important maybe because nothing changes
      -> not so sure about this. the graph becomes lighter so 
         it might be faster   
  - get all properties of a node
  - get one property of a node
  - get all nodes (of a type)
  - all operations which contain property values



##  Questions to solve: 

Only neo4j example:

  node: 
    {
      ...
      "properties": {
        "score": 34,
        "name": "Andy"
      }
    }


  query:  Match (n) where n.score IS NOT NULL AND n.score > 20 return n.score

      - das gibt nur einen einzelnen Property value zurück: 34


Annahme TimeTravelDb node:
  {
    ...
    "properties": {
      "score": timeseries: [{0,34},{1,32},{2,35}, {3,18}, ..]   | mit {time,value} 
      "name": "Andy"
    }
  }

  query:  FROM 1 TO 4 Match (n) where n.score IS NOT NULL AND n.score > 20 return n.score  | note: FROM is inclusive, TO is exclusive (from,to]

    - jetzt hätte ich also zwei werte auf die das zutreffen würde: {1,32} & {2,35}
      - what to do ? 
        - [X] möglichkeit 1: nichts zurückgeben weil die Bedingung nicht für alle Werte in dem Zeitraum gilt 
        - [ ] möglichkeit 2: nur Werte zurückgeben für welche die Bedingung in dem Zeitraum gilt  (am ehesten das. FROM, TO sollte ich einfach als zusatzbedinung sehen)
            -> FROM & TO könnten genauso in der WHERE clause stehen. Dann würde das zurückgegeben für das alle bedingungen wahr sind und nicht gleich nichts.
               Die Bedingungen sollten auf einzelne Werte in der time-series abgebildet werden, nicht auf die time-series als Wert an sich
            -> möglichkeit 1 lässt sich immernoch folgendermaßen erreichen:
              -    
               

Alle elemente einer liste zurückgeben die bedingung erfüllen 
 
  query:  MATCH (n:Test)  UNWIND n.score AS elem WHERE elem > 100  RETURN elem  |  funktioniert so nicht
  corrected version:  MATCH (n:Test) UNWIND n.score AS elem WITH elem WHERE elem > 100 RETURN elem
        



