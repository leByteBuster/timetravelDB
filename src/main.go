// this adapter allows to read in temporal property graph data in the form of json files generated by the data_generator as nodes
// and into a neo4j database

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"

	"github.com/google/uuid"
	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

type comp struct {
	id        int16
	some_data string
	is_ts     bool
}

type TmpPropVal[T any] struct {
	Start string
	End   string
	Value T
}

func main() {

	// var comp_list = []comp{
	// 	{
	// 		id:        11,
	// 		some_data: "testdata",
	// 		is_ts:     true,
	// 	},
	// 	{
	// 		id:        22,
	// 		some_data: "testdata",
	// 		is_ts:     false,
	// 	},
	// }

	// res, err := load_data(context.Background(), "neo4j://localhost:7687", "neo4j", "rhebo", comp_list)

	graph_nodes, err := loadJsonData("graph_nodes.json")
	graph_edges, err := loadJsonData("graph_edges.json")

	loadGraphNodesIntoNeo4jDatabase(graph_nodes, context.Background(), "neo4j://localhost:7687", "neo4j", "rhebo")
	loadGraphEdgesIntoNeo4jDatabase(graph_edges, context.Background(), "neo4j://localhost:7687", "neo4j", "rhebo")

	if err != nil {
		fmt.Printf("Error: %v", err)
	}
	// fmt.Printf("Result: %v", res)
}

func loadGraphNodesIntoNeo4jDatabase(graph_nodes []map[string]interface{}, ctx context.Context, uri, username, password string) {
	// Connect to the Neo4j database
	driver, err := neo4j.NewDriverWithContext(uri, neo4j.BasicAuth(username, password, ""))
	if err != nil {
		fmt.Println(err)
		return
	}
	defer driver.Close(ctx)

	session := driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	defer session.Close(ctx)

	// Loop through the data array
	for _, node := range graph_nodes {

		// Build the CREATE query
		// primaryQueryNode := `CREATE (:Node {`
		queryFlat := `CREATE (:Node {`

		// the primaryQueryFragment repesents all the properties of node n
		// the secondaryQuery represents all nodes which represent values of the properties of node n which are
		// generated in the process
		//primaryQueryFragments, secondaryQuery := generateNeo4jNodeProperties(node)

		primaryQueryFragmentsFlat := generateNeo4jFlatProperties(node)
		// for _, fragment := range primaryQueryFragments {
		// 	primaryQueryNode += fragment
		// }
		for _, fragment := range primaryQueryFragmentsFlat {
			queryFlat += fragment
		}
		// primaryQueryNode = primaryQueryNode[:len(primaryQueryNode)-2] + `})`
		// secondaryQuery = secondaryQuery[:len(secondaryQuery)-2]

		queryFlat = queryFlat[:len(queryFlat)-2] + `})`

		// nodeQuery := primaryQueryNode + ", " + secondaryQuery

		// fmt.Printf("\nOuter Query Part: %v\n", primaryQueryNode)
		// fmt.Printf("\nInner Query Part: %v\n", secondaryQuery)
		fmt.Printf("\nFlat Query: %v\n", queryFlat)

		//res, err := session.Run(ctx, `CREATE (:Node {end: "2011-05-14 22:20:58 +0200 CEST", label: "Server", nodeid: 0, properties_components_cpu_0_start: "1993-06-19 11:22:43 +0200 CEST", properties_components_cpu_0_end: "1987-08-03 13:39:26 +0200 CEST", properties_components_cpu_0_value: "XPyXgdBG", properties_components_ram_0_start: "1991-08-29 06:30:37 +0200 CEST", properties_components_ram_0_end: "2008-08-27 19:18:41 +0200 CEST", properties_components_ram_0_value: "fNQLV", properties_IP_0_start: "1977-09-09 12:52:29 +0100 CET", properties_IP_0_end: "1983-08-09 00:46:50 +0200 CEST", properties_IP_0_value: "izX", properties_Risc_0_start: "2010-01-03 11:14:59 +0100 CET", properties_Risc_0_end: "2011-04-14 10:15:46 +0200 CEST", properties_Risc_0_value: 18, start: "2010-12-18 21:09:25 +0100 CET"})`,
		//	map[string]interface{}{})
		// Execute the CREATE query
		res, err := session.Run(ctx, queryFlat, map[string]interface{}{})
		if err != nil {
			fmt.Println(err)
			return
		}
		fmt.Println("Result: ", res)
	}
}

func loadGraphEdgesIntoNeo4jDatabase(graph_edges []map[string]interface{}, ctx context.Context, uri, username, password string) {
	// Connect to the Neo4j database
	driver, err := neo4j.NewDriverWithContext(uri, neo4j.BasicAuth(username, password, ""))
	if err != nil {
		fmt.Println(err)
		return
	}
	defer driver.Close(ctx)

	session := driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	defer session.Close(ctx)

	// Loop through the data array
	for _, edge := range graph_edges {

		from := edge["from"]
		to := edge["to"]

		// maybe make a copy forst to keep the original ?  or is the map copied into this funciton anyways ?
		delete(edge, "from")
		delete(edge, "to")

		queryPrefix := `MATCH (a),(b) WHERE a.nodeid = $from AND b.nodeid = $to CREATE (a)-[r:Relation {`
		querySuffix := `}]->(b)`

		// the primaryQueryFragment repesents all the properties of node n
		// the secondaryQuery represents all nodes which represent values of the properties of node n which are
		// generated in the process
		//primaryQueryFragments, secondaryQuery := generateNeo4jNodeProperties(node)

		neo4jEdgeProperties := generateNeo4jFlatProperties(edge)

		queryProperties := ""

		for _, fragment := range neo4jEdgeProperties {
			queryProperties += fragment
		}

		queryProperties = queryProperties[:len(queryProperties)-2]

		edgeQuery := queryPrefix + queryProperties + querySuffix

		fmt.Printf("\nEdge Query: %v\n", edgeQuery)
		fmt.Printf("\nFrom: %v\n", from)
		fmt.Printf("\nTo: %v\n", to)

		// res, err := session.Run(ctx, ``,
		//	map[string]interface{}{})
		// Execute the CREATE query
		res, err := session.Run(ctx, edgeQuery, map[string]interface{}{"from": from, "to": to})
		if err != nil {
			fmt.Println(err)
			return
		}
		fmt.Println("Result: ", res)
	}
}

// the first return value repesents all the properties of node n
// the second return value represents all nodes which represent values of the properties of node n which are generated in the process
func generateNeo4jNodeProperties(property map[string]interface{}) ([]string, string) {
	queryBaseFragment := ""
	queryPropertyFragments := make([]string, 0)
	queryFragmentInner := ""
	for key, value := range property {
		switch propertyValue := value.(type) {

		case map[string]interface{}:
			propertyFragments, innerFragment := generateNeo4jNodeProperties(propertyValue)
			for _, fragment := range propertyFragments {
				queryPropertyFragments = append(queryPropertyFragments, queryBaseFragment+key+`_`+fragment)
			}
			queryFragmentInner += innerFragment

		// in the case of string not much has to be done but this case does not occour because the values are always lists of maps/objects
		case string:
			propertyFragment := key + `: "` + propertyValue + `", `
			queryPropertyFragments = append(queryPropertyFragments, propertyFragment)

		// in the case of an array of maps, every map object represents a temporal value of a property in the form of {start:_, end:_, value:_}. Create an
		// query entry for creating an own node for every of these temporal property values
		case []interface{}:

			convertedPropertyValue := convertMaps(propertyValue)

			valueNodeIds := make([]string, 0)

			// iterate over the array of maps and create a value-node query fragment for each of them (for the CREATE query)
			for _, value := range convertedPropertyValue {

				// create an unique node id (maybe later use the internal node id only)
				node_id := uuid.NewString()
				valueNodeIds = append(valueNodeIds, node_id)

				// generate a node vor the temporal value (a temporal value is in the for {start:_, end:_ , value:_ })
				queryFragmentInner += `(:Node { node_id: "` + node_id + `", start: "` + fmt.Sprint(value["Start"]) + `", end: "` + fmt.Sprint(value["End"]) + `", value: `
				switch valueType := value["Value"].(type) {
				case string:
					queryFragmentInner += `"` + valueType + `"}), `
				default:
					queryFragmentInner += fmt.Sprint(valueType) + `}), `
				}

				// add id of the new node as a value to the list of nodes (the list is the value of the property representet by queryFragment)
				// queryFragment +=
			}

			propertyFragment := key + `: [`
			for _, node_id := range valueNodeIds {
				propertyFragment += `"` + node_id + `"`
			}
			propertyFragment += `], `
			queryPropertyFragments = append(queryPropertyFragments, propertyFragment)

		default:
			propertyFragment := key + `: ` + fmt.Sprint(propertyValue) + `, `
			queryPropertyFragments = append(queryPropertyFragments, propertyFragment)
			// An dieser stelle über v iterieren und für jeden eintrag einen Knoten erstellen und mit papa knoten verbinden
			// zu queryFragmentInner hinzufügen
		}
	}
	return queryPropertyFragments, queryFragmentInner
}

// this function not only flattenes the property fields but also the value list of maps representing the according property's value. Every
// entry in the list gets its own property by its index. Like for example:
// mainboard.GPU.temperature.1: {Start:_, End:, Value: }
// mainboard.GPU.temperature.2: {Start:_, End:, Value: }
// mainboard.GPU.temperature.3: {Start:_, End:, Value: }
// instead of "." use "_" as seperator because "." is not allowed
// func generateNeo4jFlatProperties(element map[string]interface{}) (string, string) {
// 	queryFragment := ""
// 	queryFragmentInner := ""
// 	for key, value := range element {
// 		switch v := value.(type) {
// 		case map[string]interface{}:
// 			primaryFragment, secondaryFragment := generateNeo4jFlatProperties(v)
// 			queryFragment += key + "." + primaryFragment
// 			queryFragmentInner += secondaryFragment
// 		case string:
// 			queryFragment += key + ": "
// 			queryFragment += "'" + v + "'"
// 			// An dieser stelle über v iterieren und für jeden eintrag einen Knoten erstellen und mit papa knoten verbinden
// 			// zu queryFragmentInner hinzufügen
// 		default:
// 			queryFragment += key + ": "
// 			queryFragment += fmt.Sprint(v)
// 			// An dieser stelle über v iterieren und für jeden eintrag einen Knoten erstellen und mit papa knoten verbinden
// 			// zu queryFragmentInner hinzufügen
// 		}
// 		queryFragment += ", "
// 	}
// 	return queryFragment, queryFragmentInner
// }

func generateNeo4jFlatProperties(property map[string]interface{}) []string {
	queryBaseFragment := ""
	queryPropertyFragments := make([]string, 0)
	for key, value := range property {
		switch propertyValue := value.(type) {

		case map[string]interface{}:
			propertyFragments := generateNeo4jFlatProperties(propertyValue)
			for _, fragment := range propertyFragments {
				queryPropertyFragments = append(queryPropertyFragments, queryBaseFragment+key+`_`+fragment)
			}

		// in the case of string not much has to be done but this case does not occour because the values are always lists of maps/objects
		case string:
			propertyFragment := key + `: "` + propertyValue + `", `
			queryPropertyFragments = append(queryPropertyFragments, propertyFragment)

		// in the case of an array of maps, every map object represents a temporal value of a property in the form of {start:_, end:_, value:_}. Create an
		// query entry for creating an own node for every of these temporal property values
		case []interface{}:

			valueList := convertMaps(propertyValue)

			// iterate over the array of maps and create a value-node query fragment for each of them (for the CREATE query)
			for i, value := range valueList {

				// generate a unique property entry for every property value in the list. Number the property fields by the index of the list
				valueFragmentStart := key + `_` + fmt.Sprint(i) + `_` + `start` + `: "` + fmt.Sprint(value["Start"]) + `", `
				valueFragmentEnd := key + `_` + fmt.Sprint(i) + `_` + `end` + `: "` + fmt.Sprint(value["End"]) + `", `
				valueFragmentValue := key + `_` + fmt.Sprint(i) + `_` + `value` + `: `
				switch valueType := value["Value"].(type) {
				case string:
					valueFragmentValue += `"` + valueType + `", `
				default:
					valueFragmentValue += fmt.Sprint(valueType) + `, `
				}

				queryPropertyFragments = append(queryPropertyFragments, []string{valueFragmentStart, valueFragmentEnd, valueFragmentValue}...)
			}

		default:
			propertyFragment := key + `: ` + fmt.Sprint(propertyValue) + `, `
			queryPropertyFragments = append(queryPropertyFragments, propertyFragment)
		}
	}
	return queryPropertyFragments
}

func loadJsonData(path string) ([]map[string]interface{}, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	// Decode the JSON data
	var data []map[string]interface{}
	err = json.NewDecoder(file).Decode(&data)
	if err != nil {
		return nil, err
	}

	return data, nil
}

func convertMaps(originalMaps []interface{}) []map[string]interface{} {
	convertedMaps := make([]map[string]interface{}, 0)
	for _, originalMap := range originalMaps {
		convertedMap := map[string]interface{}{}
		for key, value := range originalMap.(map[string]interface{}) {
			convertedMap[key] = value.(interface{})
		}
		convertedMaps = append(convertedMaps, convertedMap)
	}
	return convertedMaps
}

// ### old function from testprojeckt ###
func load_data(ctx context.Context, uri, username, password string, cmp []comp) (string, error) {
	driver, err := neo4j.NewDriverWithContext(uri, neo4j.BasicAuth(username, password, ""))
	if err != nil {
		return "", err
	}
	defer driver.Close(ctx)
	fmt.Println("check 2")

	session := driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	defer session.Close(ctx)

	// fmt.Println("check 3")
	// _, err = session.ExecuteWrite(ctx, func(transaction neo4j.ManagedTransaction) (any, error) {
	// 	result, err := transaction.Run(ctx,
	// 		"CREATE (a:Computer) SET a.message = $message",
	// 		map[string]any{"message": "available"})
	// 	if err != nil {
	// 		return nil, err
	// 	}

	// 	if result.Next(ctx) {
	// 		return result.Record().Values[0], nil
	// 	}
	// 	fmt.Println("check 4")

	// 	return nil, result.Err()
	// })

	// _, err = session.ExecuteWrite(ctx, func(transaction neo4j.ManagedTransaction) (any, error) {
	// 	fmt.Println("check 5.1")
	// 	result, err := transaction.Run(ctx, "WITH [{id:1,some_data: 'testdata',is_ts:true},{id:2,some_data:'testdata',is_ts:false}] as nodes UNWIND nodes AS node MERGE (computer:Computer {id: node.id, someData: node.some_data, isTs: node.is_ts }) SET computer += node RETURN computer",
	// 		map[string]any{})

	// 	if err != nil {
	// 		return nil, err
	// 	}

	// 	if result.Next(ctx) {
	// 		return result.Record().Values[0], nil
	// 	}
	// 	fmt.Println("check 4")

	// 	return nil, result.Err()
	// })

	_, err = session.ExecuteWrite(ctx, func(transaction neo4j.ManagedTransaction) (any, error) {
		fmt.Println("check 5.1")
		comp_list := []map[string]interface{}{
			{
				"id":        11,
				"some_data": "testdata",
				"is_ts":     true,
			},
			{
				"id":        22,
				"some_data": "testdata",
				"is_ts":     false,
			},
		}
		result, err := transaction.Run(ctx, "UNWIND $nodes AS node MERGE (computer:Computer {id: node.id, some_data: node.some_data, is_ts: node.is_ts }) SET computer += node RETURN computer",
			map[string]any{"nodes": comp_list})

		if err != nil {
			fmt.Println("check 5.2")
			fmt.Printf("Error: %v", err)
			return nil, err
		}

		if result.Next(ctx) {
			fmt.Println("check 5.3")
			return result.Record().Values[0], nil
		}
		fmt.Println("check 4")

		return nil, result.Err()
	})

	if err != nil {
		return "", err
	}

	fmt.Println("check 5")
	return "success", nil
}
